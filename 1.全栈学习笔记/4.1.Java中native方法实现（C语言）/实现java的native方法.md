# `java`中`native`方法与`C`的交互方式

##### :hear_no_evil:*技术搬运工：[默凡语](https://github.com/MoFany)*

***具体技术请参考`JNI`（java native interface）规范：***

| 开发工具 | 基本步骤描述                                                 |
| -------- | ------------------------------------------------------------ |
| IDEA UI  | 新建一个公共（public）类，其中包含一些底层用C实现的公共（public）的native方法 |
| CMD      | 在cmd下编译含有`native方法`的类从而生成关于C的头文件`headfile.h` |
| DEV C++  | 新建Basci模块下的`dll项目`                                   |

## IDEA中需要进行的操作：

>* 先创建一个公共类然后创建一个`native`方法的声明。（C语言中这个属于函数原型的声明）
>
>  ```java
>  package extern;
>  
>  /**
>   * @author MoFany-J
>   * @date 2022/10/19
>   * @description NativeDemo 自定义native方法的类
>   */
>  public class NativeDemo {
>      //这个方法的实现我们利用C语言编写
>      public native void print();
>  }
>  ```
>

## CMD中需要进行的操作：

>* ~~cmd下利用`javac命令`编译自定义的包含`native方法的类NativeDemo.java`，从而生成其字节码文件`NativeDemo.class`。~~**无需该步骤**
>
>* 命令格式：
>
>  ```bash
>  #利用javac编译java源文件生成字节码文件
>  javac 类名.java
>  ```
>
>  * ~~目录`E:\IDEA-workspace\javaproject1\src\extern>`下输入下面的命令：~~
>
>    ```properties
>    javac NativeDemo.java
>    ```
>
>  * **编译会造成指令重排序**，使源代码不在按照编写的顺序执行；单线程安全，多线程危险！
>
>    ![](.\images\编译.png)
>
>* **在CMD下利用`javah命令`去生成基于当前java类`NativeDemo.java`的C语言头文件。`(头文件名构成：父包名_类名.h)`**
>
>* 命令格式：
>
>  ```bash
>  #利用javah编译java源文件生成与C语言相对应的头文件
>  javah -classpath 绝对路径 ClassName.java
>  ```
>
>  *备用命令（前提是得`cd`到父包名所在的父包）：`javah -jni 父包名.类名`*
>
>  * 目录`E:\IDEA-workspace\javaproject1\src\extern>`下输入下面的命令：
>
>    ```properties
>    #生成方式1：
>    javah -classpath E:\IDEA-workspace\javaproject1\src extern.NativeDemo
>    #生成方式2：（主要是路径上的不一致）
>    javah -classpath E:\IDEA-workspace\javaproject1\src\extern NativeDemo
>    ```
>
>  * 生成的头文件`extern_NativeDemo.h`中的内容为：
>
>    ```C
>    /* DO NOT EDIT THIS FILE - it is machine generated */
>    #include <jni.h>
>    /* Header for class extern_NativeDemo */
>    
>    #ifndef _Included_extern_NativeDemo
>    #define _Included_extern_NativeDemo
>    #ifdef __cplusplus
>    extern "C" {
>    #endif
>    /*
>     * Class:     extern_NativeDemo
>     * Method:    print
>     * Signature: ()V
>     */
>    JNIEXPORT void JNICALL Java_extern_NativeDemo_print
>      (JNIEnv *, jobject);
>    
>    #ifdef __cplusplus
>    }
>    #endif
>    #endif
>    ```
>
>  * 头文件中声明的函数的原型：
>
>    * C语言中进行方法声明时可以省略形参变量名，但是形参类型不能省略。
>
>    * C语言中通过关键字`extern`对一个函数进行跨文件式的作用域扩展，即声明函数来自于外部某源文件。
>
>      ```c
>      //函数声明原型时，形参变量名可省略，但是形参类型必须保留
>      JNIEXPORT void JNICALL Java_extern_NativeDemo_print(JNIEnv *, jobject);
>      
>      //等价于以下函数的原型声明（函数原型实现时不能省略参数名）
>      JNIEXPORT void JNICALL Java_extern_NativeDemo_print(JNIEnv* a, jobject b);
>      ```
>
>    * 通过上述函数的原型声明发现，由`javah`编译的头文件中的方法声明的构成格式：
>
>      ```properties
>      Java_包名_类名_方法名
>      ```
>
>      #### 我们发现一个问题：
>
>      * java中定义的这个native方法是无参的。
>
>        ```java
>        /**
>         * java
>         */
>        public native void print();
>        ```
>
>      * 通过`javah`命令生成的关于C语言头文件里的函数原型声明却是有参的。
>
>        ```c
>        /**
>         * C
>         */
>        Java_extern_NativeDemo_print(JNIEnv *, jobject);
>        ```
>
>      * **那这些生成的参数的作用具体又是什么呢？**
>
>        * **使用`javah`生成native方法对应的C中的函数声明，会发现所有的native函数的第一个参数永远是`JNIEnv*`，而第二个参数永远是`jobject`或`jclass`中的一个。**==(也就是这也参数是自动生成的，除去这些参数该函数依旧无参)==
>
>        * 参数列表中第一个参数：
>
>          * `JNIEnv *（指针类型）`：该参数是一个指向`JNIEnv`类型数据的指针变量，其代表java本地接口环境（Java Native Interface Environment），是一个JNI接口指针，其指向了本地方法的一个函数表，该函数表中的每一个成员又指向了一个JNI函数，而本地方法又通过JNI函数来访问JVM中的数据结构。
>
>          ![](.\images\JNI指针.png)
>
>        * 参数列表中第二个参数：（只会有一个）
>
>          * `jobject（类型）`：当java中声明的`native`方法是一个实例方法时，在C中就会出现该参数。
>          * `jclass（类型）`：当java中声明的`native`方法是一个类方法（static静态方法）时，在C中就会出现该参数。
>
>* ~~最终包结构：~~
>
>  ![](.\images\类的包结构.png)
>

## ==**DEV C++中需要进行的操作：**==

>#### C中对Java类`NativeDemo`中的`public native void print()`方法的具体实现
>
>1. 在DEV C++下创建Basic模块下的dll项目。
>
>2. **从jdk安装目录里的include文件夹下将`jni.h`与`jni_md.h`两个头文件复制到C的如下位置处：**
>
>   * C安装位置下的include文件夹下放入这两个头文件：
>
>   ![](.\images\所需头文件.png)
>
>   * 在当前C项目里的`.dll文件`所在目录下也放入这两个头文件：
>
>     ![](.\images\c项目.png)
>
>   * ***这种引入方式的区别在于在编写C代码时引入头文件的符号用了`<>`还是`“”`。***
>
>3. 该项目下放入头文件与函数的实现。
>
>   * 头文件
>
>     ```c
>     /* DO NOT EDIT THIS FILE - it is machine generated */
>     #include <jni.h>
>     /* Header for class extern_NativeDemo */
>     
>     #ifndef _Included_extern_NativeDemo
>     #define _Included_extern_NativeDemo
>     #ifdef __cplusplus
>     extern "C" {
>     #endif
>     /*
>      * Class:     extern_NativeDemo
>      * Method:    print
>      * Signature: ()V
>      */
>     JNIEXPORT void JNICALL Java_extern_NativeDemo_print
>       (JNIEnv *, jobject);
>     
>     #ifdef __cplusplus
>     }
>     #endif
>     #endif
>     ```
>
>   * 函数实现
>
>     * C语言中头文件引入中`<>`与`“”`的区别：
>       * 函数库文件包含：`#include <headfile.h>`表示直接去C的安装位置下的`include文件夹`下匹配头文件。
>       * 本地文件包含：`“headfile.h”`表示先在当前项目下匹配头文件，若无就去C安装位置的`include文件夹`下去匹配。
>
>     ```c
>     #include <jni.h>
>     #include <stdio.h>
>     #include "extern_NativeDemo.h"
>     //在C中实现头文件中声明的函数原型时，必须指定函数的参数变量名不能省略
>     JNIEXPORT void JNICALL Java_extern_NativeDemo_print(JNIEnv* param, jobject obj) {
>     	printf("Hello World!\n");
>     }
>     ```
>
>   * 然后编译当前项目，记录`dll`动态链接库的地址
>
>     * `E:\C\Dev C++ Works\Java_nativeMethod\java_native.dll`

## 编写测试类（回到IDEA）

>* 创建一个测试类用于测试`NativeDemo`类中的` print()`本地方法。
>
>  * 利用`Runtime.getRuntime().load(name)`去加载指定路径下的C项目中生成的动态链接库文件。
>
>    * 参数`name`是一个绝对地址的文件。
>
>      ```java
>      Runtime.getRuntime().load("E:/C/Dev C++ Works/Java_nativeMethod/java_native.dll");
>      ```
>
>  * 利用`System.load(name)`去加载指定路径下的C项目中生成的动态链接库文件。
>
>    * 参数`name`参数是一个绝对地址的文件。
>
>      ```java
>      System.load("E:/C/Dev C++ Works/Java_nativeMethod/java_native.dll");
>      ```
>
>  ```java
>  package extern;
>  
>  import extern.NativeDemo;
>  
>  /**
>   * @author MoFany-J
>   * @date 2022/10/19
>   * @description Test 测试类
>   */
>  public class Test {
>      public static void main(String[] args) {
>          //利用静态方法load(),去加载一个动态连接库文件
>          System.load("E:/C/Dev C++ Works/Java_nativeMethod/java_native.dll");
>          NativeDemo test=new NativeDemo();
>          //方法测试
>          test.print();
>      }
>  }
>  ```
>
>  ***运行结果：***
>
>  ```properties
>  Hello World!
>  
>  Process finished with exit code 0
>  ```
>
>  #### 所以我们可以在联合开发（使用C/C++）的时候使用`native`关键字去声明一些原生函数，然后通过C去在底层实现这些native方法对应的`函数原型`；native关键字声明的方法的具体实现我们是查看不了的，因为它的具体实现是在C中。