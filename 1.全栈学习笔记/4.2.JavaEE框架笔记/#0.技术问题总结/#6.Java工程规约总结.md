# Java 工程规约

## 包命名规约

>#### 包名含义
>
>* `PO`：persistant object 持久对象,是与数据库中的表相映射的java对象。最简单的PO就是对应数据库中某个表中的一条记录，多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作。
>* `VO`：value object值对象。通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象,可以和表对应,也可以不,这根据业务的需要。
>* `POJO`：plain ordinary java object ,简单无规则java对象，只有一些属性和属性对应的setter和getter方法，tostring（）方法，前面提到的PO和VO都可以归为POJO。
>* `DTO`：data transfer object 数据传输对象，有时我们仅仅需要获得某个表的几个字段，所以此时用PO对象就有点大材小用了，我们就可以用DTO来存储这几个字段。可以把它理解为VO
>* `DAO`：data access object 数据访问对象，此对象用于访问数据库。通常和PO结合使用，DAO中包含了各种数据库的操作方法。通过它中的方法,结合PO对数据库进行相关的操作。
>* `BIZ`：其名称就是商业的简写，也就是其对应的是业务层，此包里的对象通过调用DAO中的对象里的方法来完成业务层上的操作，其目的是封装对数据库的操作。
>* `Service`： 我现在做的项目里是在这个包里只放接口，有的是把此包当成业务层biz，
>* `ServiceImpl `： 此包中的对象为实现Service里的接口类
>
>#### java中各个层次
>
>* Modle 层 ：存放你的实体类
>* Dao层 ：主要做数据库的交互工作
>* Biz层 ：做相应的业务逻辑处理
>* Action层：是一个控制器
>
>#### Modle 模型层 ：
>
>* 一般是实体对象(把现实的的事物变成java中的对象，对应前面提到的po，vo，dto)，作用是暂时存储数据方便持久化（存入数据库或者写入文件）
>
>#### Dao 数据访问层 ： 
>
>* 就是用来访问数据库实现数据的持久化（把内存中的数据永久保存到硬盘中 ）
>
>#### Biz 也叫做Service层：
>
>* 在此层做相应的业务逻辑处理
>
>#### Action层：
>
>* 业务层的一部分，是一个管理器 （总开关）（作用是取掉转）（取出前台界面的数据，调用biz方法，转发到下一个action或者页面）
>
>

## LomBok使用规约

>#### 强迫队友
>
>Lombok插件的使用，要求开发者一定要在IDE中安装对应的插件。不仅自己要安装，任何和你协同开发的人都要安装。
>
>如果有谁未安装插件的话，使用IDE打开一个基于Lombok的项目的话会提示找不到方法等错误，导致项目编译失败。
>
>更重要的是，如果我们定义的一个jar包中使用了Lombok，那么就要求所有依赖这个jar包的所有应用都必须安装插件，这种侵入性是很高的。
>
>只次一点，我就已经决定不在自己的代码中使用Lombok注解了，但是，为了项目编译我依然会使用Lombok插件。
>
>#### 代码可调试性降低
>
>Lombok确实可以帮忙减少很多代码，因为Lombok会帮忙自动生成很多代码。
>
>但是，这些代码是要在编译阶段才会生成的，所以在开发的过程中，其实很多代码其实是缺失的。
>
>这就给代码调试带来一定的问题，我们想要知道某个类中的某个属性的getter方法都被哪些类引用的话，就没那么简单了。
>
>#### 影响版本升级
>
>Lombok对于代码有很强的侵入性，就可能带来一个比较大的问题，那就是会影响我们对JDK的升级。
>
>按照如今JDK的升级频率，每半年都会推出一个新的版本，但是Lombok作为一个第三方工具，并且是由开源团队维护的，那么他的迭代速度是无法保证的。
>
>所以，如果我们需要升级到某个新版本的JDK的时候，若其中的特性在Lombok中不支持的话就会受到影响。
>
>还有一个可能带来的问题，就是Lombok自身的升级也会受到限制。
>
>因为一个应用可能依赖了多个jar包，而每个jar包可能又要依赖不同版本的Lombok，这就导致在应用中需要做版本仲裁，而我们知道，jar包版本仲裁是没那么容易的，而且发生问题的概率也很高。
>
>#### 踩过的坑
>
>在使用Lombok过程中，如果对于各种注解的底层原理不理解的话，很容易产生意想不到的结果。
>
>举一个简单的例子：
>
>我们知道，当我们使用@Data定义一个类的时候，会自动帮我们生成[equals](https://so.csdn.net/so/search?q=equals&spm=1001.2101.3001.7020)()方法 。
>
>但是如果只使用了@Data，而不使用@EqualsAndHashCode(callSuper=true)的话，会默认是@EqualsAndHashCode(callSuper=false)，这时候生成的equals()方法只会比较子类的属性，不会考虑从父类继承的属性，无论父类属性访问权限是否开放，这就可能得到意想不到的结果。
>
>#### 可能会破坏封装性
>
>如果说上面的4点问题都可以人为避免，那么，关于封装性的问题就是Lombok的短板了。
>
>举个简单的例子，我们定义一个购物车类：
>
>```java
>@Data
>public class ShoppingCart { 
>
>    //商品数目
>    private int itemsCount; 
>
>    //总价格
>    private double totalPrice; 
>
>    //商品明细
>    private List items = new ArrayList<>();
>}
>```
>
>我们知道，购物车中商品数目、商品明细以及总价格三者之前其实是有关联关系的，如果需要修改的话是要一起修改的。
>
>但是，我们使用了Lombok的@Data注解，对于itemsCount 和 totalPrice这两个属性，虽然我们将它们定义成 private 类型，但是提供了 public 的 getter、setter 方法。
>
>外部可以通过 setter 方法随意地修改这两个属性的值，我们可以随意调用 setter 方法，来重新设置 itemsCount、totalPrice 属性的值，这也会导致其跟 items 属性的值不一致。
>
>而面向对象封装的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，暴露不应该暴露的 setter 方法，明显违反了面向对象的封装特性。
>
>好的做法应该是不提供getter/setter，而是只提供一个public的addItem方法，同时取修改itemsCount、totalPrice以及items三个属性。
>
>### 4、总结
>
>Lombok注解可以自动生成代码，大大减少了代码量，使代码非常简洁。
>
>但是并不意味着Lombok的使用没有任何问题，在使用Lombok的过程中，还可能存在对队友不友好、对代码不友好、对调试不友好、对升级不友好等问题。
>
>虽然，使用Lombok还会导致破坏封装性的问题，但是我更认为Lombok的操作是遵循了Bean的使用初衷。
>
>Bean尤其数据库和Java类的映射Bean，Java对Bean的定义和使用就是无参数的构造方法和set和get方法，而不应该在bean中处理任何和业务有任何关系的逻辑。