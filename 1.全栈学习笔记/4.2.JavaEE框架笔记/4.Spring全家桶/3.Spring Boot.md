# Spring Boot 准备篇

##### :panda_face:Author：MoFany-J

###### SpringBoot遵循约定优于配置的原则，而少量的配置我们一般写在其全局配置文件`application.yml`中

## SpringBoot注解开发前必须熟知五大元注解

> #### **@Target**`标识注解的作用对象`
>
> * `TYPE`作用于类型，即类类型、接口类型、枚举类型
> * `FIELD`作用于字段，即成员属性
> * `METHOD`作用于参数
> * `PARAMETER`作用于参数
> * `CONSTRUCTOR`作用于构造器
> * `LOCAL_VARIABLE`作用于本地变量，即局部变量
> * `ANOTATION_TYPE`作用于注解类型
> * `PACKAGE`作用于包
> * `TYPE_PARAMETER`作用于类型参数，即泛型
> * `TYPE_USE`作用于类型使用
> * `MODULE`作用于模块
>
> #### **@Retention**`标识注解保留策略`
>
> * `RESOURCE`源码中保留
> * `CLASS`字节码文件中保留**默认保留策略**
> * `RUNTIME`运行时保留**此时可以反射获取注解及注解信息**
>
> #### **@Repeatable**`标识注解可重复使用`
>
> * 默认情况下一个注解不能多次作用于同一个元素
> * **`Anotation.class`标识自定义注解可以多次作用于同一元素**
>
> #### **@Documented**`标识注解可以包含在doc生成文档中`
>
> #### **@Inherited**`标识注解可被作用类的子类继承`

## 注解的嵌套定义:accept:

>```java
>package com.mofany.customAnnotation;
>
>import java.lang.annotation.ElementType;
>import java.lang.annotation.Inherited;
>import java.lang.annotation.Retention;
>import java.lang.annotation.RetentionPolicy;
>import java.lang.annotation.Target;
>
>/**
> *
> * @author mofany-j 自定义嵌套注解
> */
>@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})
>@Retention(RetentionPolicy.RUNTIME)
>@Inherited
>public @interface SuperAnnotation {
>
>    /**
>     * 外部注解的属性
>     */
>    String supValue() default "";
>    
>    /**
>     * 外部注解里使用定义好的内部注解
>     */
>    SubAnnotation[] includes() default {};
>    
>    SubAnnotation[] excludes() default {};
>
>    /**
>     * 内部注解
>     */
>    @Target({})
>    @Retention(RetentionPolicy.RUNTIME)
>    @interface SubAnnotation {
>
>        /**
>         * 内部注解的属性
>         */
>        String subValue() default "";
>    }
>}
>```
>
>* ##### 嵌套注解的运用
>
>  ```java
>  package com.mofany.entity;
>  
>  import com.mofany.customAnnotation.SuperAnnotation;
>  import com.mofany.customAnnotation.SuperAnnotation.SubAnnotation;
>  
>  /**
>   *
>   * @author mofany-j 嵌套注解的应用
>   */
>  @SuperAnnotation(
>          supValue = "外部注解属性赋值", 
>          includes = {@SubAnnotation(subValue="1.1"),@SubAnnotation(subValue="1.2")},
>          excludes = {@SubAnnotation(subValue="2.1"),@SubAnnotation(subValue="2.2")}
>  )
>  public class Animals {
>      //测试类
>  }
>  ```

## 使用SpringBoot前必须引入SpringBoot的父工程

>1. Spring 官方的Starter通常命名为：***`spring-boot-starter-(名字)`***，如：`spring-boot-starter-web` 。
>2. Spring 建议非官方的Starter命名为：***`(名字)-spring-boot-starter`***，如：`mybatis-spring-boot-starter`。
>
>#### 当前项目工程必须做为SpringBoot父工程的子工程
>
>```xml
><parent>
>    <groupId>org.springframework.boot</groupId>
>    <artifactId>spring-boot-starter-parent</artifactId>
>    <version>2.0+ 版本</version> 
>   	<!-- 
><version>2.7.7 版本</version>
> 	-->
>    <relativePath/>
></parent>
>```
>
>#### 限定SpringBoot其余依赖的版本`解决单继承问题`
>
>* 解决多模块pom重构
>* 解决父子模块之间的单继承——依赖传递
>
>```xml
><properties>
>    <maven.compiler.source>11</maven.compiler.source>
>    <maven.compiler.target>11</maven.compiler.target>
>    <!-- 多模块pom重构 -->
>    <spring-boot.version>2.7.7</spring-boot.version>
></properties>
>
><!-- 子模块的依赖管理 -->
><dependencyManagement>
>	<dependencies>
>        <dependency>
>            <groupId>org.springframework.boot</groupId>
>            <artifactId>spring-boot-dependencies</artifactId>
>            <version>${spring-boot.version}</version>
>            <!-- 打包方式 -->
>            <type>pom</type>
>            <!-- 
>				不存在依赖传递，只能用在：dependencyManagement
>				且只能用在当前dependency下type=pom的依赖中
> 			-->
>            <scope>import</scope>
>        </dependency>
>    </dependencies>
></dependencyManagement>
>```

# SpringBoot聚合项目的Maven重构

## 多模块项目中`POM`依赖管理

>###### 	使用 dependencyManagement 的时候，我们可以不从父模块继承，而是使用特殊的 import scope 依赖。
>
>###### 	我们知道 Maven 的继承和 Java 的继承一样，是无法实现多重继承的，如果 10 个、20 个甚至更多模块继承自同一个模块，那么按照我们之前的做法，这个父模块的 dependencyManagement 会包含大量的依赖。如果你想把这些依赖分类以更清晰的管理，那就不可能了，但是import scope 依赖能解决这个问题。你可以把 dependencyManagement 放到单独的专门用来管理依赖的 POM 中，然后在需要使用依赖的模块中通过 import scope 依赖，就可以引入 dependencyManagement。
>
>#### 父模块
>
>```xml
><project>
>  <modelVersion>4.0.0</modelVersion>
>  <groupId>com.juvenxu.sample</groupId>
>  <artifactId>sample-dependency-infrastructure</artifactId>
>  <packaging>pom</packaging>
>  <version>1.0-SNAPSHOT</version>
>    
>  <dependencyManagement>
>    <dependencies>
>        <dependency>
>          <groupId>junit</groupId>
>          <artifactId>junit</artifactId>
>          <version>4.8.2</version>
>          <scope>test</scope>
>        </dependency>
>        <dependency>
>          <groupId>log4j</groupId>
>          <artifactId>log4j</artifactId>
>          <version>1.2.16</version>
>        </dependency>
>    </dependencies>
>  </dependencyManagement>
></project>
>```
>
>#### 子模块`非继承的方式引入依赖管理`
>
>```xml
><!-- 直接导入父模块 -->  
><dependencyManagement>
>  <dependencies>
>      <dependency>
>        <groupId>com.juvenxu.sample</groupId>
>        <artifactId>sample-dependency-infrastructure</artifactId>
>        <version>1.0-SNAPSHOT</version>
>        <type>pom</type>
>        <scope>import</scope>
>      </dependency>
>  </dependencies>
></dependencyManagement>
>
><!-- 使用父模块约定的依赖 -->
><dependency>
>  <groupId>junit</groupId>
>  <artifactId>junit</artifactId>
></dependency>
><dependency>
>  <groupId>log4j</groupId>
>  <artifactId>log4j</artifactId>
></dependency>
>```

## 消除多模块插件配置重复

>###### 与 dependencyManagement 类似的，我们也可以使用 pluginManagement 元素管理插件。一个常见的用法就是我们希望项目所有模块的使用 Maven Compiler Plugin 的时候，都使用 Java 1.5，以及指定 Java 源文件编码为 UTF-8，这时可以在父模块的 POM 中如下配置 pluginManagement：
>
>```xml
><build>
>  <pluginManagement>
>    <plugins>
>      <plugin>
>        <groupId>org.apache.maven.plugins</groupId>
>        <artifactId>maven-compiler-plugin</artifactId>
>        <version>2.3.2</version>
>        <configuration>
>          <source>1.5</source>
>          <target>1.5</target>
>          <encoding>UTF-8</encoding>
>        </configuration>
>      </plugin>
>    </plugins>
>  </pluginManagement>
></build>
>```
>
>###### 这段配置会被应用到所有子模块的 maven-compiler-plugin 中，由于 Maven 内置了 maven-compiler-plugin 与生命周期的绑定，因此子模块就不再需要任何 maven-compiler-plugin 的配置了。
>
>###### 与依赖配置不同的是，通常所有项目对于任意一个依赖的配置都应该是统一的，但插件却不是这样，例如你可以希望模块 A 运行所有单元测试，模块 B 要跳过一些测试，这时就需要配置 maven-surefire-plugin 来实现，那样两个模块的插件配置就不一致了。这也就是说，简单的把插件配置提取到父 POM 的 pluginManagement 中往往不适合所有情况，那我们在使用的时候就需要注意了，只有那些普适的插件配置才应该使用 pluginManagement 提取到父 POM 中。
>
>###### 关于插件 pluginManagement，Maven 并没有提供与 import scope 依赖类似的方式管理，那我们只能借助继承关系，不过好在一般来说插件配置的数量远没有依赖配置那么多，因此这也不是一个问题。

# SpringBoot 配置篇

## SpringBoot 核心配置文件

>* **核心配置文件的两个格式`注意对比两个格式配置文件的区别与简约程度`**
>
>  #### application.properties格式
>
>  ```properties
>  #配置服务器端口号
>  server.port=8081
>  
>  #配置SpringBoot
>  spring.application.name=HelloSpringBoot
>  spring.mvc.servlet.path=/HelloSpringBoot
>  spring.datasource.username=root
>  spring.datasource.password=Jiangmh220
>  spring.datasource.url=jdbc:mysql://localhost:3306/DatabaseName?ServerTimezone=GMT%2B8
>  spirng.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
>  
>  #启动debug模式
>  debug=true
>  ```
>
>  #### application.yml格式`利用类似于Python的书写格式大大简化了重复词`
>
>  ```yaml
>  #配置服务器端口号
>  server:
>    port: 8081
>  
>  #配置springBoot
>  spring:
>    application:
>      name: HelloSpringBoot
>    mvc:
>      servlet:
>        path: /HelloSpringBoot
>    datasource:
>      username: root
>      password: Jiangmh220
>      url: jdbc:mysql://localhost:3306/DatabaseName?ServerTimezone=GMT%2B8
>      driver-class-name: com.mysql.cj.jdbc.Driver
>  
>  #启动debug模式
>  debug: true
>  ```
>
>* **多核心配置文件**
>
>  #### 多核心配置文件也有两种格式：
>
>  1. ##### application-`dev`.yaml`开发环境`
>
>  2. ##### application-`prod`.yaml`生产环境`
>
>  3. ##### application-`test`.yaml`测试环境`
>
>### SpringBoot全局配置文件键值参数详解
>
>* 服务器端口配置
>
>  ```properties
>  server.port=8081
>  ```
>
>* Spring配置
>
>  ```properties
>  #激活当前服务器要使用的配置文件，默认使用application.properties文件
>  #要开启哪一个配置文件的使用，只需要激活文件的profile
>  # 环境有三种： dev|test|prod
>  #application-dev.properties/application-dev.yml
>  spring.profiles.active=dev
>  #application-pro.properties/application-prod.yml
>  spring.profiles.active=prod
>  
>  #配置SpringBoot应用名
>  spring.application.name=HelloSpringBoot
>  #配置访问的根路径，及端口号后要跟/HelloSpringBoot
>  spring.mvc.servlet.path=/HelloSpringBoot
>  #配置数据源属性
>  spring.datasource.username=root
>  spring.datasource.password=Jiangmh220
>  spring.datasource.url=jdbc:mysql://localhost:3306/DatabaseName?ServerTimezone=GMT%2B8
>  spirng.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
>  ```
>
>#### :boxing_glove:实际开发中项目分为生产环境与测试环境，故配置的时候也要分开配置
>
>* ***`xxx.properties格式`***
>
>  * **`application.properties 全局配置`**
>
>    ```properties
>    server.port=8081
>    #重点：激活开发环境配置的当前使用
>    spring.profiles.active=dev
>    ```
>
>  * **`application-prod.properties 生产环境配置`**
>
>    ```properties
>    server.port=8082
>    ```
>
>  * **`application-dev.properties 开发环境配置`此时系统启动时将加载该配置文件**
>
>    ```properties
>    server.port=8083
>    ```
>
>* ***`xxx.yaml格式`.yaml <==> .yml***
>
>  * **`application.yml 全局配置`**
>
>    ```yaml
>    server:
>    	port: 8081
>    
>    #重点：激活开发环境配置的当前使用
>    spring:
>    	profiles:
>    		active: dev
>    ```
>
>  * **`application-prod.yml 生产环境配置`**
>
>    ```yaml
>    server:
>    	port: 8082
>    ```
>
>  * **`application-dev.yml 开发环境配置`此时系统启动时将加载该配置文件**
>
>    ```yaml
>    server:
>    	port: 8083
>    ```
>
## `YAML`的使用说明:baby_bottle:

>#### 多文档支持
>
>* 您可以在一个YAML文件中包含多个YAML文档，以使文件组织或数据解析更加容易。
>
>* 每个文档之间的分隔都用三个破折号（`---`）标记。
>
>  ```yaml
>  ---
>  player: playerOne
>  action: attack (miss)
>  ---
>  player: playerTwo
>  action: attack (hit)
>  ---
>  ```
>
>* ***同样（`...`）表示文档结束***
>
>  ```yaml
>  #begin
>  ---
>  
>  #content
>  
>  ...
>  #end
>  ```
>
>#### 内置注释
>
>* YAML允许您使用`#`，类似于Python注释向文件添加注释。
>
>  ```yaml
>  key: #Here is a single-line comment 
>     - value line 5
>     #Here is a 
>     #multi-line comment
>   - value line 13
>  ```
>
>#### 可续的语法
>
>* YAML文件使用类似于Python的缩进系统来显示程序的结构。您需要使用空格而不是制表符来创建缩进，以免造成混淆。
>
>* 它还削减了JSON和XML文件中的许多“噪声”格式，例如引号，括号和花括号。
>
>* 这些格式规范一起提高了YAML文件的可读性，超越了XML和JSON。
>
>  * `yaml格式`
>
>    ```yaml
>    #YAML
>     Imaro:
>     author: Charles R. Saunders
>     language: English
>     publication-year: 1981
>     pages: 224
>    ```
>
>  * `json格式`
>
>    ```yaml
>    #JSON
>    {
>      "Imaro": {
>        "author": "Charles R. Saunders",
>        "language": "English",
>         "publication-year": "1981",
>         "pages": 224,
>      }
>    }
>    ```
>
>#### 隐式与显示输入
>
>* YAML在通过自动检测数据类型在输入方面提供了多功能性，同时还支持显式输入选项。要将数据标记为某种类型，只需`!![typeName]`在值之前添加。
>
>  ```yaml
>  # The value should be an int: 类型为int
>  is-an-int: !!int 14.10
>  # Turn any value to a string: 类型为string
>  is-a-str: !!str 67.43
>  # The next value should be a boolean: 类型为boolean
>  is-a-bool: !!bool yes
>  ```
>
>#### `YAML基本语法`
>
>* 键值对
>
>  * YAML文件中的大多数内容都是键-值对的一种形式，其中键表示对的名称，而值表示链接到该名称的数据
>
>    ```yaml
>    #冒号前为键后为值，冒号后输入空格在输入值
>    <key>: <value>
>    ```
>
>* 标量与映射`Scalars and mapping`
>
>  * 标量表示单个存储的值，`相当于数据类型`。
>
>  * 标量使用映射分配给键名。当定义一个映射，该映射具有名称，冒号和空格，然后为其保留一个值。
>
>  * YAML支持常见的类型，例如整数和浮点数值，以及非数字类型的Boolean和String。
>
>  * 每个都可以用不同的方式表示，例如十六进制，八进制或指数。数学概念还有特殊类型，例如无穷大，-无穷大和非数字（`NAN`）。
>
>    ```yaml
>    integer: 25
>    hex: 0x12d4 #evaluates to 4820
>    octal: 023332 #evaluates to 9946
>    float: 25.0
>    exponent: 12.3015e+05 #evaluates to 1230150.0
>    boolean: Yes
>    string: "25"
>    infinity: .inf # evaluates to infinity
>    neginf: -.Inf #evaluates to negative infinity
>    not: .NAN #Not a Number
>    ```
>
>* String
>
>  * 字符串是代表句子或短语的、字符的集合。
>
>  * `可以使用`|`将每个字符串打印为新行，`>`可以将其打印为段落。`
>
>  * `YAML中的字符串不需要用双引号引起来`
>
>    ```yaml
>    str: Hello World
>    data: |
>       These
>       Newlines
>       Are broken up
>    data: >
>       This text is
>       wrapped and is a
>       single paragraph
>    ```
>
>* 顺序`Sequence`**数组**
>
>  * `序列是类似于列表或数组的数据结构，它们在同一键下保存多个值。它们是使用块或内联流样式定义的。`
>
>  * `块样式使用空格来构造文档。`
>
>  * 与流程样式相比，它更易于阅读，但结构却不那么紧凑。
>
>    ```yaml
>    # Shopping List Sequence in Block Style
>    shopping: 
>    - milk
>    - eggs
>    - juice
>    ```
>
>  * `流样式允许您使用方括号内联编写序列，类似于Python或JavaScript等编程语言中的数组声明。`
>
>  * Flow样式更紧凑，但一眼就很难阅读。
>
>    ```yaml
>    # Shopping List Sequence in Flow Style
>    shopping: [milk, eggs, juice]
>    ```
>
>* 字典`Dictionaries`**与Python字典复合类型一致，其就是键值对的有序集合**
>
>  * 词典是键-值对的集合，它们都嵌套在同一子组下。它们有助于将数据划分为逻辑类别，以供以后使用。
>
>  * `字典的定义就像映射一样，在字典中，您输入字典名称，冒号和一个空格，后跟一个或多个缩进key-value键值对。`
>
>    ```yaml
>    # An employee record
>    Employees: 
>    - dan:
>       name: Dan D. Veloper
>       job: Developer
>       team: DevOps
>    - dora:
>       name: Dora D. Veloper
>       job: Project Manager
>       team: Web Subscriptions
>    ```
>
>* 复杂的键引导符
>
>  * 当键是一个复杂的嵌套时，如数组或映射时，就得以？引导键
>
>    ```yaml
>    #使用列表作为键
>    ? [a,b,c]: Element
>    
>    #等价于
>    
>    ? - a
>      - b
>      - c
>    : Element
>    ```

# SpringBoot 核心篇

## :boxing_glove:SpringBoot的核心注解:boxing_glove:

> #### `@SpringBootApplication核心注解`
>
> - ***`@SpringBootApplication注解源码`***SpringBoot主配置类注解
>
>   ```java
>   /***
>    * 四个元注解，分别标识其：
>    *
>    *	1.@Target 作用对象于类型，即类、接口、枚举
>    *	2.@Retention 保留策略，运行时保留
>    *	3.@Document 文档包含，doc文档生成时包含
>    *	4.@Inheried 支持继承，被标识的类继承此注解
>    *
>    */
>   @Target({ElementType.TYPE})
>   @Retention(RetentionPolicy.RUNTIME)
>   @Documented
>   @Inherited
>   /**
>    * 三个核心注解：
>    * 
>    * 	1.@SpringBootConfiguration SpringBoot配置注解
>    *	2.@EnableAutoConfiguration 开启自动配置注解
>    *	3.@ComponentScan 组件扫描注解
>    * 
>    */
>   @SpringBootConfiguration
>   @EnableAutoConfiguration
>   /**
>    * 组件扫描注解 @ComponentScan 指定了两个排除过滤器参数
>    */
>   @ComponentScan(excludeFilters = {
>       @Filter(type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class}), 
>       @Filter(type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class})
>   })
>   public @interface SpringBootApplication {
>       
>       /**
>        * EnableAutoConfiguration 开启自动配置
>        * 
>        * 以下两个注解属性的作用为依赖排除
>        *
>        */
>       @AliasFor(annotation = EnableAutoConfiguration.class)
>       Class<?>[] exclude() default {};
>       //@AilasFor注解的意思是别名
>       @AliasFor(annotation = EnableAutoConfiguration.class)
>       String[] excludeName() default {};
>       
>       /**
>        * ComponentSan 组件扫描
>        *
>        * 以下注解属性的作用为包扫描
>        *
>        */
>       @AliasFor(annotation = ComponentScan.class, attribute = "basePackages")
>       String[] scanBasePackages() default {};
>       
>       @AliasFor(annotation = ComponentScan.class, attribute = "basePackageClasses")
>       Class<?>[] scanBasePackageClasses() default {};
>       
>       @AliasFor(annotation = ComponentScan.class, attribute = "nameGenerator")
>       Class<? extends BeanNameGenerator> nameGenerator() default BeanNameGenerator.class;
>       
>       /**
>        * Configuration 配置
>        *
>        * 以下注解属性的作用为代理Bean方法
>        * 
>        */
>       @AliasFor(annotation = Configuration.class)
>       boolean proxyBeanMethods() default true;
>   }
>   ```
>
>   #### 由以上源码发现`@SpringBootApplication`注解上作用有三个核心注解
>
>   - **@SpringBootConfiguration**
>
>   - **`核心：@EnableAutoConfiguration源码`**
>
>     ```java
>     /***
>      * 四个元注解，分别标识其：
>      *
>      *	1.@Target 作用对象于类型，即类、接口、枚举
>      *	2.@Retention 保留策略，运行时保留
>      *	3.@Document 文档包含，doc文档生成时包含
>      *	4.@Inheried 支持继承，被标识的类继承此注解
>      *
>      */
>     @Target({ElementType.TYPE})
>     @Retention(RetentionPolicy.RUNTIME)
>     @Documented
>     @Inherited
>     
>     /**
>      * 自动配置包的注解
>      */
>     @AutoConfigurationPackage
>     /**
>      * 导入自动配置选择器类
>      */
>     @Import({AutoConfigurationImportSelector.class})
>     public @interface EnableAutoConfiguration {
>         /**
>          * 已启用代替属性：开启自动配置
>          */
>         public static final String ENABLED_OVERRIDE_PROPERTY = 
>             										"spring.boot.enableautoconfiguration";
>         /**
>          * 包含两个配置的的属性
>          */
>         Class<?>[] exclude() default {};
>         
>         String[] excludeName() default {};
>     }
>     ```
>
>   - **@ComponentScan**
>
> #### `@RestController注解`
>
> - **@Controller**
> - **@ResponseBody**

## :boxing_glove:SpringBoot的`run()`与Spring的`refresh()`:boxing_glove:

> #### SpringBoot中定义配置类的三个注解
>
> - ##### 同级配置类可通过`@Import`注解集中到一个自定义的注解中，再用这个自定义的注解去定义另一个自定义配置类，最后这个自定义配置类的容器中就包含所有的用`@Import`注解导入的其它同级别的配置类的Bean。
>
> - ##### 简而言之：`所有的配置类的Bean，可以通过多种方法集合汇总到主配置类（主启动类）中。`
>
>   - **`@SpringBootApplication`** 用于定义主配置类，也就是启动类，应用上下文中只能存在一个
>   - **`@SpringBootConfiguration`** 继承自`@Configuration`用于定义配置类，并会将当前配置类内声明的一个或多个以@Bean注解标识的方法的返回值实例纳入到Spring容器中，并且实例名就是方法名。
>   - **`Configuration`** 用于定义配置类
>
> #### 核心方法1：`run()`方法执行结束则整个SpringBoot应用执行流程执行完毕
>
> ```java
> public ConfigurableApplicationContext run(String... args) {
>     //记录启动时间
> 	long startTime = System.nanoTime();
>     //创建默认上下文引导程序
> 	DefaultBootstrapContext bootstrapContext = createBootstrapContext();
> 	//配置应用上下文
>     ConfigurableApplicationContext context = null;
> 	//配置Headless属性
>     configureHeadlessProperty();
>     //获取监听器（之前设置的监听器）
> 	SpringApplicationRunListeners listeners = getRunListeners(args);
>     //启动监听器
> 	listeners.starting(bootstrapContext, this.mainApplicationClass);
> 	try {
>         //设置应用参数
> 		ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
>         //配置环境（配置准备环境）
> 		ConfigurableEnvironment environment = prepareEnvironment(...);
> 		//配置要忽略的Bean信息
>         configureIgnoreBeanInfo(environment);
>         //设置启动Banner图案，及logo
> 		Banner printedBanner = printBanner(environment);
>         //创建应用上下文
> 		context = createApplicationContext();
>         //设置应用启动程序
> 		context.setApplicationStartup(this.applicationStartup);
>         //将上下文准备好（即上下文需要内容）
> 		prepareContext(
>             //引导语境（引导上下文）
>             bootstrapContext,
>             //上下文
>             context,
>             //环境
>             environment,
>             //监听器
>             listeners,
>             //应用参数
>             applicationArguments,
>             //要打印的Banner图案
>             printedBanner
>         );
>         
>         /**
>          * 核心方法：refreshContext()-->其实调用的就是：super.refresh()方法
>          */
>         //刷新上下文
> 		refreshContext(context);
>         //刷新之后
> 		afterRefresh(context, applicationArguments);
>         
>         //求时间差：当前时间-启动时间=总耗时
> 		Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime);
> 		if (this.logStartupInfo) {
>             //参数省略
> 			new StartupInfoLogger(...);
> 		}
>         //开始执行监听器
> 		listeners.started(context, timeTakenToStartup);
>         //调用Runner
> 		callRunners(context, applicationArguments);
> 	}catch (Throwable ex) {
> 		handleRunFailure(context, ex, listeners);
> 		throw new IllegalStateException(ex);
> 	}
> 	try {
>         //求时间差：当前时间-启动时间=总耗时
> 		Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime);
>         //监听器准备监听：context与timeTakenToReady
> 		listeners.ready(context, timeTakenToReady);
> 	}catch (Throwable ex) {
> 		handleRunFailure(context, ex, null);
> 		throw new IllegalStateException(ex);
> 	}
> 	return context;
> }
> ```
>
> #### 核心方法2：`refresh()`整个spring的核心方法
>
> ```java
> @Override
> public void refresh() throws BeansException, IllegalStateException {
>     /**
>     * private final Object startupShutdownMonitor = new Object();
>     * 
>     * 刷新和销毁的同步监视器
>     */
> 	synchronized (this.startupShutdownMonitor) {
> 		StartupStep contextRefresh = this.applicationStartup.start("spring.context.refresh");
> 		// 准备用于此上下文的 bean 工厂
> 		prepareRefresh();
> 		// 这里时在子类种启动refreshBeanFactory()的地方
> 		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
> 		// Prepare the bean factory for use in this context.
> 		prepareBeanFactory(beanFactory);
> 		try {
> 			// 允许在上下文子类中对 bean 工厂进行后处理
> 			postProcessBeanFactory(beanFactory);
>             // 
> 			StartupStep beanPostProcess 
>                 = this.applicationStartup.start("spring.context.beans.post-process");
> 			// 调用在上下文中注册为 beans 的工厂处理器
> 			invokeBeanFactoryPostProcessors(beanFactory);
> 			// 注册Bean的后置处理器，在Bean创建过程中调用
> 			registerBeanPostProcessors(beanFactory);
> 			beanPostProcess.end();
>             // 对上下文中的消息源进行初始化
>             initMessageSource();
>             // 初始化上下文中的事件机制
>             initApplicationEventMulticaster();
>             // 在特定上下文子类中初始化其他特殊bean
>             onRefresh();
>             // 检查监听器Bean并且将这些Bean向容器注册
>             registerListeners();
>             // 实例化所有剩余的（非惰性初始化）单例
>             finishBeanFactoryInitialization(beanFactory);
>             // 发布容器事件，结束Refresh过程
>             finishRefresh();
> 		}catch (BeansException ex) {
> 			if (logger.isWarnEnabled()) {
> 			logger.warn("Exception encountered during context initialization - " +
> 				"cancelling refresh attempt: " + ex);
> 			}
> 			// 销毁已经创建的单例以避免单例Bean占用资源
> 			destroyBeans();
> 			// 重复 ‘active’ 标志
> 			cancelRefresh(ex);
> 			// 向调用者传递异常
> 			throw ex;
> 		}finally {
> 			// 重置 Spring 核心中的公共缓存，因为我们可能不再需要单例 bean 的元数据......
> 			resetCommonCaches();
> 			contextRefresh.end();
>         }
>     }
> }
> ```

## :boxing_glove:`SpringBoot核心自动配置原理`:boxing_glove:

> #### SpringBoot的核心就是其支持自动配置，自动配置原理及流程：
>
> 1. 当启动SpringBoot应用时，先创建`SpringApplication的对象`，在该对象的构造方法中会进行某些参数的初始化工作，**主要是判断当前应用程序的类型以及设置`初始化器和监听器`**，在这个过程中会加载整个应用程序的`spring.factories`文件，将文件的内容放到缓存对象中，方便后续获取。
>
> 2. SpringApplication对象创建完成后，开始执行`run`方法，来完成整个启动。启动过程中有两个最主要的方法：`prepareContext()`、`refreshContext()`这两个方法中完成了自动装配的核心功能。
>
> 3. 前面的处理逻辑主要解决上下文对象的创建、banner的打印、异常报告的准备工作，从而方便后续来进行调用。
>
>    - **准备上下文：**在`prepareContext()`方法中主要完成的是对上下文对象的初始化操作，包括了属性值的设置，比如环境对象，**在整个过程中有一个非常重要的方法，叫做`load()`方法，该方法主要完成一件事情，就是将当前启动类做为一个`beanDefinition`注册到`registry`中，方便后续在进行`BeanFactoryPostProcessor`调用执行的时候可以找到对应的主类，来完成对`@SpringBootApplication`、`@EnableAutoConfiguration`等注解的解析工作**。
>
>    - **刷新上下文：**在`refreshContext()`方法中会进行整个容器刷新工作，会调用spring中的`refresh()`方法，`refresh()`方法中使用了**13个非常关键的方法来完成对整个SpringBoot应用程序的启动工作**，在自动配置过程中，会调用`invokeBeanFactoryPostProcessor()`方法，而在执行**`postProcessBeanDefinitionRegistry()`**方法的时候会解析各种注解，如：`@PropertySource`、`@ComponentScan`、`@ComponentScans`、`@Bean`、`@Import`等，**但其中最主要的就是关于`@Import`注解的解析。**
>
>      ```java
>      /**
>      * 配置类后置处理器类： ConfigurationClassPostProcessor
>      * 从注册表中的配置类派生更多 Bean 定义
>      */
>      @Override
>      public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
>      	...
>          // 调用：processConfigBeanDefinitions()
>      	processConfigBeanDefinitions(registry);
>      }
>      /**
>      * 基于配置类的注册表生成并验证配置模型
>      */
>      public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
>      	...
>          // 解析每一个@Configuration标识的配置类 
>          ConfigurationClassParser parser = new ConfigurationClassParser(
>      		this.metadataReaderFactory, this.problemReporter, this.environment,
>      		this.resourceLoader, this.componentScanBeanNameGenerator, registry);
>          /**
>          * 核心
>          */
>      	do {
>              // 调用parse()解析方法去解析注解
>      		parser.parse(candidates);
>      		...
>      	}while (!candidates.isEmpty());
>      	...
>      }
>      ```
>
>      ```java
>      /**
>      * 配置类解析器类：ConfigurationClassParser
>      */
>      public void parse(Set<BeanDefinitionHolder> configCandidates) {
>      	for (BeanDefinitionHolder holder : configCandidates) {
>      		BeanDefinition bd = holder.getBeanDefinition();
>      		try {
>      				// 调用：重载方法
>      				parse(...,...);
>      		}
>      		catch (BeanDefinitionStoreException ex) {
>      			throw ex;
>      		}
>      		catch (Throwable ex) {
>                  ...
>      		}
>      	}
>          ...
>      }
>      protected final void parse(..., String beanName) throws IOException {
>          ...
>          // 调用：processConfigurationClass()
>      	processConfigurationClass(
>              new ConfigurationClass(..., beanName), DEFAULT_EXCLUSION_FILTER);
>      }
>      
>      protected void processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter) throws IOException {
>      	...
>      	do {
>              // 调用：doProcessConfigurationClass()
>      		sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);
>      	}while (sourceClass != null);
>      	...
>      }
>      /**
>      * 真正调用处理 @Import 注解的处理方法
>      */
>      @Nullable
>      protected final SourceClass doProcessConfigurationClass(
>      	ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)
>      	throws IOException {
>      
>      	// Process any @PropertySource annotations
>          // Process any @ComponentScan annotations
>      	...
>      	/***
>      	* 核心：Process any @Import annotations 处理任意一个@Import注解
>      	*/
>      	processImports(configClass, sourceClass, getImports(sourceClass), filter, true);
>          ...
>      }
>      ```
>
> 4. 在解析`@Import`注解的时候，**有一个`getImports()`方法，从`主类开始递归解析所有注解`，并将所有遇到的`@Import`注解都进行处理**，然后在`processImport（）`方法中对`Import`的类进行分类，主要是为了识别`ImportSelect`接口的实现类`AutoConfigurationImportSelector`。
>
>    ```java
>    /**
>    * 获取导入项
>    */
>    private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {
>    	// @import注解属性值的集合
>        Set<SourceClass> imports = new LinkedHashSet<>();
>    	// 已经访问过的类
>        Set<SourceClass> visited = new LinkedHashSet<>();
>        // 调用：collectImports()
>    	collectImports(sourceClass, imports, visited);
>    	return imports;
>    }
>    
>    /**
>    * 递归：主类开始递归解析所有注解将遇到的所有@Import注解全部处理
>    */
>    private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)throws IOException {
>    	// 已经访问过的类则加入 visited 已访问集合中
>    	if (visited.add(sourceClass)) {
>            // 遍历当前类上所有注解
>    		for (SourceClass annotation : sourceClass.getAnnotations()) {
>                // 获取注解名
>    			String annName = annotation.getMetadata().getClassName();
>                    // 当前注解类不是 @Import 时递归遍历
>    			if (!annName.equals(Import.class.getName())) {
>                    // 开始递归遍历当前注解类
>    				collectImports(annotation, imports, visited);
>    			}
>    		}
>            // 当前注解类是 @Import 注解时，将 @imports 注解的属性值加入 imports 集合
>    		imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"));
>    	}
>    }
>    ```
>
>    ```properties
>    # 获取到的结果就是从SpringBoot应用启动直到解析到 @Import 注解导入的内容，最后获取到两个导入的类
>    org.springframework.boot.autoconfigure.AutoConfigurationPackages$Registrar
>    org.springframework.boot.autoconfigure.AutoConfigurationImportSelector
>    ```
>
> 5. **在后续过程中又会调用`DeferredImportSelector`中的`process()`方法，完成对`EnableAutoConfiguration`的加载。**
>
>    ```java
>    /**
>    * 1.解析
>    */
>    @Override
>    public void process(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector) {
>    	Assert.state(deferredImportSelector instanceof AutoConfigurationImportSelector,
>    				() -> String.format(
>                    						"Only %s implementations are supported, got %s",
>    										AutoConfigurationImportSelector.class.getSimpleName(),
>    										deferredImportSelector.getClass().getName()
>                                   		)
>                    );
>        // 获取自动配置条目
>    	AutoConfigurationEntry autoConfigurationEntry 
>            = ((AutoConfigurationImportSelector) deferredImportSelector)	
>            .getAutoConfigurationEntry(annotationMetadata);
>        
>    	this.autoConfigurationEntries.add(autoConfigurationEntry);
>        
>    	for (String importClassName : autoConfigurationEntry.getConfigurations()) {
>    		this.entries.putIfAbsent(importClassName, annotationMetadata);
>    	}
>    }
>    
>    /**
>    * 2.获取自动配置条目
>    */
>    protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {
>        
>    	if (!isEnabled(annotationMetadata)) {
>    		return EMPTY_ENTRY;
>    	}
>    	AnnotationAttributes attributes = getAttributes(annotationMetadata);
>        // 获取后选择配置项
>    	List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);
>    	configurations = removeDuplicates(configurations);
>    	Set<String> exclusions = getExclusions(annotationMetadata, attributes);
>    	checkExcludedClasses(configurations, exclusions);
>    	configurations.removeAll(exclusions);
>    	configurations = getConfigurationClassFilter().filter(configurations);
>    	fireAutoConfigurationImportEvents(configurations, exclusions);
>    	return new AutoConfigurationEntry(configurations, exclusions);
>    }
>    ```
>
> 6. ##### 最后的最后会将Spring容器的一切配置全部汇总到自定义的启动类，即主配置类中，从而完成所有SpringBoot应用的准备、初始化、加载配置、解析配置、解析注解等等，而`@SpringBootApplication`注解就相当于SpringBoot独有的主配置类标识一样。
>
> #### 总结
>
> - ###### 先是`prepareContext()`（预准备容器）的时候加载启动类，在`refreshContext()`（刷新容器）的时候加载启动类注解以及该注解里的各种子注解，最重要的是加载 `@import `注解，而`@import`注解里了几 个类，在`getCandidateConfigurations()`方法处打一个断点就可以看一下是如何加载的了。
>
>   ```java
>   /**
>   * 3.获取候选者配置项
>   */
>   protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
>       
>      List<String> configurations = SpringFactoriesLoader
>          .loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),getBeanClassLoader());
>       
>      Assert.notEmpty(configurations, 
>                      "No auto configuration classes found in META-INF/spring.factories.");
>      return configurations;
>   }
>   
>   /**
>   * 4.获得SpringFactory加载器工厂类
>   */
>   protected Class<?> getSpringFactoriesLoaderFactoryClass() {
>   	return EnableAutoConfiguration.class;
>   }
>   
>   /**
>   * 5.开启自动配置注解
>   */
>   @Target(ElementType.TYPE)
>   @Retention(RetentionPolicy.RUNTIME)
>   @Documented
>   @Inherited
>   @AutoConfigurationPackage
>   @Import(AutoConfigurationImportSelector.class)
>   public @interface EnableAutoConfiguration {
>   	/**
>   	 * Environment property that can be used to override when auto-configuration is
>   	 * enabled.
>   	 */
>   	String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";
>   
>   	Class<?>[] exclude() default {};
>   
>   	String[] excludeName() default {};
>   }
>   ```
>
>   - `SpringFactoriesLoader`会扫描所有jar包类路径下的`META-INF/spring.factories`文件，并获取指定接口的配置。
>   - `getCandidateConfigurations()`方法获取的是`EnableAutoConfiguration`接口的配置。
>
> - ###### `spring.factories`文件本质上与properties文件相似，其中包含一组或多组键值对。其中，key的取值是接口的全限定名，value的取值是接口实现类的全限定名。一个接口可以设置多个实现类，不同实现类之间使用`,`隔开。
>
>   ```properties
>   org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
>   org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
>   org.springframework.boot.autoconfigure.aop.AopAutoConfiguration
>   ```
>
> - ###### `AutoConfigurationImportSelector`类是`ImportSelector`的实现类，实现了`selectImports()`方法。而`selectImports()`方法又调用`getAutoConfigurationEntry()`方法从`spring.factories`文件中读取配置类的全限定名列表，并进行过滤，最终得到需要自动配置的类全限定名列表。

## :accept:SpringBoot读取配置文件属性的`6种`常用方式:accept:

>#### **:a:读取全局配置文件`application.properties`**
>
>```properties
>#--application.properties
>#服务器端口
>server.port=8081
>
>#以下配置文件中属性要被指定类读取（对应于类中获取全局配置属性值的三种方式）
>#student
>student.id=1
>student.name=蒋明辉
>student.sex=男
>student.age=24
>#teacher
>teacher.jobNum=1
>teacher.name=余华
>teacher.sex=男
>teacher.subject=大学语文
>#animals
>animals.classes=Cat
>animals.name=Tom
>animals.color=white
>animals.age=3
>```
>
>1. **方法1：在自定义Controller中使用`Environment`类获取全局配置属性值（实体类中不能使用其给成员属性赋值）**
>
>   ```java
>   package com.mofany.controller;
>   
>   import org.springframework.core.env.Environment;
>   import org.springframework.web.bind.annotation.*;
>   
>   import javax.annotation.Resource;
>   import java.util.HashMap;
>   import java.util.Map;
>   
>   /**
>    * @author MoFany-J
>    * @date 2023/1/15
>    * @description MyController
>    */
>   @RestController//该注解不能返回视图
>   @RequestMapping(value = "api")
>   public class MyController {
>   
>       /**
>        * 读取配置属性值的方式1(需要Environment类实例来读取application配置文件的属性值)
>        * */
>       @Resource
>       private Environment environment;
>   
>       @GetMapping("animals/{key}")
>       @ResponseBody
>       public Map<String, Map<String, Object>> animals(@PathVariable(name = "key")String key){
>           
>           Map<String,Map<String,Object>> supMap=new HashMap<>();
>           Map<String,Object> subMap=new HashMap<>();
>           //Environment类的getProperty()方法用户获取全局配置文件中指定键的值
>           subMap.put("classes", environment.getProperty("animals.classes"));
>           subMap.put("name", environment.getProperty("animals.name"));
>           subMap.put("color", environment.getProperty("animals.color"));
>           subMap.put("age", environment.getProperty("animals.age"));
>           supMap.put(key,subMap);
>           //返回值即响应值为JSON格式
>           return supMap;
>       }
>   }
>   ```
>
>2. **方法2：实体类成员属性上使用`@Vaule`注解**
>
>   ```java
>   package com.mofany.entity;
>   
>   import lombok.Getter;
>   import lombok.NoArgsConstructor;
>   import lombok.ToString;
>   import org.springframework.beans.factory.annotation.Value;
>   import org.springframework.stereotype.Component;
>   
>   /**
>    * @author MoFany-J
>    * @date 2023/1/15
>    * @description Student
>    */
>   @Getter
>   @ToString
>   @NoArgsConstructor
>   @Component
>   public class Student {
>       /**
>        * 读取配置属性值的方式2（使用这种方式的原理就是赋值无需setter方法，故内部为赋值）
>        * */
>       @Value("${student.id}")
>       private Integer id;
>       @Value("${student.name}")
>       private String name;
>       @Value("${student.sex}")
>       private String sex;
>       @Value("${student.age}")
>       private Short age;
>   }
>   ```
>
>3. **方法3：实体类上使用`@ConfigurationProperties`注解**
>
>   ```java
>   package com.mofany.entity;
>   
>   import lombok.Getter;
>   import lombok.NoArgsConstructor;
>   import lombok.Setter;
>   import lombok.ToString;
>   import org.springframework.boot.context.properties.ConfigurationProperties;
>   import org.springframework.stereotype.Component;
>   
>   /**
>    * @author MoFany-J
>    * @date 2023/1/15
>    * @description Teacher
>    */
>   @Getter
>   @Setter
>   @ToString
>   @NoArgsConstructor
>   @Component
>   /**
>    * 读取配置属性的方式3（使用这种方式必须为属性提供setter方法，故外部为setter方法）
>    * */
>   @ConfigurationProperties(prefix = "teacher")
>   public class Teacher {
>       private Integer jobNum;
>       private String name;
>       private String sex;
>       private String subject;
>   }
>   ```
>
>   #### 接口测试结果
>
>   * 学生
>
>     ```http
>     http://localhost:8081/api/student/蒋明辉
>     ```
>
>     ```json
>     {
>     	"蒋明辉": {
>     		"sex": "男",
>     		"name": "蒋明辉",
>     		"id": 1,
>     		"age": 24
>     	}
>     }
>     ```
>
>   * 老师
>
>     ```http
>     http://localhost:8081/api/teacher/余华
>     ```
>
>     ```json
>     {
>     	"余华": {
>     		"jobName": 1,
>     		"subject": "大学语文",
>     		"sex": "男",
>     		"name": "余华"
>     	}
>     }
>     ```
>
>   * 动物
>
>     ```http
>     http://localhost:8081/api/animals/猫
>     ```
>
>     ```json
>     {
>     	"猫": {
>     		"color": "white",
>     		"classes": "Cat",
>     		"name": "Tom",
>     		"age": "3"
>     	}
>     }
>     ```
>
>#### **:b:读取其它配置文件`application-other.properties`**
>
>```properties
>#--application-dev.properties 开发测试环境配置
>server.port=8082
>
>#要获取的属性值
>development.content=test
>development.context=我是开发环境
>```
>
>```properties
>#--application-pro.properties 生产环境配置
>server.port=8083
>
>#要获取的属性值
>production.content=yield
>production.context=我是生产环境
>```
>
>* **使用`@PropertySource`注解结合`@Value`注解或`@ConfigurationProperties`注解**
>
>  * ***同时解决了配置文件中中文参数值乱码的问题***
>
>  1. **方法1：`@PropertySource+@Value`**
>
>     ```java
>     package com.mofany.controller;
>     
>     import org.springframework.beans.factory.annotation.Value;
>     import org.springframework.context.annotation.PropertySource;
>     import org.springframework.web.bind.annotation.*;
>     
>     import javax.annotation.Resource;
>     import java.util.HashMap;
>     import java.util.Map;
>     
>     /**
>      * @author MoFany-J
>      * @date 2023/1/15
>      * @description MyController
>      */
>     @RestController//该注解不能返回视图
>     @RequestMapping(value = "api")
>     /**
>      * 一次性加载多个非全局配置文件
>      * */
>     @PropertySource(
>             /**
>              * 一次性加载两个非全局配置文件
>              * */
>             value = {"application-dev.properties","application-pro.properties"},
>             /**
>              * 指定配置文件中的编码（同时解决了配置文件中中文参数乱码问题）
>              * */
>             encoding = "UTF-8")
>     public class MyController {
>     
>         /**
>          * 开发环境配置读取
>          */
>         @Value("${development.content}")
>         private String developmentContent;
>         @Value("${development.context}")
>         private String developmentContext;
>     
>         /**
>          * 生产环境配置读取
>          */
>         @Value("${production.content}")
>         private String productionContent;
>         @Value("${production.context}")
>         private String productionContext;
>     
>     
>         /**
>          * 响应开发环境的请求
>          */
>         @GetMapping("development/{key}")
>         @ResponseBody
>         public Map<String,Map<String,Object>> dev(@PathVariable(name = "key")String key){
>             Map<String,Map<String,Object>> supMap=new HashMap<>();
>             Map<String,Object> subMap=new HashMap<>();
>             subMap.put("Development-Content",developmentContent );
>             subMap.put("Development-Context",developmentContext );
>             supMap.put(key,subMap);
>             return supMap;
>         }
>         
>     	/**
>     	 * 响应生产环境的请求
>     	 */
>         @GetMapping("production/{key}")
>         @ResponseBody
>         public Map<String,Map<String,Object>> pro(@PathVariable(name = "key")String key){
>             Map<String,Map<String,Object>> supMap=new HashMap<>();
>             Map<String,Object> subMap=new HashMap<>();
>             subMap.put("Production-Content",productionContent );
>             subMap.put("Production-Context",productionContext );
>             supMap.put(key,subMap);
>             return supMap;
>         }
>     }
>     ```
>
>     #### 接口测试结果
>
>     * 生产环境
>
>       ```http
>       http://localhost:8081/api/production/生产环境
>       ```
>
>       ```json
>       {
>       	"生产环境": {
>       		"Production-Context": "我是生产环境",
>       		"Production-Content": "yield"
>       	}
>       }
>       ```
>
>     * 开发环境
>
>       ```http
>       http://localhost:8081/api/development/开发环境
>       ```
>
>       ```json
>       {
>       	"开发环境": {
>       		"Development-Context": "我是开发环境",
>       		"Development-Content": "test"
>       	}
>       }
>       ```
>
>  2. **方法2：`@PropertySource + @ConfigurationProperties`**
>
>     ```java
>     package com.mofany.controller;
>     
>     import lombok.Setter;
>     import org.springframework.boot.context.properties.ConfigurationProperties;
>     import org.springframework.context.annotation.PropertySource;
>     import org.springframework.web.bind.annotation.*;
>     
>     import javax.annotation.Resource;
>     import java.util.HashMap;
>     import java.util.Map;
>     
>     /**
>      * @author MoFany-J
>      * @date 2023/1/15
>      * @description MyController
>      */
>     @RestController
>     @RequestMapping(value = "api")
>     /**
>      * 一次性加载多个非全局配置文件
>      * */
>     @PropertySource(
>             /**
>              * 一次性加载两个非全局配置文件
>              * */
>             value = {"application-dev.properties","application-pro.properties"},
>             /**
>              * 指定配置文件中的编码（同时解决了配置文件中中文参数乱码问题）
>              * */
>             encoding = "UTF-8")
>     /**
>      * 读取前缀位production为前缀的属性值由setter方法进行JavaBean的映射
>      * */
>     @ConfigurationProperties(prefix = "production")//prefix = "development"
>     public class MyController {
>     
>         /**
>          * 限制setter方法的访问权限
>          * */
>         @Setter(AccessLevel.MODULE)
>         private String content;
>         @Setter(AccessLevel.MODULE)
>         private String context;
>     
>         @GetMapping("attribute/{key}")
>         @ResponseBody
>         public Map<String,Map<String,Object>> attr(@PathVariable(name = "key")String key){
>             Map<String,Map<String,Object>> supMap=new HashMap<>();
>             Map<String,Object> subMap=new HashMap<>();
>             subMap.put("Content",content );
>             subMap.put("Context",context );
>             supMap.put(key,subMap);
>             return supMap;
>         }
>     }
>     ```
>
>     #### 接口测试结果
>
>     * 生产环境
>
>       ```http
>       http://localhost:8081/api/attribute/生产环境
>       ```
>
>       ```json
>       {
>       	"生产环境": {
>       		"Context": "我是生产环境",
>       		"Content": "yield"
>       	}
>       }
>       ```
>
>     * 开发环境
>
>       ```http
>       http://localhost:8081/api/attribute/开发环境
>       ```
>
>       ```json
>       {
>       	"开发环境": {
>       		"Context": "我是开发环境",
>       		"Content": "test"
>       	}
>       }
>       ```
>
>#### **:ab:`字节输入流结合Properties类`读取任意配置文件的属性键值`InputStream + Properties`**
>
>```properties
>server.port=8081
>
>#配置文件中指定类中要用到的属性（类中获取配置文件属性值的三中方式）
>animals.classes=Cat
>animals.name=Tom猫
>animals.color=白色
>animals.age=3
>```
>
>1. **方式1：使用`InputStream+Properties`读取配置文件，然后由属性的键获取属性的值**
>
>   ```java
>     package com.mofany.controller;
>     
>     import org.springframework.web.bind.annotation.*;
>     
>     import java.io.IOException;
>     import java.io.InputStream;
>     import java.util.HashMap;
>     import java.util.Map;
>     import java.util.Properties;
>     
>     /**
>      * @author MoFany-J
>      * @date 2023/1/15
>      * @description MyController
>      */
>     @RestController
>     @RequestMapping(value = "api")
>     public class MyController {
>         /**
>          * 通过当前类的类加载器去获取指定资源的字节输入流实例
>          * */
>         private InputStream resourceAsStream = MyController.class.getClassLoader()
>             .getResourceAsStream("application.properties");
>         /**
>        	 * 创建Properties属性类实例
>          * */
>         private Properties properties = new Properties();
>         
>         @GetMapping("test/{key}")
>         public Map<String,Map<String,Object>> test(@PathVariable(name = "key")String key){
>             Map<String,Map<String,Object>> supMap=new HashMap<>();
>             Map<String,Object> subMap=new HashMap<>();
>             
>             try {
>     			//将资源对应的字节流实例装载到Properties实例中
>                 properties.load(resourceAsStream);
>             } catch (IOException e) {
>                 e.printStackTrace();
>             }
>             
>     		//通过getProperties()方法获取配置文件指定键的对应值
>             subMap.put("Class",properties.getProperty("animals.classes") );
>             subMap.put("Name",properties.getProperty("animals.name"));
>             subMap.put("Color",properties.getProperty("animals.color"));
>             subMap.put("Age",properties.getProperty("animals.age"));
>             supMap.put(key,subMap);
>             
>             //返回值为JSON
>             return supMap;
>         }
>     }
>   ```
>
>   #### 接口测试结果
>
>   * 动物
>
>     ```http
>     http://localhost:8081/api/test/猫
>     ```
>
>     ```json
>     {
>     	"猫": {
>     		"Color": "白色",
>     		"Class": "Cat",
>     		"Age": "3",
>     		"Name": "Tom猫"
>     	}
>     }
>     ```
>
>### SpringBoot读取配置文件属性时发生的中文乱码解决办法
>
>* **使用`application.yml`格式作为配置文件格式**
>* **使用注解`@PropertySource`并设置参数：**
>  * **`@ProertySource(value={"classpath:application.properties"},encoding="UTF-8")`**
>  * **`@ProertySource(value={"classpath:application.yml"},encoding="UTF-8")`**
>* 检查IDE工具的编码规则是否为UTF-8
>

## :accept:SpringBoot配置静态资源放行的两种方式:accept:

>#### :a:`方式1：`代码法`@Configuration--多种静态资源的放行`
>
>* 编写实现`WebMvcConfigurer`接口的配置类`GlobalWebConfig`
>
>  ```java
>  @Configuration
>  public class GlobalWebConfig implements WebMvcConfigurer{
>      
>      /**
>       * 添加资源处理器，即静态资源放行
>       * */
>      @Override
>      public void addResourceHandlers(ResourceHandlerRegistry registry) {
>          
>          //要放行的资源1
>          registry.addResourceHandler("StaticResource-URL")
>                  .addResourceLocations("classpath:/StaticResource-Path/");
>          
>          //...
>          
>          //要放行的资源n
>          registry.addResourceHandler("StaticResource-URL")
>                  .addResourceLocations("classpath:/StaticResource-Path/");
>      }
>  }
>  ```
>
>  #### 实际配置
>
>  * `启动类`
>
>    ```java
>    package com.mofany;
>    
>    import org.springframework.boot.SpringApplication;
>    import org.springframework.boot.autoconfigure.SpringBootApplication;
>    
>    /**
>     * @author MoFany-J
>     * @date 2023/1/16
>     * @description MyApplication
>     */
>    @SpringBootApplication
>    public class MyApplication {
>        public static void main(String[] args) {
>            SpringApplication.run(MyApplication.class,args);
>        }
>    }
>    ```
>
>    * config.GlobalWebConfig
>
>      ```java
>      package com.mofany.config;
>      
>      
>      import org.springframework.context.annotation.Configuration;
>      import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
>      import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
>      
>      /**
>       * @author MoFany-J
>       * @date 2023/1/16
>       * @description GlobalWebConfig 全局Web配置文件
>       */
>      @Configuration
>      public class GlobalWebConfig implements WebMvcConfigurer {
>          
>          /**
>           * 添加资源处理器，即静态资源放行
>           * */
>          @Override
>          public void addResourceHandlers(ResourceHandlerRegistry registry) {
>              
>              //视图页放行
>              registry.addResourceHandler("/templates/**")
>                      .addResourceLocations("classpath:/templates/");
>              
>              //样式放行
>              registry.addResourceHandler("/static/**")
>                      .addResourceLocations("classpath:/static/");
>              
>              //js放行...
>          }
>      }
>      ```
>
>    * ***resources***
>
>      * `application.yml`
>
>        ```yaml
>        #指定服务器端口
>        server:
>          port: 8081
>        ```
>
>      * static
>
>        * css`mycss.css`
>
>          ```css
>          /* 取消浏览器默认边距8px */
>          body{
>              padding: 0;
>              margin: 0;
>          }
>          
>          /* 字体颜色红色 */
>          .font-color-red{
>              color: red;
>          }
>          ```
>
>      * templates`index.html`
>
>        ```html
>        <!DOCTYPE html>
>        <html lang="en">
>        	<head>
>            	<meta charset="UTF-8">
>            	<title>Title</title>
>            	<link rel="stylesheet" type="text/css" href="/static/css/mycss.css">
>        	</head>
>        	<body>
>        		<h1 class="font-color-red">你好世界！</h1>
>        	</body>
>        </html>
>        ```
>
>      * ***测试的接口***
>
>        ```http
>        http://localhost:8081/templates/index.html
>        ```
>
>      * ***字与颜色都正常显示***
>
>
>#### :b:方式2：配置法`application.yaml--单一静态资源放行`
>
>* **`application.yaml配置格式`**
>
>  ```yaml
>  #application.yaml 实际可行的
>  
>  spring:
>    mvc:
>      static-path-pattern: /res/** # URL路径
>    web:
>      resources:
>        static-locations: [classpath:/haha] # URL映射的物理路径
>  ```
>
>  * 方式1：***这个会导致welcome page功能失效***
>
>    ```yaml
>    #application.yaml 可行的
>    
>    spring:
>      mvc:
>        static-path-pattern: /res/** # URL路径
>      web:
>        resources:
>          static-locations: [classpath:/haha] # URL映射的物理路径
>    ```
>
>  * 方式2：***这个会导致Favicon功能失效****
>
>    ```yaml
>    #application.yaml 由于没有指定资源的请求实际映射路径，故容器报错
>    
>    spring:
>      mvc:
>        static-path-pattern: /res/** # URL路径
>    ```
>
>    * 响应结果
>
>      ```properties
>      2023-01-18 22:47:29.561  WARN 16900 --- [nio-8081-exec-2] o.s.web.servlet.PageNotFound             : No mapping for GET /favicon.ico
>      ```
>
>  * 方式3：***禁用所有静态资源规则***
>
>    ```yaml
>    #禁用静态资源访问规则
>    
>    spring:
>      web:
>        resources:
>          add-mappings: false # 禁用所有静态资源文件规则
>    ```
>
>  * 方式4：***欢迎页`WelcomePage`映射与静态资源`StaticResource`的四大映射路径***
>
>    * WelcomePage欢迎页：`WebMvcAutoConfiguration类addResourceHandler()方法`
>
>      *  `this.mvcProperties.getStaticPathPattern()`
>
>        ```java
>        //欢迎页的URL前缀应该是/**，否则欢迎页无法访问
>        private String staticPathPattrern = "/**";
>        ```
>
>    * StaticResource静态资源映射：`WebMvcAutoConfiguration类addResourceHandler()方法`
>
>      *  `this.resourceProperties.getStaticLocations()`
>
>        ```java
>        //静态资源默认的四个访问路径
>        private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { 
>            "classpath:/META-INF/resources/",			
>            "classpath:/resources/", 
>            "classpath:/static/", 
>            "classpath:/public/" 
>        };
>        ```
>
>  #### 实际配置
>
>  * `启动类`
>
>    ```java
>    package com.mofany;
>    
>    import org.springframework.boot.SpringApplication;
>    import org.springframework.boot.autoconfigure.SpringBootApplication;
>    
>    /**
>     * @author MoFany-J
>     * @date 2023/1/16
>     * @description MyApplication
>     */
>    @SpringBootApplication
>    public class MyApplication {
>        public static void main(String[] args) {
>            SpringApplication.run(MyApplication.class,args);
>        }
>    }
>    ```
>
>  * **resources**
>
>    * static
>
>      * css`mycss.css`
>
>        ```css
>        /* 取消浏览器默认边距8px */
>        body{
>            padding: 0;
>            margin: 0;
>        }
>        
>        /* 字体颜色红色 */
>        .font-color-red{
>            color: red;
>        }
>        ```
>
>    * templates`index.html`
>
>      ```html
>      <!DOCTYPE html>
>      <html lang="en">
>      	<head>
>          	<meta charset="UTF-8">
>          	<title>Title</title>
>          	<link rel="stylesheet" type="text/css" href="/static/css/mycss.css">
>      	</head>
>      	<body>
>      		<h1 class="font-color-red">你好世界！</h1>
>      	</body>
>      </html>
>      ```
>
>    * **`application.yaml`**
>
>      ```yaml
>      # 指定服务器端口
>      server:
>        port: 8081
>      
>      # springboot静态资源放行
>      spring:
>        mvc:
>          static-path-pattern: /templates/** # 指定访问视图页的URL前缀
>        web:
>          resources:
>            static-locations:
>              - classpath:/templates/
>              - classpath:/META-INF/resources/ # 静态资源默认的四个访问路径
>              - classpath:/resources
>              - classpath:/static/
>              - classpath:/public/
>      ```
>      * 访问的接口
>
>        ```http
>        http://localhost:8081/templates/index.html
>        ```
>
>      * 访问的控制台反馈
>
>        ```properties
>        2023-01-18 21:48:08.997  WARN 2712 --- [nio-8081-exec-3] o.s.web.servlet.PageNotFound             : No mapping for GET /static/css/mycss.css
>        2023-01-18 21:48:09.766  WARN 2712 --- [nio-8081-exec-8] o.s.web.servlet.PageNotFound             : No mapping for GET /static/css/mycss.css
>        ```
>
>        * ***出现了问题：只有视图页的静态资源被放行了，即其它样式静态资源没有被放行***
>
>          * ***原因是因为`static-path-pattern`参数值只能为一个导致的问题***
>
>            ```yaml
>            spring:
>              mvc:
>                static-path-pattern: # 的值只能有一个
>            ```
>
>        * ***解决方法？***
>

##  :accept:自定义`WebMvcConfigurer`实现类:accept:

>#### 自定义全局web配置类`GlobalWebConfig`，实现无业务逻辑的视图跳转
>
>```java
>package com.mofany.config;
>
>import org.springframework.context.annotation.Configuration;
>import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
>import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
>import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
>
>/**
> * @author MoFany-J
> * @date 2023/1/18
> * @description GlobalWebConfig 全局web配置
> */
>@Configuration
>public class GlobalWebConfig implements WebMvcConfigurer {
>    /**
>     * 添加资源处理器：用于处理静态资源放行
>     * */
>    @Override
>    public void addResourceHandlers(ResourceHandlerRegistry registry) {
>
>        //样式放行
>        registry.addResourceHandler("/static/**")
>                .addResourceLocations("classpath:/static/");
>        //视图页放行
>        registry.addResourceHandler("/templates/**")
>                .addResourceLocations("classpath:/templates/");
>
>    }
>
>    /**
>     * 添加视图控制器：用于进行视图跳转(有这个存在对于简单的视图跳转可以省略视图控制器即controller)
>     * 视图跳转的页面无需进行静态资源放行
>     *
>     * 如果你的静态资源放在templates下的一个目录下则请求地址需要带上它并需要return出去
>     * */
>    @Override
>    public void addViewControllers(ViewControllerRegistry registry) {
>        //无业务逻辑跳转至登录页
>        registry.addViewController("/login")
>                .setViewName("html/login");
>
>        //无业务逻辑跳转至注册页
>        registry.addViewController("/register")
>                .setViewName("html/register");
>    }
>}
>```
>
>* 全局配置文件`application.yaml`
>
>  ```yaml
>  # 指定端口
>  server:
>    port: 8081
>  
>  # 配置Thymeleaf模版引擎
>  spring:
>    thymeleaf:
>      prefix: classpath:/templates/ 	# thymeleaf默认的根模版位置，前缀
>      suffix: .html 					#	后缀
>  ```
>
>  * 首页访问接口：
>
>    ```http
>    http://localhost:8081/templates/index.html
>    ```
>
>    * 登录页访问接口：
>
>      ```http
>      http://localhost:8081/login
>      ```
>
>    * 注册页访问接口：
>
>      ```http
>      http://localhost:8081/register
>      ```

## :fist_oncoming:SpringBoot自定义Starter:fist_oncoming:

>##### 简历一个空的Maven项目，不适用任何框架
>
>#### `pom.xml`
>
>```xml
><?xml version="1.0" encoding="UTF-8"?>
><project xmlns="http://maven.apache.org/POM/4.0.0"
>         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
>         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
>         http://maven.apache.org/xsd/maven-4.0.0.xsd">
>    <modelVersion>4.0.0</modelVersion>
>    <groupId>com.mofany</groupId>
>    <artifactId>mystarter-spring-boot-starter</artifactId>
>    <version>1.0.0</version>
>    
>    <!--  打包方式为jar包  -->
>    <packaging>jar</packaging>
>    <properties>
>        <maven.compiler.source>11</maven.compiler.source>
>        <maven.compiler.target>11</maven.compiler.target>
>    </properties>
>    <dependencies>
>        <dependency>
>            <groupId>org.projectlombok</groupId>
>            <artifactId>lombok</artifactId>
>            <version>1.18.24</version>
>        </dependency>
>        <!--    springBoot 自动配置依赖    -->
>        <dependency>
>            <groupId>org.springframework.boot</groupId>
>            <artifactId>spring-boot-autoconfigure</artifactId>
>            <version>2.7.7</version>
>        </dependency>
>    </dependencies>
></project>
>```
>
>#### `com.mofany.autoconfig.DemoProperties`配置文件属性映射类
>
>```java
>package com.mofany.autoconfig;
>
>import lombok.Getter;
>import lombok.Setter;
>import org.springframework.boot.context.properties.ConfigurationProperties;
>
>/**
> * @author MoFany-J
> * @date 2023/2/8
> * @description DemoProperties 该类用于接收全局配置中定义的属性值
> */
>@Setter
>@Getter
>/**
> * 使用配置属性注解：@ConfigurationProperties
> * 将application.yaml全局配置文件中的以spring.mystarter开头的配置项的信息映射到该类中
> * */
>@ConfigurationProperties(prefix = "spring.mystarter")
>public class DemoProperties {
>    /**
>     * 该成员属性的值在使用的项目配置文件application.yaml或application.properties中指定
>     * 指定格式：
>     *      spring.mystarter.parameter=XXX
>     */
>    private String parameter;
>}
>```
>
>#### `com.mofany.autoconfig.DemoService`核心服务类
>
>```java
>package com.mofany.autoconfig;
>
>import lombok.AllArgsConstructor;
>import lombok.NoArgsConstructor;
>
>/**
> * @author MoFany-J
> * @date 2023/2/8
> * @description DemoService 自定义启动器
> */
>@NoArgsConstructor
>@AllArgsConstructor
>public class DemoService {
>    /**
>     * 将全局配置中的属性值封装为对象
>     * */
>    private DemoProperties demoProperties;
>
>    public String print() {
>        System.out.println("测试自定义Starter，全局配置参数为：" + demoProperties.getParameter());
>        return demoProperties.getParameter();
>    }
>}
>```
>
>#### `com.mofany.autoconfig.DemoAutoConfiguration`自动配置类
>
>```java
>package com.mofany.autoconfig;
>
>import org.springframework.beans.factory.annotation.Autowired;
>import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
>import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
>import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
>import org.springframework.boot.context.properties.EnableConfigurationProperties;
>import org.springframework.context.annotation.Bean;
>import org.springframework.context.annotation.Configuration;
>
>/**
> * @author MoFany-J
> * @date 2023/2/8
> * @description DemoAutoConfiguration 自定义自动装配类
> */
>@Configuration
>/**
> * 启用配置属性
> * */
>@EnableConfigurationProperties(DemoProperties.class)
>/**
> * 使用条件注解：@ConditionalOnClass
> * 在类路径上存在指定类时自动装配
> * */
>@ConditionalOnClass(DemoService.class)
>/**
> * 使用条件注解：@ConditionalOnProperty
> * 应用环境中属性是否存在指定的值
> * */
>@ConditionalOnProperty(prefix = "spring.mystarter", value = "enabled", matchIfMissing = true)
>public class DemoAutoConfiguration {
>    @Autowired
>    private DemoProperties demoProperties;
>
>    /**
>     * 使用条件注解：@ConditionalOnMissingBean
>     * 当Spring容器中不存在指定的实例Bean时自动装配
>     */
>    @ConditionalOnMissingBean(DemoService.class)
>    @Bean
>    public DemoService myStarter() {
>        return new DemoService(demoProperties);
>    }
>}
>```
>
>#### resources
>
>* META-INF
>
>  * **`spring.factories`**
>
>    ```properties
>    # SpringBoot自动配置工厂文件，自动配置自定义Starter
>    org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
>      com.mofany.autoconfig.DemoAutoConfiguration
>    ```
>
>    * *执行`mvn install`*打包
>
>#### 创建SpringBoot项目对自定义`starter`进行测试
>
>* 依赖引入
>
>  ```java
>  <dependency>
>      <groupId>com.mofany</groupId>
>      <artifactId>mystarter-spring-boot-starter</artifactId>
>      <version>1.0.0</version>
>  </dependency>
>  ```
>
>* 编写全局配置文件`application.yaml`
>
>  ```yaml
>  # 自定义starter的配置项
>  spring:
>    mystarter:
>      parameter: Hello World!
>  ```
>
>* 编写SpringBoot单元测试类
>
>  ```java
>  package com.mofany;
>  
>  import com.mofany.autoconfig.DemoService;
>  import org.junit.jupiter.api.Test;
>  import org.springframework.boot.test.context.SpringBootTest;
>  
>  import javax.annotation.Resource;
>  
>  /**
>   * @author MoFany-J
>   * @date 2023/2/8
>   * @description MyStarterTest
>   */
>  @SpringBootTest
>  public class MyStarterTest {
>      @Resource
>      private DemoService demoService;
>  
>      @Test
>      public void test1(){
>          demoService.print();
>      }
>  }
>  ```
>
>  * 测试结果
>
>    ```properties
>    测试自定义Starter，全局配置参数为：Hello World!
>    ```
>

## :fist_oncoming:手动实现@Value注解与类属性绑定反射赋值的实现:fist_oncoming:

>#### 定义注解
>
>* **@Param**
>
>  ```java
>  package com.mofany.customAnnotation;
>  
>  import java.lang.annotation.ElementType;
>  import java.lang.annotation.Inherited;
>  import java.lang.annotation.Retention;
>  import java.lang.annotation.RetentionPolicy;
>  import java.lang.annotation.Target;
>  
>  /**
>   *
>   * @author jiang
>   */
>  @Target(ElementType.FIELD)
>  @Retention(RetentionPolicy.RUNTIME)
>  @Inherited
>  public @interface Param {
>  
>      String name() default "这是一个测试注解！";
>  }
>  ```
>
>* **`@Value`核心**
>
>  ```java
>  package com.mofany.customAnnotation;
>  
>  import java.lang.annotation.Documented;
>  import java.lang.annotation.ElementType;
>  import java.lang.annotation.Inherited;;
>  import java.lang.annotation.Retention;
>  import java.lang.annotation.RetentionPolicy;
>  import java.lang.annotation.Target;
>  
>  /**
>   *
>   * @author jiang
>   */
>  @Target({ElementType.FIELD})
>  @Retention(RetentionPolicy.RUNTIME)
>  @Documented
>  @Inherited
>  public @interface Value {
>  
>      /**
>       *
>       * @return
>       */
>      String value() default "";
>  
>  }
>  ```
>
>#### 定义实体类
>
>* **Student**
>
>  ```java
>  package com.mofany.entity;
>  
>  import com.mofany.customAnnotation.Param;
>  import com.mofany.customAnnotation.Value;
>  
>  /**
>   *
>   * @author jiang
>   */
>  public class Student {
>  
>      @Param
>      @Value(value = "1")
>      private Integer id;
>      @Param
>      @Value(value = "lisa")
>      private String name;
>      @Param
>      @Value(value = "女")
>      private String sex;
>      @Param
>      @Value("32")
>      private short age;
>  
>      @Override
>      public String toString() {
>          return "[id=" + id + ",name=" + name + ",sex=" + sex + ",age=" + age + "]";
>      }
>  }
>  ```
>
>* **Teacher**
>
>  ```java
>  package com.mofany.entity;
>  
>  import com.mofany.customAnnotation.Param;
>  import com.mofany.customAnnotation.Value;
>  
>  /**
>   *
>   * @author jiang
>   */
>  public class Teacher {
>  
>      @Param
>      @Value("1")
>      private int jobNum;
>      @Param
>      @Value("余华")
>      private String name;
>      @Param
>      @Value("男")
>      private String sex;
>      @Param
>      @Value("65")
>      private short age;
>      @Param
>      @Value("大学语文")
>      private String subject;
>      @Param
>      @Value("true")
>      private boolean workState;
>  
>      @Override
>      public String toString() {
>          return "[jobNum=" 
>                  + jobNum 
>                  + ",name=" 
>                  + name 
>                  + ",sex=" 
>                  + sex 
>                  + ",age=" 
>                  + age 
>                  + ",subject=" 
>                  + subject 
>                  + ",workState=" 
>                  + workState 
>                  + "]";
>      }
>  }
>  ```
>
>#### 定义工具类
>
>```java
>package com.mofany.util;
>
>import com.mofany.customAnnotation.Value;
>import java.lang.annotation.Annotation;
>import java.lang.reflect.Constructor;
>import java.lang.reflect.Field;
>import java.lang.reflect.InvocationTargetException;
>import java.lang.reflect.Type;
>import java.util.logging.Level;
>import java.util.logging.Logger;
>
>/**
> *
> * @author jiang
> */
>public class CustomReflectUtils {
>    
>    private CustomReflectUtils(){
>        //禁止运行时的操作及注入
>        throw new RuntimeException("禁止反射!");
>    }
>
>    /**
>     * 反射创建任意运行时类的实例
>     *
>     * @param <T>
>     * @param clazz 类的Class对象
>     * @return 返回值为传入类的实例
>     */
>    public static <T extends Object> T instanceObject(Class<? extends T> clazz) {
>        T instance = null;
>        Constructor constructor = null;
>        try {
>            //反射获取构造器
>            constructor = clazz.getDeclaredConstructor();
>            //允许私有访问
>            if (constructor.isAccessible()) {
>                constructor.setAccessible(true);
>            }
>            //反射创建实例
>            instance = (T) constructor.newInstance();
>        } catch (NoSuchMethodException ex) {
>            Logger.getLogger(CustomReflectUtils.class.getName()).log(Level.SEVERE, null, ex);
>        } catch (InstantiationException ex) {
>            Logger.getLogger(CustomReflectUtils.class.getName()).log(Level.SEVERE, null, ex);
>        } catch (IllegalAccessException ex) {
>            Logger.getLogger(CustomReflectUtils.class.getName()).log(Level.SEVERE, null, ex);
>        } catch (InvocationTargetException ex) {
>            Logger.getLogger(CustomReflectUtils.class.getName()).log(Level.SEVERE, null, ex);
>        }
>        return instance;
>    }
>
>    /**
>     * 解析当前类中所有字段上的@Value注解并为注解的字段设置值
>     *
>     * @param <T>
>     * @param clazz 类的Class对象
>     * @return 返回值为传入类的实例并带有指定属性
>     */
>    public static <T extends Object> T parseValueAnnotaiton(Class<? extends T> clazz) {
>        //反射创建传入类的创建实例
>        T instance = instanceObject(clazz);
>        //反射获取获取传入类的所有字段
>        Field[] fields = clazz.getDeclaredFields();
>        //遍历类中所有字段
>        for (Field field : fields) {
>            //支持私有字段访问，默认为false
>            if (!field.isAccessible()) {
>                field.setAccessible(true);
>            }
>            //获取当前字段上的所有注解
>            for (Annotation annotation : field.getDeclaredAnnotations()) {
>                Class annotationClass = annotation.annotationType();
>                /**
>                 * 解析所有的@Value注解
>                 */
>                if (annotationClass.getName().equals(Value.class.getName())) {
>                    //获取类当前字段上的@Value注解
>                    Value valueObj = (Value) annotation;
>                    //获取类当前字段上的@Value注解的值
>                    String annotationParam = valueObj.value();
>                    //获取字段的类型
>                    Type fieldType = field.getGenericType();
>                    //**测试**
>                    System.out.print("注解参数为：" + annotationParam);
>                    System.out.print("，被注解的字段为：" + field.getName());
>                    System.out.println(",被注解的字段的类型为：" + fieldType.getTypeName());
>                    try {
>                        /**
>                         * 为当前类实例的对应属性设置值
>                         */
>                        field.set(instance, type(fieldType.getTypeName(), annotationParam));
>                    } catch (IllegalAccessException ex) {
>                        String currentClassName=CustomReflectUtils.class.getName();
>                        Logger.getLogger(currentClassName).log(Level.SEVERE, null, ex);
>                    }
>                }
>            }
>        }
>        return instance;
>    }
>
>    /**
>     * 动态类型转为包装类类型
>     */
>    private static Object type(String type, String targetVariable) {
>        switch (type) {
>            //八大基本类型（都要返回包装类类型）
>            case "int":
>            case "java.lang.Integer":
>                return Integer.valueOf(targetVariable);
>            case "byte":
>            case "java.lang,Byte":
>                return Byte.valueOf(targetVariable);
>            case "long":
>            case "java.lang.Long":
>                return Long.valueOf(targetVariable);
>            case "short":
>            case "java.lang.Short":
>                return Short.valueOf(targetVariable);
>            case "char":;
>            case "java.lang.Character":
>                if(targetVariable.length()!=1){
>                    throw new RuntimeException("参数长度错误！"); 
>                }
>                return Character.valueOf(targetVariable.charAt(0));
>            case "float":
>            case "java.lang.Float":
>                return Float.valueOf(targetVariable);
>            case "double":
>            case "java.lang.Double":
>                return Double.valueOf(targetVariable);
>            case "boolean":
>            case "java.lang.Boolean":
>                return Boolean.valueOf(targetVariable);
>            case "java.lang.String":
>                return targetVariable;
>            default:
>                throw new RuntimeException("类型转换异常，请检查方法参数！");
>        }
>    }
>}
>```
>
>#### 定义测试类
>
>```java
>package com.mofany.test;
>
>import com.mofany.entity.Student;
>import com.mofany.entity.Teacher;
>import com.mofany.util.CustomReflectUtils;
>import org.junit.Test;
>
>/**
> *
> * @author jiang
> */
>public class TestCrrentProject {
>    @Test
>    public void test() {
>        
>        //测试1
>        Object obj=CustomReflectUtils.instanceObject(Student.class);
>        System.out.println("**测试1：反射创建的类为："+obj.getClass().getCanonicalName()+"\n");
>
>        //测试2
>        Student student = CustomReflectUtils.parseValueAnnotaiton(Student.class);
>        System.out.println("**测试2："+student+"\n");
>        
>        //测试3
>        Teacher teacher=CustomReflectUtils.parseValueAnnotaiton(Teacher.class);
>        System.out.println("**测试3："+teacher+"\n");
>    }
>}
>```
>
>#### 测试结果
>
>```shell
>----------------------< com.mofany:mavenproject2 >----------------------
>Building mavenproject2 1.0-SNAPSHOT
>--------------------------------[ jar ]---------------------------------
>
>--- maven-surefire-plugin:2.12.4:test (default-cli) @ mavenproject2 ---
>Surefire report directory: E:\Net-Beans-workspace\mavenproject2\target\surefire-reports
>
>-------------------------------------------------------
> T E S T S
>-------------------------------------------------------
>Running com.mofany.test.TestCrrentProject
>**测试1：反射创建的类为：com.mofany.entity.Student
>
>注解参数为：1，被注解的字段为：id,被注解的字段的类型为：java.lang.Integer
>注解参数为：lisa，被注解的字段为：name,被注解的字段的类型为：java.lang.String
>注解参数为：女，被注解的字段为：sex,被注解的字段的类型为：java.lang.String
>注解参数为：32，被注解的字段为：age,被注解的字段的类型为：short
>**测试2：[id=1,name=lisa,sex=女,age=32]
>
>注解参数为：1，被注解的字段为：jobNum,被注解的字段的类型为：int
>注解参数为：余华，被注解的字段为：name,被注解的字段的类型为：java.lang.String
>注解参数为：男，被注解的字段为：sex,被注解的字段的类型为：java.lang.String
>注解参数为：65，被注解的字段为：age,被注解的字段的类型为：short
>注解参数为：大学语文，被注解的字段为：subject,被注解的字段的类型为：java.lang.String
>注解参数为：true，被注解的字段为：workState,被注解的字段的类型为：boolean
>**测试3：[jobNum=1,name=余华,sex=男,age=65,subject=大学语文,workState=true]
>
>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.064 sec
>
>Results :
>
>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
>
>------------------------------------------------------------------------
>BUILD SUCCESS
>------------------------------------------------------------------------
>Total time:  1.051 s
>Finished at: 2023-01-17T16:39:24+08:00
>------------------------------------------------------------------------
>```

## :fist_oncoming:`@JsonFormat注解`，解决Post日期请求参数格式问题:fist_oncoming:

>#### `@JsonFormat`注解
>
>* 用于将返回参数序列化
>
>* **@JsonFormat用于后端传给前端的日期时间格式转换**`也可以转换其它类型的实体类成员属性`
>
>  ```java
>  // 读时用指定格式序列化，实体类属性
>  @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
>  private LocalDateTime dateTime;
>  ```
>
>  - #### 若出现无法从字符串中反序列化处`LocalDataTime`时
>
>    - Cannot deserialize value of type `java.time.LocalDateTime` from String "2023-02-12 22:23:00": Failed to deserialize java.time.LocalDateTime: (java.time.format.DateTimeParseException) Text '2023-02-12 22:23:00' could not be parsed: Unable to obtain LocalDateTime from TemporalAccessor
>    - 解决方案：
>      - `shape=JsonFormat.Shape.STRING`指定前端传过来的日期时间字符串类型，用于序列化的结构：映射的定义取决于数据类型，但通常有直接对应的数据格式 (JSON)。
>      - `timezone = "GMT+8"`东八区取消日期时间转换时的误差
>      - `pattern="yyyy-MM-dd HH:mm:ss"`指定日期时间格式
>
>    ```java
>    // 读写时用指定格式序列化，实体类属性
>    @JsonFormat(shape=JsonFormat.Shape.STRING, timezone="GMT+8", pattern="yyyy-MM-dd HH:mm:ss") 
>    ```
>
>#### `@DateTimeFormat`注解
>
>* 用于请请求参数序列化
>
>* **@DateTimeFormat用于前端传给后端的时间格式转换**
>
>  ```java
>  @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
>  private LocalDateTime dateTime;
>  ```

## SpringBoot的数据访问`Spring-Data-JPA`

>
>
>

# SpringBoot专用于配置类的条件注解

## :boxing_glove:条件注解：`@Conditional`:boxing_glove:

>##### 所有SpringBoot中的条件注解都是基于Spring中的`@Conditional`去实现的
>
>#### 条件注解的作用：
>
>* ##### 就是使应用程序的配置类在满足某先特定条件后才能自动启动此配置类中的配置项，即配置方法。
>
>* ##### 条件注解是`Spring4`提供的一种`Bean加载特性`，主要用于控制配置类和bean初始化条件。在`springBoot，springCloud`一系列框架底层源码中，条件注解的使用到处可见。
>
>#### SpringBoot条件注解`仅用于自定义配置类与主配置类`
>
>| 注解名                            | 条件                                   |
>| --------------------------------- | -------------------------------------- |
>| @ConditionalOn`Bean`              | 指定Bean存在于Spring容器时启用配置项   |
>| @ConditionalOn`MissingBean`       | 指定Bean不存在于Spring容器时启用配置项 |
>| @ConditionalOn`Class`             | 指定Class存在于类路径时启用配置项      |
>| @ConditionalOn`MissingClass`      | 指定Class不存在于类路径时启用配置项    |
>| @ConditionalOn`WebApplication`    | 当前应用是Web应用                      |
>| @ConditionalOn`NotWebApplication` | 当前应用不是Web应用                    |
>| @ConditionalOn`SingleCandidate`   | Spring容器中是否存在指定单例Bean       |
>| @ConditionalOn`Property`          | 应用环境中是否存在指定属性值           |
>| @ConditionalOn`Resource`          | 是否存在指定资源文件                   |
>| @ConditionalOn`Java`              | 是否为指定java版本                     |
>| @ConditionalOn`Jndi`              | 在JNDI存在的情况下查找指定位置         |
>| @ConditionalOn`Expression`        | Spring EL表达式是否成立                |
>| @ConditionalOn`CloudPlatform`     | 是否在云平台                           |
>
>