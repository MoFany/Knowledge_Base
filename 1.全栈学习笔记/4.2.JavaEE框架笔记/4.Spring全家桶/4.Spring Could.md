# 微服务：SpringCould父项目搭建

## 工作流程`天上飞的理念，必然有落地的实现`

>1. **建module**
>2. **改POM**
>3. **写YAM**
>4. **主启动**
>5. **业务类**

## SpringCloud与SpringBoot版本关系对照表`2023-02-11`

>| SpringCloud                                                  | SpringBoot                                |
>| ------------------------------------------------------------ | ----------------------------------------- |
>| [2022.0.x](https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2022.0-Release-Notes) aka Kilburn | 3.0.x                                     |
>| **[2021.0.x](https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2021.0-Release-Notes) aka Jubilee** | **2.6.x, 2.7.x (Starting with 2021.0.3)** |
>| [2020.0.x](https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2020.0-Release-Notes) aka Ilford | 2.4.x, 2.5.x (Starting with 2020.0.3)     |
>| [Hoxton](https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-Hoxton-Release-Notes) | 2.2.x, 2.3.x (Starting with SR5)          |
>| [Greenwich](https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Greenwich-Release-Notes) | 2.1.x                                     |
>| [Finchley](https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Finchley-Release-Notes) | 2.0.x                                     |
>| [Edgware](https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Edgware-Release-Notes) | 1.5.x                                     |
>| [Dalston](https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Dalston-Release-Notes) | 1.5.x                                     |
>
>#### 更详细更具体的SpringCloud与SpringBoot直接的版本对照信息
>
>* **官网提供：https://start.spring.io/actuator/info**
>
>  ```json
>  {
>    "git": {
>      "branch": "63c47880fe7a5f99d9cbbea31120e39c0ae016e9",
>      "commit": {
>        "id": "63c4788",
>        "time": "2023-02-07T13:48:26Z"
>      }
>    },
>    "build": {
>      "version": "0.0.1-SNAPSHOT",
>      "artifact": "start-site",
>      "versions": {
>        "spring-boot": "3.0.2",
>        "initializr": "0.20.0-SNAPSHOT"
>      },
>      "name": "start.spring.io website",
>      "time": "2023-02-07T13:50:40.146Z",
>      "group": "io.spring.start"
>    },
>    "bom-ranges": {
>      "codecentric-spring-boot-admin": {
>        "2.4.3": "Spring Boot >=2.3.0.M1 and <2.5.0-M1",
>        "2.5.6": "Spring Boot >=2.5.0.M1 and <2.6.0-M1",
>        "2.6.8": "Spring Boot >=2.6.0.M1 and <2.7.0-M1",
>        "2.7.4": "Spring Boot >=2.7.0.M1 and <3.0.0-M1",
>        "3.0.0-M4": "Spring Boot >=3.0.0-M1 and <3.1.0-M1"
>      },
>      "solace-spring-boot": {
>        "1.1.0": "Spring Boot >=2.3.0.M1 and <2.6.0-M1",
>        "1.2.2": "Spring Boot >=2.6.0.M1 and <3.0.0-M1"
>      },
>      "solace-spring-cloud": {
>        "1.1.1": "Spring Boot >=2.3.0.M1 and <2.4.0-M1",
>        "2.1.0": "Spring Boot >=2.4.0.M1 and <2.6.0-M1",
>        "2.3.2": "Spring Boot >=2.6.0.M1 and <3.0.0-M1"
>      },
>      "spring-cloud": {
>        "Hoxton.SR12": "Spring Boot >=2.2.0.RELEASE and <2.4.0.M1",
>        "2020.0.6": "Spring Boot >=2.4.0.M1 and <2.6.0-M1",
>        "2021.0.0-M1": "Spring Boot >=2.6.0-M1 and <2.6.0-M3",
>        "2021.0.0-M3": "Spring Boot >=2.6.0-M3 and <2.6.0-RC1",
>        "2021.0.0-RC1": "Spring Boot >=2.6.0-RC1 and <2.6.1",
>        "2021.0.5": "Spring Boot >=2.6.1 and <3.0.0-M1",
>        "2022.0.0-M1": "Spring Boot >=3.0.0-M1 and <3.0.0-M2",
>        "2022.0.0-M2": "Spring Boot >=3.0.0-M2 and <3.0.0-M3",
>        "2022.0.0-M3": "Spring Boot >=3.0.0-M3 and <3.0.0-M4",
>        "2022.0.0-M4": "Spring Boot >=3.0.0-M4 and <3.0.0-M5",
>        "2022.0.0-M5": "Spring Boot >=3.0.0-M5 and <3.0.0-RC1",
>        "2022.0.0-RC1": "Spring Boot >=3.0.0-RC1 and <3.0.0-RC2",
>        "2022.0.0-RC2": "Spring Boot >=3.0.0-RC2 and <3.0.0",
>        "2022.0.1": "Spring Boot >=3.0.0 and <3.1.0-M1"
>      },
>      "spring-cloud-azure": {
>        "4.6.0": "Spring Boot >=2.5.0.M1 and <3.0.0-M1",
>        "5.0.0": "Spring Boot >=3.0.0-M1 and <3.1.0-M1"
>      },
>      "spring-cloud-gcp": {
>        "2.0.11": "Spring Boot >=2.4.0-M1 and <2.6.0-M1",
>        "3.4.3": "Spring Boot >=2.6.0-M1 and <3.0.0-M1",
>        "4.0.0": "Spring Boot >=3.0.0-M1 and <3.1.0-M1"
>      },
>      "spring-cloud-services": {
>        "2.3.0.RELEASE": "Spring Boot >=2.3.0.RELEASE and <2.4.0-M1",
>        "2.4.1": "Spring Boot >=2.4.0-M1 and <2.5.0-M1",
>        "3.3.0": "Spring Boot >=2.5.0-M1 and <2.6.0-M1",
>        "3.4.0": "Spring Boot >=2.6.0-M1 and <2.7.0-M1",
>        "3.5.0": "Spring Boot >=2.7.0-M1 and <3.0.0-M1",
>        "4.0.0": "Spring Boot >=3.0.0 and <3.1.0-M1"
>      },
>      "spring-shell": {
>        "2.1.6": "Spring Boot >=2.7.0 and <3.0.0-M1",
>        "3.0.0": "Spring Boot >=3.0.0 and <3.1.0-M1"
>      },
>      "vaadin": {
>        "14.9.5": "Spring Boot >=2.1.0.RELEASE and <2.6.0-M1",
>        "23.2.15": "Spring Boot >=2.6.0-M1 and <2.7.0-M1",
>        "23.3.5": "Spring Boot >=2.7.0-M1 and <2.8.0-M1"
>      },
>      "wavefront": {
>        "2.0.2": "Spring Boot >=2.1.0.RELEASE and <2.4.0-M1",
>        "2.1.1": "Spring Boot >=2.4.0-M1 and <2.5.0-M1",
>        "2.2.2": "Spring Boot >=2.5.0-M1 and <2.7.0-M1",
>        "2.3.4": "Spring Boot >=2.7.0-M1 and <3.0.0-M1",
>        "3.0.1": "Spring Boot >=3.0.0-M1 and <3.1.0-M1"
>      }
>    },
>    "dependency-ranges": {
>      "okta": {
>        "1.4.0": "Spring Boot >=2.2.0.RELEASE and <2.4.0-M1",
>        "1.5.1": "Spring Boot >=2.4.0-M1 and <2.4.1",
>        "2.0.1": "Spring Boot >=2.4.1 and <2.5.0-M1",
>        "2.1.6": "Spring Boot >=2.5.0-M1 and <3.0.0-M1",
>        "3.0.2": "Spring Boot >=3.0.0-M1 and <3.1.0-M1",
>        "managed": "Spring Boot >=3.1.0-M1"
>      },
>      "mybatis": {
>        "2.1.4": "Spring Boot >=2.1.0.RELEASE and <2.5.0-M1",
>        "2.2.2": "Spring Boot >=2.5.0-M1 and <2.7.0-M1",
>        "2.3.0": "Spring Boot >=2.7.0-M1 and <3.0.0-M1",
>        "3.0.0": "Spring Boot >=3.0.0-M1"
>      },
>      "camel": {
>        "3.5.0": "Spring Boot >=2.3.0.M1 and <2.4.0-M1",
>        "3.10.0": "Spring Boot >=2.4.0.M1 and <2.5.0-M1",
>        "3.13.0": "Spring Boot >=2.5.0.M1 and <2.6.0-M1",
>        "3.17.0": "Spring Boot >=2.6.0.M1 and <2.7.0-M1",
>        "3.20.2": "Spring Boot >=2.7.0.M1 and <3.0.0-M1",
>        "4.0.0-M1": "Spring Boot >=3.0.0-M1 and <3.1.0-M1"
>      },
>      "picocli": {
>        "4.7.0": "Spring Boot >=2.5.0.RELEASE and <3.1.0-M1"
>      },
>      "open-service-broker": {
>        "3.2.0": "Spring Boot >=2.3.0.M1 and <2.4.0-M1",
>        "3.3.1": "Spring Boot >=2.4.0-M1 and <2.5.0-M1",
>        "3.4.1": "Spring Boot >=2.5.0-M1 and <2.6.0-M1",
>        "3.5.0": "Spring Boot >=2.6.0-M1 and <2.7.0-M1"
>      }
>    }
>  }
>  ```
>

## SpringCloud项目核心依赖

>#### 父模块核心依赖
>
>```xml
><!-- 管理子模块依赖 -->
><dependencyManagement>
>    <dependencies>
>        <!--     spring boot   -->
>        <dependency>
>            <groupId>org.springframework.boot</groupId>
>            <artifactId>spring-boot-dependencies</artifactId>
>            <version>2.7.7</version>
>            <type>pom</type>
>            <scope>import</scope>
>        </dependency>
>        <!--      spring cloud      -->
>        <dependency>
>            <groupId>org.springframework.cloud</groupId>
>            <artifactId>spring-cloud-dependencies</artifactId>
>            <version>2021.0.5</version>
>            <type>pom</type>
>            <scope>import</scope>
>        </dependency>
>        <!--    spring could alibaba        -->
>        <dependency>
>            <groupId>com.alibaba.cloud</groupId>
>            <artifactId>spring-cloud-alibaba-dependencies</artifactId>
>            <version>2021.1</version>
>            <type>pom</type>
>            <scope>import</scope>
>        </dependency>
>    </dependencies>
></dependencyManagement>
>```
>
>#### 子模块核心依赖
>
>```xml
><dependencies>
>    <!-- web支持 -->
>    <dependency>
>        <groupId>org.springframework.boot</groupId>
>        <artifactId>spring-boot-starter-web</artifactId>
>    </dependency>
>    <!-- 健康检查追踪检测,以及图形监控 -->
>    <dependency>
>        <groupId>org.springframework.boot</groupId>
>        <artifactId>spring-boot-starter-actuator</artifactId>
>    </dependency>
></dependencies>
>```
>

# 微服务：模块项目的Rest风格请求调用

```properties
# 订单调用支付	
Oder ————————>	Panyment 
```

## :ballot_box_with_check:微服务项目重构`抽取公共实体作为自定义jar，引入其它工程`

>### cloud-api-commons`公共的实体类，工具类`
>
>#### 依赖`pom.xml`
>
>```xml
><dependencies>
>    <dependency>
>        <groupId>org.springframework.boot</groupId>
>        <artifactId>spring-boot-devtools</artifactId>
>        <scope>runtime</scope>
>        <optional>true</optional>
>    </dependency>
>    <dependency>
>        <groupId>org.projectlombok</groupId>
>        <artifactId>lombok</artifactId>
>        <optional>true</optional>
>    </dependency>
>    <dependency>
>        <groupId>cn.hutool</groupId>
>        <artifactId>hutool-all</artifactId>
>        <version>5.7.22</version>
>    </dependency>
></dependencies>
>```
>
>#### entities公共实体
>
>* 数据库实体表封装类：`Payment`
>
>  ```java
>  package com.mofany.entities;
>  
>  import lombok.*;
>  
>  import java.io.Serializable;
>  
>  /**
>   * @author MoFany-J
>   * @date 2023/2/14
>   * @description Payment 主实体类
>   */
>  @Setter
>  @Getter
>  @ToString
>  @NoArgsConstructor
>  @AllArgsConstructor
>  public class Payment implements Serializable {
>  
>      /**
>       * 主键id字段
>       * */
>      private Long id;
>      /**
>       *
>       * */
>      private String serial;
>  
>      /**
>       * 可序列化接口实现类必须有一个 serialVersionUID
>       */
>      private static final long serialVersionUID = -2322665254768493702L;
>  }
>  ```
>
>* ***响应实体封装类：`CommonResult<T>`***
>
>  ```java
>  package com.mofany.entities;
>  
>  import lombok.AllArgsConstructor;
>  import lombok.Getter;
>  import lombok.NoArgsConstructor;
>  import lombok.Setter;
>  
>  import java.io.Serializable;
>  
>  /**
>   * @author MoFany-J
>   * @date 2023/2/14
>   * @description CommonResult Json封装体类
>   */
>  @Setter
>  @Getter
>  @NoArgsConstructor
>  @AllArgsConstructor
>  public class CommonResult<T> implements Serializable {
>  
>      private Integer code;
>      private String message;
>      private T data;
>      /**
>       * 可序列化接口实现类必须有一个 serialVersionUID
>       */
>      private static final long serialVersionUID = -5161884966657763669L;
>  
>      public CommonResult(Integer code, String message) {
>          this(code, message, null);
>      }
>  }
>  ```
>
>#### 然后跳过测试，执行maven打包，生成的jar包的坐标
>
>```xml
><!--    项目重构后的jar包,即引入自己定义的api通用包   -->
><dependency>
>    <groupId>com.mofany</groupId>
>    <artifactId>cloud-api-commons</artifactId>
>    <version>1.0.0</version>
></dependency>
>```

## :ballot_box_with_check:**8001，**微服务初体验之，`微服务提供者`

>### cloud-provider-payment8001`支付模块：直接与数据库交涉，并响应订单模块的请求`
>
>#### 依赖`pom.xml`
>
>```xml
><dependencies>
>    <dependency>
>        <groupId>org.springframework.boot</groupId>
>        <artifactId>spring-boot-starter-web</artifactId>
>    </dependency>
>    <dependency>
>        <groupId>org.springframework.boot</groupId>
>        <artifactId>spring-boot-starter-actuator</artifactId>
>    </dependency>
>    <dependency>
>        <groupId>org.springframework.boot</groupId>
>        <artifactId>spring-boot-starter-jdbc</artifactId>
>    </dependency>
>    <dependency>
>        <groupId>org.springframework.boot</groupId>
>        <artifactId>spring-boot-starter-test</artifactId>
>        <scope>test</scope>
>    </dependency>
>    <!--     热部署   -->
>    <dependency>
>        <groupId>org.springframework.boot</groupId>
>        <artifactId>spring-boot-devtools</artifactId>
>        <scope>runtime</scope>
>        <optional>true</optional>
>    </dependency>
>    <dependency>
>        <groupId>mysql</groupId>
>        <artifactId>mysql-connector-java</artifactId>
>    </dependency>
>    <dependency>
>        <groupId>com.alibaba</groupId>
>        <artifactId>druid-spring-boot-starter</artifactId>
>    </dependency>
>    <dependency>
>        <groupId>org.mybatis.spring.boot</groupId>
>        <artifactId>mybatis-spring-boot-starter</artifactId>
>    </dependency>
>    <dependency>
>        <groupId>org.projectlombok</groupId>
>        <artifactId>lombok</artifactId>
>    </dependency>
>    <!--    项目重构后的jar包,即引入自己定义的api通用包   -->
>    <dependency>
>        <groupId>com.mofany</groupId>
>        <artifactId>cloud-api-commons</artifactId>
>        <version>1.0.0</version>
>    </dependency>
></dependencies>
>```
>
>#### config
>
>```java
>package com.mofany.config;
>
>import org.springframework.context.annotation.Configuration;
>import org.springframework.web.servlet.config.annotation.CorsRegistry;
>import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
>
>/**
> * @author MoFany-J
> * @date 2023/2/15
> * @description GlobalWebConfig 全局web配置
> */
>@Configuration
>public class GlobalWebConfig implements WebMvcConfigurer {
>    /**
>     * 跨域放行
>     * */
>    @Override
>    public void addCorsMappings(CorsRegistry registry) {
>        registry.addMapping("/**")
>                .allowedHeaders("*")
>                .allowedMethods("*")
>                .allowedOriginPatterns("*");
>    }
>}
>```
>
>#### controller
>
>```java
>package com.mofany.controller;
>
>import com.mofany.entities.CommonResult;
>import com.mofany.entities.Payment;
>import com.mofany.service.PaymentService;
>import lombok.extern.slf4j.Slf4j;
>import org.springframework.web.bind.annotation.*;
>
>import javax.annotation.Resource;
>
>/**
> * @author MoFany-J
> * @date 2023/2/15
> * @description PaymentController 支付模块对外的controller
> */
>@Slf4j
>@RestController
>@RequestMapping("payment")
>public class PaymentController {
>    @Resource
>    private PaymentService paymentService;
>
>    /**
>     * 插入数据
>     * 测试接口：http://localhost:8001/payment/create
>     * {
>     * "code": 200,
>     * "message": "插入数据成功",
>     * "data": 1
>     * }
>     */
>    @PostMapping("create")
>    public CommonResult create(@RequestBody Payment payment) {
>        int result = paymentService.create(payment);
>        log.info("********插入结果：" + result);
>        if (result > 0) {
>            return new CommonResult(200, "插入数据成功", result);
>        }
>        return new CommonResult(444, "插入数据失败", null);
>    }
>
>    /**
>     * 查询
>     * 测试接口：http://localhost:8001/payment/get/1
>     * <p>
>     * {
>     * "code": 200,
>     * "message": "查询成功",
>     * "data": {
>     * "id": 1,
>     * "serial": "笑傲江湖"
>     * }
>     * }
>     */
>    @GetMapping("get/{id}")
>    public CommonResult<Payment> getPaymentById(@PathVariable("id") Long id) {
>        Payment payment = paymentService.getPaymentById(id);
>        log.info("********插入结果：" + payment);
>        if (payment != null) {
>            return new CommonResult(200, "查询成功", payment);
>        }
>        return new CommonResult(444, "无对应记录，查询ID：" + id, null);
>    }
>}
>```
>
>#### mapper
>
>```java
>package com.mofany.mapper;
>
>import com.mofany.entities.Payment;
>import org.apache.ibatis.annotations.Mapper;
>import org.apache.ibatis.annotations.Param;
>
>
>/**
> * @author MoFany-J
> * @date 2023/2/15
> * @description PaymentMapper 数据访问接口层
> */
>@Mapper
>public interface PaymentMapper {
>    /**
>     * 新增
>     * */
>    int create(Payment payment);
>
>    /**
>     * 按id查Payment
>     * */
>    Payment getPaymentById(@Param("id") Long id);
>}
>```
>
>#### service
>
>```java
>package com.mofany.service;
>
>import com.mofany.entities.Payment;
>import org.apache.ibatis.annotations.Param;
>
>/**
> * @author MoFany-J
> * @date 2023/2/15
> * @description PaymentService
> */
>public interface PaymentService {
>    /**
>     * 新增
>     * */
>    int create(Payment payment);
>
>    /**
>     * 按id查Payment
>     * */
>    Payment getPaymentById(@Param("id") Long id);
>}
>```
>
>* **impl**
>
>  ```java
>  package com.mofany.service.impl;
>  
>  import com.mofany.entities.Payment;
>  import com.mofany.mapper.PaymentMapper;
>  import com.mofany.service.PaymentService;
>  import org.springframework.stereotype.Service;
>  
>  import javax.annotation.Resource;
>  
>  /**
>   * @author MoFany-J
>   * @date 2023/2/15
>   * @description PaymentServiceImpl
>   */
>  @Service
>  public class PaymentServiceImpl implements PaymentService {
>      @Resource
>      private PaymentMapper paymentMapper;
>      /**
>       * 新增
>       *
>       * @param payment
>       */
>      @Override
>      public int create(Payment payment) {
>          return paymentMapper.create(payment);
>      }
>  
>      /**
>       * 按id查Payment
>       *
>       * @param id
>       */
>      @Override
>      public Payment getPaymentById(Long id) {
>          return paymentMapper.getPaymentById(id);
>      }
>  }
>  ```
>
>#### 核心启动类
>
>```java
>package com.mofany;
>
>import org.mybatis.spring.annotation.MapperScan;
>import org.springframework.boot.SpringApplication;
>import org.springframework.boot.autoconfigure.SpringBootApplication;
>
>/**
> * @author MoFany-J
> * @date 2023/2/14
> * @description PaymentMain8001 支付模块
> */
>@MapperScan(basePackages = "com.mofany.mapper")
>@SpringBootApplication
>public class PaymentMain8001 {
>    public static void main(String[] args) {
>        SpringApplication.run(PaymentMain8001.class,args);
>    }
>}
>```
>
>#### resources
>
>* mapper/`PaymentMapper.xml`
>
>  ```xml
>  <?xml version="1.0" encoding="UTF-8" ?>
>  <!DOCTYPE mapper
>          PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
>          "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
>  <mapper namespace="com.mofany.mapper.PaymentMapper">
>      <resultMap id="BaseResultMap" type="com.mofany.entities.Payment">
>          <id property="id" column="id" jdbcType="BIGINT"/>
>          <result property="serial" column="serial" jdbcType="VARCHAR"/>
>      </resultMap>
>      <insert id="create" parameterType="Payment" useGeneratedKeys="true" keyColumn="id">
>          insert into payment
>          values (null, #{serial,jdbcType=VARCHAR})
>      </insert>
>      <select id="getPaymentById" parameterType="java.lang.Long" resultMap="BaseResultMap">
>          select *
>          from payment
>          where id = #{id}
>      </select>
>  </mapper>
>  ```
>
>* `application.yaml`
>
>  ```yaml
>  server:
>    port: 8001
>  
>  spring:
>    application:
>      name: cloud-payment-service
>    datasource:
>      type: com.alibaba.druid.pool.DruidDataSource
>      driver-class-name: com.mysql.cj.jdbc.Driver
>      url: jdbc:mysql://localhost:3306/springcloud?ServerTimezone=GMT%2B8
>      username: root
>      password: Jiangmh220
>    sql:
>      init:
>        mode: always						# 启动时始终创建表
>        schema-locations:
>          - classpath:payment.sql         # 建表的Sql脚本
>        data-locations:
>          - classpath:payment-data.sql    # 插值的Sql脚本
>  
>  
>  mybatis:
>    type-aliases-package: com.mofany.entities             # entities别名类所在包
>    mapper-locations: classpath*:mapper/*Mapper.xml
>  ```
>
>  * `payment.sql`
>
>    ```mysql
>    drop table if exists payment;
>    create table payment
>    (
>        id     bigint(20) not null auto_increment comment 'ID',
>        serial varchar(200) DEFAULT '',
>        primary key (id)
>    ) auto_increment = 1;
>    ```
>
>  * `payment-data.sql`
>
>    ```mysql
>    delete
>    from payment;
>    insert into payment
>    values (null, '笑傲江湖');
>    ```

## :ballot_box_with_check:**80，**微服务初体验之消费者，`客户端消费者`

>### cloud-consumer--order80`订单模块：直接与前端交涉，然后去调用支付模块修改数据库`
>
>#### 依赖`pom.xml`
>
>```xml
><dependencies>
>    <dependency>
>        <groupId>org.springframework.boot</groupId>
>        <artifactId>spring-boot-starter-web</artifactId>
>    </dependency>
>    <dependency>
>        <groupId>org.springframework.boot</groupId>
>        <artifactId>spring-boot-starter-actuator</artifactId>
>    </dependency>
>    <dependency>
>        <groupId>org.springframework.boot</groupId>
>        <artifactId>spring-boot-starter-test</artifactId>
>        <scope>test</scope>
>    </dependency>
>    <dependency>
>        <groupId>org.springframework.boot</groupId>
>        <artifactId>spring-boot-devtools</artifactId>
>        <scope>runtime</scope>
>        <optional>true</optional>
>    </dependency>
>    <dependency>
>        <groupId>org.projectlombok</groupId>
>        <artifactId>lombok</artifactId>
>    </dependency>
>    <!--    项目重构后的jar包,即引入自己定义的api通用包   -->
>    <dependency>
>        <groupId>com.mofany</groupId>
>        <artifactId>cloud-api-commons</artifactId>
>        <version>1.0.0</version>
>    </dependency>
></dependencies>
>```
>
>#### config
>
>```java
>package com.mofany.config;
>
>import org.springframework.context.annotation.Bean;
>import org.springframework.context.annotation.Configuration;
>import org.springframework.web.client.RestTemplate;
>
>/**
> * @author MoFany-J
> * @date 2023/2/15
> * @description ApplicationContextConfig
> */
>@Configuration
>public class ApplicationContextConfig {
>    @Bean("restTemplate")
>    public RestTemplate getResetTemplate() {
>        return new RestTemplate();
>    }
>}
>```
>
>#### controller
>
>```java
>package com.mofany.controller;
>
>import com.mofany.entities.CommonResult;
>import com.mofany.entities.Payment;
>import lombok.extern.slf4j.Slf4j;
>import org.springframework.web.bind.annotation.*;
>import org.springframework.web.client.RestTemplate;
>
>import javax.annotation.Resource;
>
>/**
> * @author MoFany-J
> * @date 2023/2/15
> * @description OrderController 客户端controller模拟向服务端发请求
> */
>@Slf4j
>@RestController
>@RequestMapping("consumer/payment")
>public class OrderController {
>
>    private static final String PAYMENT_URL = "http://localhost:8001";
>    /**
>     * 不同端口的微服务之间通信
>     */
>    @Resource
>    private RestTemplate restTemplate;
>
>    /**
>     * 客户端向服务端发新增请求
>     */
>    @PostMapping ("create")
>    public CommonResult<Payment> create(@RequestBody Payment payment) {
>        // 返回时二次发请求
>        return restTemplate.postForObject(PAYMENT_URL + "/payment/create", payment, CommonResult.class);
>    }
>
>    /**
>     * 客户端向服务端发获取请求
>     *
>     * @return
>     */
>    @GetMapping("get/{id}")
>    public CommonResult getPayment(@PathVariable("id") Long id) {
>        // 返回时二次发请求
>        return restTemplate.getForObject(PAYMENT_URL + "/payment/get/" + id, CommonResult.class);
>    }
>}
>```
>
>#### 启动类
>
>```java
>package com.mofany;
>
>import org.springframework.boot.SpringApplication;
>import org.springframework.boot.autoconfigure.SpringBootApplication;
>
>/**
> * @author MoFany-J
> * @date 2023/2/15
> * @description OrderMain80
> */
>@SpringBootApplication
>public class OrderMain80 {
>    public static void main(String[] args) {
>        SpringApplication.run(OrderMain80.class, args);
>    }
>}
>```

# CAP理论与Base理论

## 何为CAP理论?

>#### `一个分布式系统永远满足三进二原则，CAP理论关注的是数据并非系统` 
>
>1. C`（Consistency）`：强，一致性，等同于所有节点访问同一份最新的数据副本。
>2. A`（Availability）`：高，可用性，每次请求都能获取到非错的响应，但是不保证获取的数据为最新数据。
>3. P`（Partition tolerance）`：分区容错性，以实际效果而言，分区相当于对通信的时限要求，**故`p`永远要在分布式中保证。**
>
>##### 对于一个分布式计算系统而言，不可能同时满足CAP三点
>
>##### **CAP** 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾
>
>##### 系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，`必须就当前操作在C和A之间做出选择`! 

## 何为Base理论？

>#### BASE理论是为解决CAP理论中提出的在分布式系统中`一致性（C）和可用性（A）不能兼得`的问题。。
>
>#### BASE模型与ACID模型截然不同，满足CAP理论，通过牺牲强一致性，获得可用性，一般应用在服务化系统的应用层或者大数据处理系统，通过达到最终一致性来尽量满足业务的绝大部分需求。
>
>#### BASE模型包含个三个元素：
>
>* ##### BA：Basically Available，基本可用
>
>  * 系统出现了不可预知的故障，但还是能用，相比较正常的系统而言会有响应时间上的损失和功能上的损失。
>
>* ##### S：Soft State，软状态，状态可以有一段时间不同步
>  * 什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。
>
>    软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。
>
>* #### E：Eventually Consistent，最终一致，最终数据是一致的就可以了，而不是时时保持强一致。
>
>  * 上面说软状态，然后不可能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于网络延时、系统负载、数据复制方案设计等等因素。
>
>  * 而在实际工程实践中，最终一致性分为5种：
>
>    1. **因果一致性（Causal consistency）**
>
>       因果一致性指的是：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和修改都是基于A更新后的值。于此同时，和节点A无因果关系的节点C的数据访问则没有这样的限制。
>
>    2. **读己之所写一致性（Read-your-writes consistency）**
>
>       读己之所写指的是：节点A更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。
>
>    3. **会话一致性（Session consistency）**
>
>       会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值
>
>    4. **单调读一致性（Monotonic read consistency）**
>
>       单调读一致性指的是：如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。
>
>    5. **单调写一致性（Monotonic write consistency）**
>
>       单调写一致性指的是：一个系统要能够保证来自同一个节点的写操作被顺序的执行。
>
>> 在实际的实践中，这5种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。
>
>BASE模型的软状态是实现BASE理论的方法，基本可用和最终一致是目标。按照BASE模型实现的系统，由于不保证强一致性，系统在处理请求的过程中，可以存在短暂的不一致，在短暂的不一致窗口请求处理处在临时状态中，系统在做每步操作的时候，通过记录每一个临时状态，在系统出现故障的时候，可以从这些中间状态继续未完成的请求处理或者退回到原始状态，最后达到一致的状态。
>
>### ***BASE理论的思想是：系统可能处于不一致的状态，但最终会变得一致***

# SpringCloud升级及核心组件

## AP-服务注册中心`Eureka`:x::cowboy_hat_face:

>#### Eureka 采用 CS（Client/Server，客户端/服务器） 架构，它包括以下两大组件：
>
>- **Eureka Server**：Eureka 服务注册中心，主要用于提供服务注册功能。当微服务启动时，会将自己的服务注册到 Eureka Server。Eureka Server 维护了一个可用服务列表，存储了所有注册到 Eureka Server 的可用服务的信息，这些可用服务可以在 Eureka Server 的管理界面中直观看到。
>- **Eureka Client**：Eureka 客户端，通常指的是微服务系统中各个微服务，主要用于和 Eureka Server 进行交互。在微服务应用启动后，Eureka Client 会向 Eureka Server 发送心跳（默认周期为 30 秒）。若 Eureka Server 在多个心跳周期内没有接收到某个 Eureka Client 的心跳，Eureka Server 将它从可用服务列表中移除（默认 90 秒）。 
>  * “心跳”指的是一段定时发送的自定义信息，让对方知道自己“存活”，以确保连接的有效性。大部分 CS 架构的应用程序都采用了心跳机制，服务端和客户端都可以发心跳。通常情况下是客户端向服务器端发送心跳包，服务端用于判断客户端是否在线。
>
>#### **Eureka原理**
>
>- **服务注册中心（Register Service）**：它是一个 Eureka Server，用于提供服务注册和发现功能。
>- **服务提供者（Provider Service）**：它是一个 Eureka Client，用于提供服务。它将自己提供的服务注册到服务注册中心，以供服务消费者发现。
>- **服务消费者（Consumer Service）**：它是一个 Eureka Client，用于消费服务。它可以从服务注册中心获取服务列表，调用所需的服务。
>
>#### 编码实现单机版`服务注册中心7001、服务提供者8001、服务消费者80`
>
>* **Eureka提供负载均衡的注解：`@LoadBalanced注解`赋予RestTemplate默认轮询的负载均衡的能力**
>* **Eureka修饰主启动类的核心注解**
>  1. `@EnableEurekaServer注解`	开启服务注册中心
>  2. `@EnableEurekaClient注解 ` 开启客户端，服务的提供者或服务的消费者
>  3. `@EnableDiscoveryClient注解`
>
>* **Eureka Server依赖，服务端`注册服务中心`cloud-eureka-server7001**
>
>  ```xml
>  <!--    Eureka-Server    -->
>  <dependency>
>      <groupId>org.springframework.cloud</groupId>
>      <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
>  </dependency>
>  ```
>
>  * 全局配置`application.yaml`
>
>    ```yaml
>    server:
>      port: 7001
>    
>    # 配置Eureka服务注册中心
>    eureka:
>      instance:
>        hostname: localhost # eureka服务端的实例名称
>      client:
>        register-with-eureka: false # false表示不向注册中心注册自己
>        fetch-registry: false # false表示自己是注册中心，我的职责就是维护服务实例，并不需要去检索服务
>        service-url:
>          # 设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址
>          defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
>    ```
>
>  * 主启动类
>
>    * 使用**`@EnableEurekaServer`**注解开启**`Eureka服务支持，即开启服务注册中心`**
>
>    ```java
>    package com.mofany;
>    
>    import org.springframework.boot.SpringApplication;
>    import org.springframework.boot.autoconfigure.SpringBootApplication;
>    import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;
>    
>    /**
>     * @author MoFany-J
>     * @date 2023/2/15
>     * @description EurekaMain7001
>     */
>    @EnableEurekaServer	// 服务注册中心
>    @SpringBootApplication
>    public class EurekaMain7001 {
>        public static void main(String[] args) {
>            SpringApplication.run(EurekaMain7001.class,args);
>        }
>    }
>    ```
>
>  * 启动该模块`输入URL后出现Eureka网站`
>
>    ```http
>    http://localhost:7001/
>    ```
>
>* **Eureka Client依赖，客户端`服务的提供者`cloud-provider-payment8001**
>
>  ```xml
>  <!--    Eureka-Client    -->
>  <dependency>
>      <groupId>org.springframework.cloud</groupId>
>      <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
>  </dependency>
>  ```
>
>  * 全局配置`application.yaml`
>
>    ```yaml
>    server:
>      port: 8001
>    
>    spring:
>      application:
>        name: cloud-payment-service
>      datasource:
>        type: com.alibaba.druid.pool.DruidDataSource
>        driver-class-name: com.mysql.cj.jdbc.Driver
>        url: jdbc:mysql://localhost:3306/springcloud?ServerTimezone=GMT%2B8
>        username: root
>        password: Jiangmh220
>      sql:
>        init:
>          mode: always
>          schema-locations:
>            - classpath:payment.sql         # 建表的Sql脚本
>          data-locations:
>            - classpath:payment-data.sql    # 插值的Sql脚本
>    
>    mybatis:
>      type-aliases-package: com.mofany.entities             # 所有entity别名类所在包
>      mapper-locations: classpath*:mapper/*Mapper.xml
>    
>    # 配置Eureka服务提供者
>    eureka:
>      client:
>        register-with-eureka: true  # 表示是否将自己注册进Eureka-Server默认位true
>        # 是否从Eureka—Server抓取已有的注册信息，默认位true
>        # 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
>        fetch-registry: true
>        service-url:
>          defaultZone: http://localhost:7001/eureka
>    ```
>
>  * 主启动类
>
>    * 使用**`@EnableEurekaClient`**注解开启**`Eureka客户支持，即客户端向服务注册中心注册成为服务的提供者`**
>
>    ```java
>    package com.mofany;
>    
>    import org.mybatis.spring.annotation.MapperScan;
>    import org.springframework.boot.SpringApplication;
>    import org.springframework.boot.autoconfigure.SpringBootApplication;
>    import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
>    
>    /**
>     * @author MoFany-J
>     * @date 2023/2/14
>     * @description PaymentMain8001 支付模块
>     */
>    @EnableEurekaClient // 服务的提供者
>    @SpringBootApplication
>    @MapperScan(basePackages = "com.mofany.mapper")
>    public class PaymentMain8001 {
>        public static void main(String[] args) {
>            SpringApplication.run(PaymentMain8001.class,args);
>        }
>    }
>    ```
>
>  * 启动7001、8001模块`向服务注册中心注册服务的提供者`
>
>    * 先启动**`Eureka-Server`服务注册中心7001**
>    * 后启动**`Eureka-Client`服务提供者8001**`入驻服务注册中心，职位服务提供者`
>
>  | Application               |    AMIs     | Availability Zones | Status                                                       |
>  | ------------------------- | :---------: | :----------------: | ------------------------------------------------------------ |
>  | **CLOUD-PAYMENT-SERVICE** | **n/a** (1) |        (1)         | **UP** (1) - [MoFany_J:cloud-payment-service:8001](http://mofany_j:8001/actuator/info) |
>
>* **Eureka Client依赖，消费者`服务的消费者使用者`cloud-consumer-order80**
>
>  ```xml
>  <dependency>
>      <groupId>org.springframework.cloud</groupId>
>      <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
>  </dependency>
>  ```
>
>  * 全局配置`application.yaml`
>
>    ```yaml
>    server:
>      port: 80
>    
>    # 指定服务消费者名字
>    spring:
>      application:
>        name: cloud-order-service
>    
>    # 配置eureka服务消费者
>    eureka:
>      client:
>        # 表示是否将自己注册进Eureka-Server，默认为true
>        register-with-eureka: true
>        # 是否从Eureka—Server抓取已有的注册信息，默认为true
>        # 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
>        fetch-registry: true
>        service-url:
>          defaultZone: http://localhost:7001/eureka
>    ```
>
>  * 主启动类
>
>    * 使用**`@EnableEurekaClient`**注解开启**`Eureka客户支持，即客户端向服务注册中心注册成为服务的消费者`**
>
>    ```java
>    package com.mofany;
>    
>    import org.springframework.boot.SpringApplication;
>    import org.springframework.boot.autoconfigure.SpringBootApplication;
>    import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
>    
>    /**
>     * @author MoFany-J
>     * @date 2023/2/15
>     * @description OrderMain80
>     */
>    @EnableEurekaClient // 服务的消费者
>    @SpringBootApplication
>    public class OrderMain80 {
>        public static void main(String[] args) {
>            SpringApplication.run(OrderMain80.class, args);
>        }
>    }
>    ```
>
>  * 启动7001、8001、80模块`先后向服务注册中心7001注册服务提供者8001与服务消费者80`
>
>    * 先启动**`Eureka-Server`服务注册中心7001**
>    * 再启动**`Eureka-Client`服务提供者8001**`入驻服务注册中心，职位服务提供者`
>    * 最后启动**`Eureka-Client`服务消费者80**`入驻服务注册中心，职位服务消费者`
>
>  |        Application        |    AMIs     | Availability Zones | Status                                                       |
>  | :-----------------------: | :---------: | :----------------: | ------------------------------------------------------------ |
>  |  **CLOUD-ORDER-SERVICE**  | **n/a** (1) |        (1)         | **UP** (1) - [MoFany_J:cloud-order-service:80](http://mofany_j/actuator/info) |
>  | **CLOUD-PAYMENT-SERVICE** | **n/a** (1) |        (1)         | **UP** (1) - [MoFany_J:cloud-payment-service:8001](http://mofany_j:8001/actuator/info) |
>
>* 最后测试
>
>  ```http
>  http://localhost/consumer/payment/get/1
>  ```
>
>* 结果
>
>  ```java
>  {
>  	"code": 200,
>  	"message": "查询成功",
>  	"data": {
>  		"id": 1,
>  		"serial": "笑傲江湖"
>  	}
>  }
>  ```
>
>#### `集群Eureka`不使用集群，注册中心与服务提供者异常时会引起单点故障
>
>* 使用集群的目的是实现**高可用**。
>
>* 多个服务注册中心：互相注册，相互守望
>
>* 域名映射：修改本地系统的`hosts`加入同一回环ip的不同映射
>
>  ```properties
>  ######################SpringCloud2022###############
>  
>  127.0.0.1 eureka7001.com
>  127.0.0.1 eureka7002.com
>  ```
>
>* 配置`cloud-eureka-server7001`服务注册中心：`application.yaml`
>
>  ```yaml
>  server:
>    port: 7001
>  
>  # 配置Eureka服务注册中心
>  eureka:
>    instance:
>      hostname: eureka7001.com # eureka服务端的实例名称
>    client:
>      register-with-eureka: false # false表示不向注册中心注册自己
>      fetch-registry: false # false表示自己是注册中心，我的职责就是维护服务实例，并不需要去检索服务
>      service-url:
>        # 设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址
>        defaultZone: http://eureka7002.com:7002/eureka/
>  ```
>
>* 配置`cloud-eureka-server7002`服务注册中心：`application.yaml`
>
>  ```yaml
>  server:
>    port: 7002
>  
>  # 配置Eureka服务注册中心
>  eureka:
>    instance:
>      hostname: eureka7002.com # eureka服务端的实例名称
>    client:
>      register-with-eureka: false # false表示不向注册中心注册自己
>      fetch-registry: false # false表示自己是注册中心，我的职责就是维护服务实例，并不需要去检索服务
>      service-url:
>        # 设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址
>        defaultZone: http://eureka7001.com:7001/eureka/
>  ```
>
>* 启动eureka7001与eureka7002
>
>  ```properties
>  http://eureka7001.com:7001/  ——————>  eureka7002.com
>  http://eureka7002.com:7002/  ——————>  eureka7001.com
>  
>   ------   —————>  ------
>  | 7001 |         | 7002 |
>   ------  <—————   ------
>  ```
>
>  #### 集群版`服务提供者8001，服务消费者80`
>
>  * `服务提供者8001`配置`application.yaml`
>
>    ```yaml
>    server:
>      port: 8001
>    
>    spring:
>      application:
>        name: cloud-payment-service
>      datasource:
>        type: com.alibaba.druid.pool.DruidDataSource
>        driver-class-name: com.mysql.cj.jdbc.Driver
>        url: jdbc:mysql://localhost:3306/springcloud?ServerTimezone=GMT%2B8
>        username: root
>        password: Jiangmh220
>      sql:
>        init:
>          mode: always
>          schema-locations:
>            - classpath:payment.sql         # 建表的Sql脚本
>          data-locations:
>            - classpath:payment-data.sql    # 插值的Sql脚本
>    
>    mybatis:
>      type-aliases-package: com.mofany.entities             # 所有entity别名类所在包
>      mapper-locations: classpath*:mapper/*Mapper.xml
>    
>    
>    # 配置Eureka提供者，即服务的提供者
>    eureka:
>      client:
>        register-with-eureka: true  # 表示是否将自己注册进Eureka-Server默认位true
>        # 是否从Eureka—Server抓取已有的注册信息，默认位true
>        # 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
>        fetch-registry: true
>        service-url:
>        # 集群版
>          defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  
>    ```
>
>  * `服务消费者80`配置`application.yaml`
>
>    ```yaml
>    server:
>      port: 80
>    
>    # 指定服务消费者名字
>    spring:
>      application:
>        name: cloud-order-service
>    
>    # 配置eureka服务消费者
>    eureka:
>      client:
>        # 表示是否将自己注册进Eureka-Server，默认为true
>        register-with-eureka: true
>        # 是否从Eureka—Server抓取已有的注册信息，默认为true
>        # 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
>        fetch-registry: true
>        service-url:
>        # 集群版
>          defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka
>    ```
>
>#### 集群测试
>
>* 测试顺序
>
>  * 先启动所有服务注册中心：`7001、7002`
>  * 接着启动所有服务提供者：`8001`
>  * 最后启动所有服务消费者：`80`
>
>* 访问：`http://eureka7001.com:7001`
>
>  | Application               |    AMIs     | Availability Zones | Status                                                       |
>  | ------------------------- | :---------: | :----------------: | ------------------------------------------------------------ |
>  | **CLOUD-ORDER-SERVICE**   | **n/a** (1) |        (1)         | **UP** (1) - [MoFany_J:cloud-order-service:80](http://mofany_j/actuator/info) |
>  | **CLOUD-PAYMENT-SERVICE** | **n/a** (1) |        (1)         | **UP** (1) - [MoFany_J:cloud-payment-service:8001](http://mofany_j:8001/actuator/info) |
>
>* 访问：`http://eureka7002.com:7002`
>
>  | Application               |    AMIs     | Availability Zones | Status                                                       |
>  | ------------------------- | :---------: | :----------------: | ------------------------------------------------------------ |
>  | **CLOUD-ORDER-SERVICE**   | **n/a** (1) |        (1)         | **UP** (1) - [MoFany_J:cloud-order-service:80](http://mofany_j/actuator/info) |
>  | **CLOUD-PAYMENT-SERVICE** | **n/a** (1) |        (1)         | **UP** (1) - [MoFany_J:cloud-payment-service:8001](http://mofany_j:8001/actuator/info) |
>
>#### 搭建服务注册中心集群`负载均衡`
>
>* 配置服务注册中心`cloud-provider-payment8001`服务提供者`application.yaml`
>
>  ```yaml
>  server:
>    port: 8001
>  
>  spring:
>    application:
>      name: cloud-payment-service
>    datasource:
>      type: com.alibaba.druid.pool.DruidDataSource
>      driver-class-name: com.mysql.cj.jdbc.Driver
>      url: jdbc:mysql://localhost:3306/springcloud?ServerTimezone=GMT%2B8
>      username: root
>      password: Jiangmh220
>    sql:
>      init:
>        mode: always
>        schema-locations:
>          - classpath:payment.sql         # 建表的Sql脚本
>        data-locations:
>          - classpath:payment-data.sql    # 插值的Sql脚本
>  
>  mybatis:
>    type-aliases-package: com.mofany.entities             # 所有entity别名类所在包
>    mapper-locations: classpath*:mapper/*Mapper.xml
>  
>  # 配置Eureka提供者，即服务的提供者
>  eureka:
>    client:
>      register-with-eureka: true  # 表示是否将自己注册进Eureka-Server默认位true
>      # 是否从Eureka—Server抓取已有的注册信息，默认位true
>      # 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
>      fetch-registry: true
>      service-url:
>        defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版
>  ```
>
>* 配置服务注册中心`cloud-provider-payment8002`服务提供者`application.yaml`
>
>  ```yaml
>  server:
>    port: 8002
>  
>  spring:
>    application:
>      name: cloud-payment-service
>    datasource:
>      type: com.alibaba.druid.pool.DruidDataSource
>      driver-class-name: com.mysql.cj.jdbc.Driver
>      url: jdbc:mysql://localhost:3306/springcloud?ServerTimezone=GMT%2B8
>      username: root
>      password: Jiangmh220
>  
>  mybatis:
>    type-aliases-package: com.mofany.entities             # 所有entity别名类所在包
>    mapper-locations: classpath*:mapper/*Mapper.xml
>  
>  # 配置Eureka提供者，即服务的提供者
>  eureka:
>    client:
>      register-with-eureka: true  # 表示是否将自己注册进Eureka-Server默认位true
>      # 是否从Eureka—Server抓取已有的注册信息，默认位true
>      # 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
>      fetch-registry: true
>      service-url:
>        #      defaultZone: http://localhost:7001/eureka/   # 单机版
>        defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版
>  ```
>
>* 修改服务消费者的控制器与配置类，使其支持轮询的以负载均衡的方式访问服务提供者集群
>
>  * controller
>
>    ```java
>    package com.mofany.controller;
>    
>    import com.mofany.entities.CommonResult;
>    import com.mofany.entities.Payment;
>    import lombok.extern.slf4j.Slf4j;
>    import org.springframework.web.bind.annotation.*;
>    import org.springframework.web.client.RestTemplate;
>    
>    import javax.annotation.Resource;
>    
>    /**
>     * @author MoFany-J
>     * @date 2023/2/15
>     * @description OrderController 客户端controller模拟向服务端发请求
>     */
>    @Slf4j
>    @RestController
>    @RequestMapping("consumer/payment")
>    public class OrderController {
>    
>        /**
>         * 集群版，URL为微服务名称
>         * */
>        private static final String PAYMENT_URL = "http://CLOUD-PAYMENT-SERVICE";
>    
>        /**
>         * 不同端口的微服务之间通信
>         */
>        @Resource
>        private RestTemplate restTemplate;
>    
>        /**
>         * 客户端向服务端发新增请求
>         */
>        @PostMapping ("create")
>        public CommonResult<Payment> create(@RequestBody Payment payment) {
>            // 返回时二次发请求
>            return restTemplate.postForObject(PAYMENT_URL + "/payment/create", payment, CommonResult.class);
>        }
>    
>        /**
>         * 客户端向服务端发获取请求
>         *
>         * @return
>         */
>        @GetMapping("get/{id}")
>        public CommonResult getPayment(@PathVariable("id") Long id) {
>            // 返回时二次发请求
>            return restTemplate.getForObject(PAYMENT_URL + "/payment/get/" + id, CommonResult.class);
>        }
>    }
>    ```
>
>  * config
>
>    * **`@LoadBalanced`注解赋予RestTemplate默认轮询的负载均衡的能力**
>
>    ```java
>    package com.mofany.config;
>    
>    import org.springframework.cloud.client.loadbalancer.LoadBalanced;
>    import org.springframework.context.annotation.Bean;
>    import org.springframework.context.annotation.Configuration;
>    import org.springframework.web.client.RestTemplate;
>    
>    /**
>     * @author MoFany-J
>     * @date 2023/2/15
>     * @description ApplicationContextConfig
>     */
>    @Configuration
>    public class ApplicationContextConfig {
>        /**
>         * @LoadBalanced注解赋予RestTemplate默认轮询的负载均衡的能力
>         * */
>        @LoadBalanced
>        @Bean("restTemplate")
>        public RestTemplate getResetTemplate() {
>            return new RestTemplate();
>        }
>    }
>    ```
>
>#### 服务注册中心集群测试
>
>* 访问：`http://eureka7001.com:7001`
>
>|        Application        |    AMIs     | Availability Zones | Status                                                       |
>| :-----------------------: | :---------: | :----------------: | ------------------------------------------------------------ |
>|  **CLOUD-ORDER-SERVICE**  | **n/a** (1) |        (1)         | **UP** (1) - [mofany:cloud-order-service:80](http://mofany/actuator/info) |
>| **CLOUD-PAYMENT-SERVICE** | **n/a** (2) |        (2)         | **UP** (2) - [mofany:cloud-payment-service:8002](http://mofany:8002/actuator/info) , [mofany:cloud-payment-service:8001](http://mofany:8001/actuator/info) |
>
>* 访问：`http://eureka7002.com:7002`
>
>|        Application        |    AMIs     | Availability Zones | Status                                                       |
>| :-----------------------: | :---------: | :----------------: | ------------------------------------------------------------ |
>|  **CLOUD-ORDER-SERVICE**  | **n/a** (1) |        (1)         | **UP** (1) - [mofany:cloud-order-service:80](http://mofany/actuator/info) |
>| **CLOUD-PAYMENT-SERVICE** | **n/a** (2) |        (2)         | **UP** (2) - [mofany:cloud-payment-service:8002](http://mofany:8002/actuator/info) , [mofany:cloud-payment-service:8001](http://mofany:8001/actuator/info) |
>
>#### 同一条接口测试
>
>* 第一次测试：`http://localhost/consumer/payment/get/1`
>
>  ```json
>  {
>  	"code": 200,
>  	"message": "查询成功，serverPort：8001",
>  	"data": {
>  		"id": 1,
>  		"serial": "笑傲江湖"
>  	}
>  }
>  ```
>
>* 第二次测试：`http://localhost/consumer/payment/get/1`
>
>  ```json
>  {
>  	"code": 200,
>  	"message": "查询成功，serverPort：8002",
>  	"data": {
>  		"id": 1,
>  		"serial": "笑傲江湖"
>  	}
>  }
>  ```
>
>  * 发现两次同样的请求，但是返回值的端口号是交替出现的！故`达到了负载均衡效果`
>
>  * `Ribbon与Eureka整合后Consumer可以直接调用服务而不需要再关心地址与端口号，且该服务具有了负载均衡效果`
>
>    ##### `@LoadBalanced`注解可赋予`RestTemplate`默认轮询的负载均衡的能力!
>
>#### 完善集群配置
>
> * 8001
>
>    ```yaml
>    # 配置Eureka提供者，即服务的提供者
>    eureka:
>      client:
>        register-with-eureka: true  # 表示是否将自己注册进Eureka-Server默认位true
>        # 是否从Eureka—Server抓取已有的注册信息，默认位true
>        # 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
>        fetch-registry: true
>        service-url:
>          defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版
>      instance:
>        instance-id: payment8001    # 显示服务名
>        prefer-ip-address: true     # 服务名对应的IP地址
>    ```
>
>  * 8002
>
>    ```yaml
>    # 配置Eureka提供者，即服务的提供者
>    eureka:
>      client:
>        register-with-eureka: true  # 表示是否将自己注册进Eureka-Server默认位true
>        # 是否从Eureka—Server抓取已有的注册信息，默认位true
>        # 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
>        fetch-registry: true
>        service-url:
>          defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版
>      instance:
>        instance-id: payment8002    # 显示服务名
>        prefer-ip-address: true     # 服务名对应的IP地址
>    ```
>
>  * 主机名：服务名称修改与访问服务名显示IP
>
>    - 访问：`http://localhost:7001`
>
>    | Application               | AMIs        | Availability Zones | Status                                                       |
>    | ------------------------- | ----------- | ------------------ | ------------------------------------------------------------ |
>    | **CLOUD-ORDER-SERVICE**   | **n/a** (1) | (1)                | **UP** (1) - [mofany:cloud-order-service:80](http://mofany/actuator/info) |
>    | **CLOUD-PAYMENT-SERVICE** | **n/a** (2) | (2)                | **UP** (2) - [payment8002](http://mofany:8002/actuator/info) , [payment8001](http://mofany:8001/actuator/info) |
>
>    - 访问：`http://localhost:7002`
>
>    | Application               | AMIs        | Availability Zones | Status                                                       |
>    | ------------------------- | ----------- | ------------------ | ------------------------------------------------------------ |
>    | **CLOUD-ORDER-SERVICE**   | **n/a** (1) | (1)                | **UP** (1) - [mofany:cloud-order-service:80](http://mofany/actuator/info) |
>    | **CLOUD-PAYMENT-SERVICE** | **n/a** (2) | (2)                | **UP** (2) - [payment8002](http://mofany:8002/actuator/info) , [payment8001](http://mofany:8001/actuator/info) |
>
>
>#### Eureka服务发现`Discoverty`
>
>* **`@EnableDiscoveryClient`开启服务发现**
>
>  ```java
>  /**
>   * @author MoFany-J
>   * @date 2023/2/15
>   * @description PaymentController 支付模块对外的controller
>   */
>  @Slf4j
>  @RestController
>  @RequestMapping("payment")
>  public class PaymentController {
>  
>      /***
>       * 通过服务发现读取服务信息
>       * */
>      @Resource
>      private DiscoveryClient discoveryClient;
>  
>  	......
>      
>      /**
>       * 通过服务发现来查看本服务的信息
>       * */
>      @GetMapping("discovery")
>      public Object discovery(){
>          List<String> services=discoveryClient.getServices();
>          for (String element: services) {
>              log.info("*******element:"+element);
>          }
>          List<ServiceInstance> instances = 
>              discoveryClient.getInstances("CLOUD-PAYMENT-SERVICE");
>          for (ServiceInstance instance:instances) {
>              log.info(instance.getServiceId()+"\t"
>                       +instance.getHost()+"\t"
>                       +instance.getPort()+"\t"
>                       +instance.getUri());
>          }
>          return this.discoveryClient;
>      }
>  
>  }
>  ```
>
>* 访问：`http://localhost:8001/payment/discovery`
>
>  ```json
>  {
>    "services": [
>      "cloud-payment-service",
>      "cloud-order-service"
>    ],
>    "order": 0
>  }
>  ```
>
>  ```properties
>  2023-02-16 15:00:10.651  INFO 540 --- [io-8001-exec-10] com.mofany.controller.PaymentController  : *******element:cloud-payment-service
>  2023-02-16 15:00:10.652  INFO 540 --- [io-8001-exec-10] com.mofany.controller.PaymentController  : *******element:cloud-order-service
>  2023-02-16 15:00:10.652  INFO 540 --- [io-8001-exec-10] com.mofany.controller.PaymentController  : CLOUD-PAYMENT-SERVICE	192.168.0.110	8002	http://192.168.0.110:8002
>  2023-02-16 15:00:10.652  INFO 540 --- [io-8001-exec-10] com.mofany.controller.PaymentController  : CLOUD-PAYMENT-SERVICE	192.168.0.110	8001	http://192.168.0.110:8001
>  ```
>
>#### Eureka的自我保护
>
>* 保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护，一旦进入保护模式**Eureka Server将会常识保护其服务注册表种的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。**
>
>* **Eureka的自我保护属于分布式CAP里面的AP设计思想。**
>
>  * Eureka是为了误删除才开启自我保护机制的。
>  * **宁可保留错误的服务注册信息，也不盲目的注销任何可能健康的服务实例。**
>  * 即在某个时刻微服务无法使用了，Eureka不会立刻清理，而是Eureka依旧继续保存微服务的信息。
>
>* 官网上看到以下这句话，说明Eureka进入保护模式：
>
>  **`EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.`**	
>
>#### 禁止自Eureka我保护
>
>* 无用的服务立即清除，不保留。
>
>* 全局配置文件`application.yaml`中加入：
>
>  ```yaml
>  # 禁止Eureka自我保护
>  eureka:
>    server:
>      enable-self-preservation: false       # 禁用Eureka自我保护
>      eviction-interval-timer-in-ms: 2000   # 多长时间清除无用服务，ms
>  ```
>
>  * 自我保护机制已关闭：
>
>    **`THE SELF PRESERVATION MODE IS TURNED OFF. THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS.`**
>

## :accept:CP-服务注册中心`Zookeeper`:ballot_box_with_check::zap:

>##### 	zookeeper上存在一个znode（即自身）节点，而每一个微服务作为一个节点放到zookeeper中，其中微服务是zookeeper中的一个临时节点，策略是微服务关闭的一定时间内不会清除微服务节点过时则清除。
>
>zookeeper上节点分类：
>
>* 粗略分为两种：`临时节点`、`持久节点`；
>
>* 细分为四种：`临时节点`、`带序号的临时节点`、`持久节点`、`带序号的持久节点`
>
>#### 先在Linux上启动`Zookeeper`服务器`使用zookeeper的前提是Linux必须有jdk`
>
>```properties
>[root@localhost bin]# ./zkServer.sh start
>ZooKeeper JMX enabled by default
>Using config: /usr/local/zookeeper/apache-zookeeper-3.7.1-bin/bin/../conf/zoo.cfg
>Starting zookeeper ... STARTED
>```
>
>#### Zookeeper默认服务端口`2181`
>
>```properties
># 运行zookeeper
>[root@localhost bin]# ./zkCli.sh
>Connecting to localhost:2181
>```
>
>#### 然后关闭Linux防火墙或进行端口放行
>
>* 暂时关闭防火墙`下次开机重启`
>
>  ```properties
>  #查看防火墙状态
>  systemctl status firewalld
>  
>  #暂时关闭防火墙（下次开机启动）
>  systemctl stop firewalld
>  ```
>
>* 放行指定端口`不用关闭防火墙`
>
>  ```properties
>  #查询放行的全部端口
>  firewall-cmd --list-all
>  
>  #放行指定端口
>  firewall-cmd --zone=public --add-port=2181/tcp --permanent
>  
>  #刷新设置
>  firewall-cmd --reload
>  ```
>
>#### Zookeeper依赖准备
>
>```xml
><!--    SpringBoot整合Zookeeper客户端    -->
><dependency>
>    <groupId>org.springframework.cloud</groupId>
>    <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>
></dependency>
>```
>
>* 依赖排除`本地引入的jar包的版本应该与Linux上的zookeeper版本一致，否则会出现依赖冲突问题`
>
>  ```xml
>  <!--    整合的zookeeper版本应该与远程zookeeper版本一致    -->
>  <dependency>
>      <groupId>org.apache.zookeeper</groupId>
>      <artifactId>zookeeper</artifactId>
>      <version>3.7.1</version>
>  </dependency>
>  <!--    SpringCloud整合Zookeeper客户端    -->
>  <dependency>
>      <groupId>org.springframework.cloud</groupId>
>      <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>
>      <exclusions>
>          <!--  依赖排除自带的zookeeper否则可能与Linux上的zookeeper发生冲突    -->
>          <exclusion>
>              <groupId>org.apache.zookeeper</groupId>
>              <artifactId>zookeeper</artifactId>
>          </exclusion>
>      </exclusions>
>  </dependency>
>  ```
>
>#### `服务提供者`全局配置
>
>```yaml
># 服务提供者端口
>server:
>  port: 8004
>
># 服务别名---注册zookeeper到注册中心名称
>spring:
>  application:
>    name: cloud-provider-payment	# 服务名
>  cloud:
>    zookeeper:
>      # 单个zookeeper服务器的ip:端口
>      connect-string: 192.168.85.150:2181		#  集群版再加逗号 + ip:port即可
>```
>
>#### `服务提供者`业务类
>
>* controller
>
>  ```java
>  package com.mofany.controller;
>  
>  import lombok.extern.slf4j.Slf4j;
>  import org.springframework.beans.factory.annotation.Value;
>  import org.springframework.web.bind.annotation.GetMapping;
>  import org.springframework.web.bind.annotation.RequestMapping;
>  import org.springframework.web.bind.annotation.RestController;
>  
>  import java.util.UUID;
>  
>  /**
>   * @author MoFany-J
>   * @date 2023/2/16
>   * @description PaymentController
>   */
>  @RestController
>  @Slf4j
>  @RequestMapping("payment")
>  public class PaymentController {
>      @Value("${server.port}")
>      private String serverPort;
>  
>      @GetMapping("zookeeperTest")
>      public String paymentzk(){
>          return "springcloud with zookeeper："+serverPort+"\t"+ UUID.randomUUID().toString();
>      }
>  }
>  ```
>
>#### `服务提供者`启动类
>
>* **`@EnableDiscoveryClient`该注解用于向使用consul或zookeeper作为注册中心时提供注册服务**
>
>```java
>package com.mofany;
>
>import org.springframework.boot.SpringApplication;
>import org.springframework.boot.autoconfigure.SpringBootApplication;
>import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
>
>/**
> * @author MoFany-J
> * @date 2023/2/16
> * @description PaymentMain8004
> */
>@EnableDiscoveryClient // 该注解用于向使用consul或zookeeper作为注册中心时提供注册服务
>@SpringBootApplication
>public class PaymentMain8004 {
>    public static void main(String[] args) {
>        SpringApplication.run(PaymentMain8004.class,args);
>    }
>}
>```
>
>#### 服务提供者启动后Linux下的zookeeper的变化
>
>* 此时微服务的提供者成功注册到`服务注册中心Zookeeper`
>
>  * 微服务启动前，查看Linux下的zookeeper
>
>    ```properties
>    # 微服务启动前只有一个zookeeper自身的节点
>    [zk: localhost:2181(CONNECTED) 0] ls /
>    [zookeeper]
>    ```
>
>  * 微服务启动后，查看Linux下的zookeeper
>
>    ```properties
>    # 微服务启动后出现了service节点
>    [zk: localhost:2181(CONNECTED) 1] ls /
>    [services, zookeeper]
>    
>    # 查看service节点下的微服务
>    [zk: localhost:2181(CONNECTED) 2] ls /services
>    [cloud-provider-payment]
>    ```
>
>#### 请求测试`服务提供者`
>
>* 第一次请求访问`http://localhost:8004/payment/zookeeperTest`
>
>  ```properties
>  springcloud with zookeeper：8004 c4c44b00-5b4e-4c46-8800-1a7357fa23ae
>  ```
>
>* 第二次请求访问`http://localhost:8004/payment/zookeeperTest`
>
>  ```properties
>  springcloud with zookeeper：8004 6e173ddf-49bd-4aae-8864-01c03a723d24
>  ```
>
>* 第三次请求访问`http://localhost:8004/payment/zookeeperTest`
>
>  ```properties
>  springcloud with zookeeper：8004 e7a462f0-53ca-448c-afcf-af775f10876d
>  ```
>
>* 第四次请求访问`http://localhost:8004/payment/zookeeperTest`
>
>  ```properties
>  springcloud with zookeeper：8004 f1e46886-032b-4403-a3ba-9f2979af12e9
>  ```
>
>#### 查看zookeeper中注册进来的服务提供者的详情
>
>```properties
># 查看指定微服务的唯一标识
>[zk: localhost:2181(CONNECTED) 3] ls /services/cloud-provider-payment
>[042a102b-e328-47a5-9929-467b817dcee4]
>
># 获取唯一标识里的具体细节
>[zk: localhost:2181(CONNECTED) 5] get /services/cloud-provider-payment/042a102b-e328-47a5-9929-467b817dcee4
>{"name":"cloud-provider-payment","id":"042a102b-e328-47a5-9929-467b817dcee4","address":"mofany","port":8004,"sslPort":null,"payload":{"@class":"org.springframework.cloud.zookeeper.discovery.ZookeeperInstance","id":"cloud-provider-payment","name":"cloud-provider-payment","metadata":{"instance_status":"UP"}},"registrationTimeUTC":1676561781709,"serviceType":"DYNAMIC","uriSpec":{"parts":[{"value":"scheme","variable":true},{"value":"://","variable":false},{"value":"address","variable":true},{"value":":","variable":false},{"value":"port","variable":true}]}}
>[zk: localhost:2181(CONNECTED) 6]
>```
>
>* 格式化详情`json`
>
>  ```json
>  {
>    "name": "cloud-provider-payment",
>    "id": "042a102b-e328-47a5-9929-467b817dcee4",
>    "address": "mofany",
>    "port": 8004,
>    "sslPort": null,
>    "payload": {
>      "@class": "org.springframework.cloud.zookeeper.discovery.ZookeeperInstance",
>      "id": "cloud-provider-payment",
>      "name": "cloud-provider-payment",
>      "metadata": {
>        "instance_status": "UP"
>      }
>    },
>    "registrationTimeUTC": 1676561781709,
>    "serviceType": "DYNAMIC",
>    "uriSpec": {
>      "parts": [
>        {
>          "value": "scheme",
>          "variable": true
>        },
>        {
>          "value": "://",
>          "variable": false
>        },
>        {
>          "value": "address",
>          "variable": true
>        },
>        {
>          "value": ":",
>          "variable": false
>        },
>        {
>          "value": "port",
>          "variable": true
>        }
>      ]
>    }
>  }
>  ```
>
>#### `服务消费者`全局配置
>
>```yaml
># 服务消费者端口
>server:
>  port: 80
>
># 服务别名---注册zookeeper到注册中心名称
>spring:
>  application:
>    name: cloud-consumer-order
>  cloud:
>    zookeeper:
>      # 单个zookeeper服务器的ip:端口
>      connect-string: 192.168.85.150:2181		# 集群版再加逗号 + ip:port即可
>```
>
>#### `服务消费者`业务类`利用服务消费者访问服务提供者`
>
>* config
>
>  ```java
>  package com.mofany.config;
>  
>  import org.springframework.cloud.client.loadbalancer.LoadBalanced;
>  import org.springframework.context.annotation.Bean;
>  import org.springframework.context.annotation.Configuration;
>  import org.springframework.web.client.RestTemplate;
>  
>  /**
>   * @author MoFany-J
>   * @date 2023/2/17
>   * @description ApplicationContext
>   */
>  @Configuration
>  public class ApplicationContext {
>      @Bean
>      @LoadBalanced //启用负载均衡
>      public RestTemplate getRestTemplate() {
>          return new RestTemplate();
>      }
>  }
>  ```
>
>* controller
>
>  ```java
>  package com.mofany.controller;
>  
>  import lombok.extern.slf4j.Slf4j;
>  import org.springframework.web.bind.annotation.GetMapping;
>  import org.springframework.web.bind.annotation.RequestMapping;
>  import org.springframework.web.bind.annotation.RestController;
>  import org.springframework.web.client.RestTemplate;
>  
>  import javax.annotation.Resource;
>  
>  /**
>   * @author MoFany-J
>   * @date 2023/2/17
>   * @description OrderZKController
>   */
>  @Slf4j
>  @RestController
>  @RequestMapping("consumer")
>  public class OrderZKController {
>      public static final String INVOKE_URL = "http://cloud-provider-payment";
>      @Resource
>      private RestTemplate restTemplate;
>  
>      @GetMapping("payment/zookeeperTest")
>      public String paymentInfo() {
>          String result = restTemplate.getForObject(INVOKE_URL + 
>                                                    "/payment/zookeeperTest", String.class);
>          return result;
>      }
>  }
>  ```
>
>#### `服务消费者`启动类
>
>```java
>package com.mofany;
>
>import org.springframework.boot.SpringApplication;
>import org.springframework.boot.autoconfigure.SpringBootApplication;
>import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
>
>/**
> * @author MoFany-J
> * @date 2023/2/17
> * @description OrderZKMain80
> */
>@EnableDiscoveryClient // 服务消费者
>@SpringBootApplication
>public class OrderZKMain80 {
>    public static void main(String[] args) {
>        SpringApplication.run(OrderZKMain80.class, args);
>    }
>}
>```
>
>#### 测试
>
>* 先启动服务提供者`8004`
>
>* 后启动服务消费者`80`
>
>* 启动后zookeeper的变化
>
>  ```properties
>  # 服务提供者与服务消费者均未启动
>  [zk: localhost:2181(CONNECTED) 0] ls /
>  [zookeeper]
>  
>  # 服务提供者与服务消费者均已启动
>  [zk: localhost:2181(CONNECTED) 1] ls /
>  [services, zookeeper]
>  # 查看当前的微服务
>  [zk: localhost:2181(CONNECTED) 3] ls /services
>  [cloud-consumer-order, cloud-provider-payment]
>  ```
>
>* 直接访问服务提供者
>
>  ```http
>  http://localhost:8004/payment/zookeeperTest
>  ```
>
>  ```properties
>  # 第一次访问
>  springcloud with zookeeper：8004 6fb83f91-3fe5-4b99-98f1-7c91dc6b6712
>  
>  # 第二次访问
>  springcloud with zookeeper：8004 88158960-6e14-488e-bf2e-a2ee1579648b
>  
>  # 第三次访问
>  springcloud with zookeeper：8004 e1f33636-1cf3-40e6-8a43-2280ede4912b
>  ```
>
>* **通过访问服务消费者来间接访问服务提供者**
>
>  ```http
>  http://localhost/consumer/payment/zookeeperTest
>  ```
>
>  ```properties
>  # 第一次访问
>  springcloud with zookeeper：8004 d38c74aa-3d86-45e0-8479-2b1352023a24
>  
>  # 第二次访问
>  springcloud with zookeeper：8004 85445e03-6e5c-4be9-adb0-7dd4886c5a2c
>  
>  # 第三次访问
>  springcloud with zookeeper：8004 0f6d705b-b986-4392-be75-5622ccd9d512
>  ```
>

## :accept:CP-服务注册中心`Consul`:ballot_box_with_check::zap:

>#### Linux安装Consul
>
>```shell
>yum install -y yum-utils
>yum-config-manager --add-repo https://rpm.releases.hashicorp.com/RHEL/hashicorp.repo
>
># 安装consul
>yum -y install consul
>```
>
>#### 使用Windows版Consul
>
>* 首先在consul.exe目录下启动cmd
>
>* 输入命令测试：`consul -version`
>
>  ```shell
>  Consult-windows\consul_1.14.4_windows_amd64> consul -version
>  Consul v1.14.4
>  Revision dae670fe
>  Build Date 2023-01-26T15:47:10Z
>  Protocol 2 spoken by default, understands 2 to 3 (agent will automatically use protocol >2 when speaking to compatible agents)
>  ```
>
>* **使用开发模式启动：`consul agent -dev`**
>
>* 然后访问：`localhost:8500`
>
>#### 核心依赖
>
>```xml
><!--     SpringCloud-ConsulServer   -->
><dependency>
>    <groupId>org.springframework.cloud</groupId>
>    <artifactId>spring-cloud-starter-consul-discovery</artifactId>
></dependency>
>```
>
>#### `服务提供者`全局配置
>
>```yaml
># 服务提供者端口号
>server:
>  port: 8006
>
># 配置consul服务注册中心的服务提供者
>spring:
>  application:
>    name: consul-provider-payment   # 服务提供者的微服务名
>
>  cloud:
>    consul:
>      host: localhost   # consul的本地主机名
>      port: 8500        # 主机端口号
>      # hostname:127.0.0.1
>      discovery:
>        service-name: ${spring.application.name}
>```
>
>#### `服务提供者`业务类
>
>* controller
>
>  ```java
>  package com.mofan.controller;
>  
>  import lombok.extern.slf4j.Slf4j;
>  import org.springframework.beans.factory.annotation.Value;
>  import org.springframework.web.bind.annotation.GetMapping;
>  import org.springframework.web.bind.annotation.RestController;
>  
>  import java.util.UUID;
>  
>  /**
>   * @author MoFany-J
>   * @date 2023/2/17
>   * @description PaymentController
>   */
>  @RestController
>  @Slf4j
>  public class PaymentController {
>      @Value("${server.port}")
>      private String serverPort;
>  
>      @GetMapping("")
>      public String paymentConsul() {
>          return "spring cloud with consul：" + serverPort + "\t" + UUID.randomUUID().toString();
>      }
>  }
>  ```
>
>#### `服务提供者`启动类
>
>```java
>package com.mofan;
>
>import org.springframework.boot.SpringApplication;
>import org.springframework.boot.autoconfigure.SpringBootApplication;
>import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
>
>/**
> * @author MoFany-J
> * @date 2023/2/17
> * @description PaymentMain8006
> */
>@EnableDiscoveryClient // 开启服务的提供者
>@SpringBootApplication
>public class PaymentMain8006 {
>    public static void main(String[] args) {
>        SpringApplication.run(PaymentMain8006.class, args);
>    }
>}
>
>```
>
>* 测试`发现每次生成的流水号ID不同`
>
>  * 第一次请求：`http://localhost:8006/payment/consul`
>
>    ```properties
>    spring cloud with consul：8006 60dde209-85e3-4021-bdb1-715f9d62fa7d
>    ```
>
>  * 第二次请求：`http://localhost:8006/payment/consul`
>
>    ```properties
>    spring cloud with consul：8006 002bd420-6b8b-4b3b-8d3c-ccb99680aaf8
>    ```
>
>  * 第三次请求：`http://localhost:8006/payment/consul`
>
>    ```properties
>    spring cloud with consul：8006 989f4f85-0da0-4701-83f6-597de2174c53
>    ```
>
>#### `服务消费者`全局配置`利用服务消费者访问服务提供者`
>
>```yaml
># 服务消费者端口
>server:
>  port: 80
>
># 服务消费者配置
>spring:
>  application:
>    name: consul-consumer-order
>  # 注册中心地址
>  cloud:
>    consul:
>      host: localhost
>      port: 8500
>      discovery:
>        service-name: ${spring.application.name}
>```
>
>#### `服务消费者`业务类
>
>* config
>
>  ```java
>  package com.mofany.config;
>  
>  import org.springframework.cloud.client.loadbalancer.LoadBalanced;
>  import org.springframework.context.annotation.Bean;
>  import org.springframework.context.annotation.Configuration;
>  import org.springframework.web.client.RestTemplate;
>  
>  /**
>   * @author MoFany-J
>   * @date 2023/2/17
>   * @description ApplicationContextConfig
>   */
>  @Configuration
>  public class ApplicationContextConfig {
>      @Bean
>      @LoadBalanced
>      public RestTemplate getRestTemplate() {
>          return new RestTemplate();
>      }
>  }
>  ```
>
>* controller
>
>  ```java
>  package com.mofany.controller;
>  
>  import lombok.extern.slf4j.Slf4j;
>  import org.springframework.web.bind.annotation.GetMapping;
>  import org.springframework.web.bind.annotation.RequestMapping;
>  import org.springframework.web.bind.annotation.RestController;
>  import org.springframework.web.client.RestTemplate;
>  
>  import javax.annotation.Resource;
>  
>  /**
>   * @author MoFany-J
>   * @date 2023/2/17
>   * @description OrderConsulController
>   */
>  @RestController
>  @Slf4j
>  @RequestMapping("consumer")
>  public class OrderConsulController {
>  
>      /**
>       * 通过微服务的名字去请求
>       */
>      private static final String INVOKE_URL = "http://consul-provider-payment";
>  
>      @Resource
>      private RestTemplate restTemplate;
>  
>      /**
>       *
>       */
>      @GetMapping("payment/consul")
>      public String paymentInfo() {
>          String result = restTemplate.getForObject(INVOKE_URL + "/payment/consul", String.class);
>          return result;
>      }
>  }
>  ```
>
>#### `服务消费者`启动类
>
>```java
>package com.mofany;
>
>import org.springframework.boot.SpringApplication;
>import org.springframework.boot.autoconfigure.SpringBootApplication;
>import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
>
>/**
> * @author MoFany-J
> * @date 2023/2/17
> * @description OrderConsulMain80
> */
>@EnableDiscoveryClient // 开启服务消费者
>@SpringBootApplication
>public class OrderConsulMain80 {
>    public static void main(String[] args) {
>        SpringApplication.run(OrderConsulMain80.class, args);
>    }
>}
>```
>
>#### 测试`通过服务消费者访问服务提供者`
>
>* 第一次访问：`http://localhost/consumer/payment/consul`
>
>  ```properties
>  spring cloud with consul：8006 84fc2431-ed64-4a9f-a4b6-e0ca78dbc6e4
>  ```
>
>* 第二次访问：`http://localhost/consumer/payment/consul`
>
>  ```properties
>  spring cloud with consul：8006 feff9635-8e99-4ea4-9764-8647f036bdfb
>  ```
>
>* 第三次访问：`http://localhost/consumer/payment/consul`
>
>  ```properties
>  spring cloud with consul：8006 e8efe28c-fa68-4dfe-a1fb-38adabc1a6d6
>  ```
>
>  #### 由此发现同一个请求访问多次每次生成的`流水号ID都不相同`

## :accept:服务注册中心`Nacos`:ballot_box_with_check:

>
>

## 服务调用`Ribbon`:ballot_box_with_check:

> ##### Spring Cloud Ribbon是基于`Netflix`实现的一套客户端负载均衡的工具
>
> #### 负载均衡就是将用户的请求平均分配到多个服务器上，即降低单台服务器所承受的负荷
>
> Ribbon专门提供LB，而负载均衡分为两种：`负载均衡+RestTemplate`
>
> 1. 集中式LB`Nginx属于服务端负载均衡`
>    * Nginx是服务器服务器负载均衡，客户端所有请求都会交给nginx,然后由nginx实现请求转发，即负载均衡是由服务端实现的。
> 2. 进程内LB`Ribbon属于本地负载均衡`
>    * Rebbon本地负载均衡，在调用微服务接口时，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。
>
> #### Ribbon依赖
>
> ```xml
> <!-- 核心依赖1 -->
> <dependency>
>     <groupId>org.springframework.cloud</groupId>
>     <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
>     <version>2.2.10.RELEASE</version>
> </dependency>
> <!-- 核心依赖2 -->
> <dependency>
>     <groupId>com.netflix.ribbon</groupId>
>     <artifactId>ribbon-loadbalancer</artifactId>
>     <version>2.3.0</version>
>     <scope>compile</scope>
> </dependency>
> <!-- 核心依赖3 -->
> <dependency>
>     <groupId>org.springframework.cloud</groupId>
>     <artifactId>spring-cloud-netflix-ribbon</artifactId>
>     <version>2.2.10.RELEASE</version>
>     <scope>compile</scope>
> </dependency>
> ```
>
> #### ribbon中`getForObject()`与`getForEntity()`的区别：
>
> * `getForObject()`：返回对象为响应体中数据转化成的对象，基本上可以理解为`Json`。
> * `getForEntity()`：返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体。
>
> #### 测试业务
>
> ```java
> package com.mofany.controller;
> 
> import com.mofany.entities.CommonResult;
> import com.mofany.entities.Payment;
> import lombok.extern.slf4j.Slf4j;
> import org.springframework.http.ResponseEntity;
> import org.springframework.web.bind.annotation.*;
> import org.springframework.web.client.RestTemplate;
> 
> import javax.annotation.Resource;
> 
> /**
>  * @author MoFany-J
>  * @date 2023/2/15
>  * @description OrderController 客户端controller模拟向服务端发请求
>  */
> @Slf4j
> @RestController
> @RequestMapping("consumer/payment")
> public class OrderController {
> 
>     /**
>      * 集群版，URL为微服务名称
>      * */
>     private static final String PAYMENT_URL = "http://CLOUD-PAYMENT-SERVICE";
> 
>     /**
>      * 不同端口的微服务之间通信
>      */
>     @Resource
>     private RestTemplate restTemplate;
> 
>     @GetMapping("getEntity/{id}")
>     public CommonResult<Payment> getEntity(@PathVariable("id") Long id) {
>         // 返回时二次发请求
>         ResponseEntity<CommonResult> entity = restTemplate.getForEntity(PAYMENT_URL +
>                                                                         "/payment/get/" + 
>                                                                         id, CommonResult.class);
>         if (entity.getStatusCode().is2xxSuccessful()){
>             return entity.getBody();
>         }else {
>             return new CommonResult<>(444,"操作失败");
>         }
>     }
> }
> ```
>
> * 成功访问：`http://localhost/consumer/payment/getEntity/1`
>
>   ```java
>   {
>     "code": 200,
>     "message": "查询成功，serverPort：8002",
>     "data": {
>       "id": 1,
>       "serial": "笑傲江湖"
>     }
>   }
>   ```
>
> * 失败访问：`http://localhost/consumer/payment/getEntity/10`
>
>   ```java
>   {
>     "code": 444,
>     "message": "无对应记录，查询ID：10",
>     "data": null
>   }
>   ```
>
> #### Ribbon默认自带的负载均衡规则：
>
> 1. **`RoundRobinRule`	默认为轮询**
> 2. `RandomRule`    随机
> 3. `RetryRule`先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试，获取可用的服务
> 4. `WeightedResponseTimeRule`对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择
> 5. `BestAvailableRule`会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务
> 6. `AvailabilityFilteringRule`先过滤掉故障实例，再选择并发小的实例
> 7. `ZoneAvoidanceRule`默认规则，复合判断server所在区域的性能和serrver的可用性选择服务器
>
> #### Ribbon负载规则的替换：
>
> * 该自定义配置类不能放在`@ComponentScan`所扫描的当前包以及当前包的子包下（即不能放在主启动类所在包及其子包下），否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊定制的目的了。
>
> * **主启动类**
>
>   ```java
>   package com.mofany;
>   
>   import com.myrule.packages.MySelfRule;
>   import org.springframework.boot.SpringApplication;
>   import org.springframework.boot.autoconfigure.SpringBootApplication;
>   import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
>   import org.springframework.cloud.netflix.ribbon.RibbonClient;
>   
>   /**
>    * @author MoFany-J
>    * @date 2023/2/15
>    * @description OrderMain80
>    */
>   @RibbonClient(name = "CLOUD-PAYMENT-SERVICE",configuration = MySelfRule.class)  //Ribbon
>   @EnableEurekaClient // 服务的消费者
>   @SpringBootApplication
>   public class OrderMain80 {
>       public static void main(String[] args) {
>           SpringApplication.run(OrderMain80.class, args);
>       }
>   }
>   
>   ```
>
> * **自定义负载规则类**`不能位于主启动类的所在包或其子包下`
>
>   ```java
>   package com.myrule.packages;
>   
>   import com.netflix.loadbalancer.IRule;
>   import com.netflix.loadbalancer.RandomRule;
>   import org.springframework.context.annotation.Bean;
>   import org.springframework.context.annotation.Configuration;
>   
>   /**
>    * @author MoFany-J
>    * @date 2023/2/18
>    * @description MySelfRule
>    */
>   @Configuration
>   public class MySelfRule {
>       @Bean
>       public IRule myRule() {
>           /**
>            * 从轮询负载均衡切换为随机负载均衡
>            * */
>           return new RandomRule();
>       }
>   }
>   ```
>
>   #### 测试：
>
>   * 第一次访问：`http://localhost/consumer/payment/get/1`
>
>     ```properties
>     {
>       "code": 200,
>       "message": "查询成功，serverPort：8001",
>       "data": {
>         "id": 1,
>         "serial": "笑傲江湖"
>       }
>     }
>     ```
>
>   * 第二次访问：`http://localhost/consumer/payment/get/1`
>
>     ```properties
>     {
>       "code": 200,
>       "message": "查询成功，serverPort：8001",
>       "data": {
>         "id": 1,
>         "serial": "笑傲江湖"
>       }
>     }
>     ```
>
>   * 第三次访问：`http://localhost/consumer/payment/get/1`
>
>     ```properties
>     {
>       "code": 200,
>       "message": "查询成功，serverPort：8002",
>       "data": {
>         "id": 1,
>         "serial": "笑傲江湖"
>       }
>     }
>     ```
>
>     ##### 根据此结果我们发现：Ribbon的负载均衡机制由原来的轮询切换为了现在的随机。
>
> #### Ribbon负载均衡原理
>
> * 负载均衡算法：
>
>   |        Application        |    AMIs     | Availability Zones | Status                                                       |
>   | :-----------------------: | :---------: | :----------------: | ------------------------------------------------------------ |
>   | **CLOUD-PAYMENT-SERVICE** | **n/a** (2) |        (2)         | **UP** (2) - [payment8002](http://172.20.10.2:8002/actuator/info) , [payment8001](http://172.20.10.2:8001/actuator/info) |
>
>   * `每次服务重启后rest接口计数从1开始`**实际调用服务器位置下标 = rest接口的第几次请求数 % 服务器集群总数量**
>
>     ```properties
>     List<ServiceInstance> instances = discoveryClient.getInstances("CLOUD-PAYMENT-SERVICE");
>     
>     #如：
>     						# panyment8002
>     	List[0] instances = 127.0.0.1:8002
>     	
>     						# panyment8001
>     	List[1] instances = 127.0.0.1:8001	
>     
>     ################################################################################
>     8001+8002组合成为集群，它们共计2台机器，集群总数为2，按照轮询算法原理为：
>     
>     当总请求数为1时：1%2=1 对应下标位置为1，则获得服务地址为127.0.0.1:8001
>     当总请求数为2时：2%2=0 对应下标位置为0，则获得服务地址为127.0.0.1:8002
>     当总请求数为3时：3%2=1 对应下标位置为1，则获得服务地址为127.0.0.1:8001
>     当总请求数为4时：4%2=0 对应下标位置为0，则获得服务地址为127.0.0.1:8002
>     
>     如此类推......
>     ```
>
> #### Ribbon负载均衡算法分析
>
> * 旧版本核心：`原子类 + CAS + 自旋锁`
>
> * 新版本核心：
>
>   ```java
>   package com.netflix.loadbalancer;
>   
>   import com.netflix.client.config.IClientConfig;
>   import org.slf4j.Logger;
>   import org.slf4j.LoggerFactory;
>   
>   import java.util.List;
>   import java.util.concurrent.atomic.AtomicInteger;
>   
>   /**
>    * The most well known and basic load balancing strategy, i.e. Round Robin Rule.
>    *
>    * @author stonse
>    * @author Nikos Michalakis <nikos@netflix.com>
>    *
>    */
>   public class RoundRobinRule extends AbstractLoadBalancerRule {
>   
>       /**
>       * nextServerCyclicCounter可原子操作的下一台服务器的循环计数器
>       */
>       private AtomicInteger nextServerCyclicCounter;
>       /**
>       * 可用的存活的service
>       */
>       private static final boolean AVAILABLE_ONLY_SERVERS = true;
>       /**
>       * 全部service
>       */
>       private static final boolean ALL_SERVERS = false;
>   
>       /**
>       *  通过一个记录器工程创建一个记录器
>       */
>       private static Logger log = LoggerFactory.getLogger(RoundRobinRule.class);
>   
>       public RoundRobinRule() {
>           /**
>           * 构造器设置原子类实例初始值为0
>           */
>           nextServerCyclicCounter = new AtomicInteger(0);
>       }
>   
>       public RoundRobinRule(ILoadBalancer lb) {
>           this();
>           setLoadBalancer(lb);
>       }
>   
>       /**
>       * 负载均衡的核心算法：
>       * 核心方法1：用于返回下一台服务
>       */
>       public Server choose(ILoadBalancer lb, Object key) {
>           // 先判断是不是要进行负载均衡操作
>           if (lb == null) {
>               log.warn("no load balancer");
>               return null;
>           }
>   		// 初始化一台server
>           Server server = null;
>           // 定义一个计数器
>           int count = 0;
>           // 循环遍历并计数，直至server被指定且计数器小于10为止
>           while (server == null && count++ < 10) {
>               // 获取负载均衡下的可达的服务器作为一个lsit集合
>               List<Server> reachableServers = lb.getReachableServers();
>               // 获取负载均衡下的全部服务器作为一个list集合
>               List<Server> allServers = lb.getAllServers();
>               // 获取可达服务器list中的服务器数
>               int upCount = reachableServers.size();
>               // 获取全部服务器lsit中的服务器数
>               int serverCount = allServers.size();
>   			// 没有存活服务器时警告
>               if ((upCount == 0) || (serverCount == 0)) {
>                   log.warn("No up servers available from load balancer: " + lb);
>                   return null;
>               }
>   			/**
>   			* 返回下一台服务器的索引，通过
>   			*/
>               int nextServerIndex = incrementAndGetModulo(serverCount);
>               /**
>               * 通过服务器列表的下标从全部服务器列表中获取服务器实例server
>               */
>               server = allServers.get(nextServerIndex);
>   
>               if (server == null) {
>                   /* Transient. */
>                   Thread.yield();
>                   continue;
>               }
>   			// 获取到的这台服务器是否还活着且是否准备服务
>               if (server.isAlive() && (server.isReadyToServe())) {
>                   return (server);
>               }
>   
>               // Next.
>               server = null;
>           }
>   
>           if (count >= 10) {
>               log.warn("No available alive servers after 10 tries from load balancer: "
>                       + lb);
>           }
>           return server;
>       }
>   
>       /**
>       * 负载均衡的核心算法：
>       * 核心方法2：用于返回选择的吓一台服务所在列表的下标
>       */
>       private int incrementAndGetModulo(int modulo) {
>           /**
>           * 这是一个自旋锁，且采用了乐观锁CAS比较并交换，
>           */
>           for (;;) {
>               /**
>               * 获取当前服务器对应的循环计数器数值，其初始值是0
>               */
>               int current = nextServerCyclicCounter.get();
>               /**
>               * 求下一台服务的下标
>               */
>               int next = (current + 1) % modulo;
>               /**
>               * 进行比较并交换或比较并重设置值操作，传入的参数为当前值与下一次的值
>               */
>               if (nextServerCyclicCounter.compareAndSet(current, next))
>                   /**
>                   * 当上述条件成立并交换时更新值时，return执行并退出循环
>                   */
>                   return next;
>           }
>       }
>   
>       @Override
>       public Server choose(Object key) {
>           return choose(getLoadBalancer(), key);
>       }
>       @Override
>       public void initWithNiwsConfig(IClientConfig clientConfig) {
>       }
>   }
>   ```
>
> ### `基于服务消费者:`Ribbon负载均衡算法实现`自定义本地负载均衡器`
>
> * `config`
>
>   ```java
>   package com.mofany.config;
>   
>   import org.springframework.context.annotation.Bean;
>   import org.springframework.context.annotation.Configuration;
>   import org.springframework.web.client.RestTemplate;
>   
>   /**
>    * @author MoFany-J
>    * @date 2023/2/15
>    * @description ApplicationContextConfig
>    */
>   @Configuration
>   public class ApplicationContextConfig {
>   
>       @Bean("restTemplate")
>       public RestTemplate getResetTemplate() {
>           return new RestTemplate();
>       }
>   }
>   ```
>
> * `lb`面向接口编程
>
>   ```java
>   package com.mofany.lb;
>   
>   import org.springframework.cloud.client.ServiceInstance;
>   
>   import java.util.List;
>   
>   /**
>    * @author MoFany-J
>    * @date 2023/2/18
>    * @description MyLoadBalancer 自定义LoadBalancer接口
>    */
>   public interface MyLoadBalancer {
>   
>       /**
>        * @param serviceInstanceList 现在服务器集群上能够提供服务的机器的集合
>        * */
>       ServiceInstance instances(List<ServiceInstance> serviceInstanceList);
>   }
>   
>   ```
>
>   * 接口实现类
>
>     ```java
>     package com.mofany.lb.impl;
>     
>     import com.mofany.lb.MyLoadBalancer;
>     import org.springframework.cloud.client.ServiceInstance;
>     import org.springframework.stereotype.Component;
>     
>     import java.util.List;
>     import java.util.concurrent.atomic.AtomicInteger;
>     
>     /**
>      * @author MoFany-J
>      * @date 2023/2/18
>      * @description MyLoadBalancerImpl
>      */
>     @Component
>     public class MyLoadBalancerImpl implements MyLoadBalancer {
>     
>         /**
>          * 第一次时请求时原子整型类成员属性初始值为0
>          */
>         private AtomicInteger atomicInteger = new AtomicInteger(0);
>     
>         /**
>          * 先获取在增加
>          */
>         public final int getAndIncrement() {
>             // 当前值
>             int current;
>             // 请求访问的次数
>             int next;
>             do {
>                 // 第一次时请求时原子整型类成员属性初始值为0
>                 current = this.atomicInteger.get();
>                 /**
>                 * Integer.MAX_VALUE ==> 2147483647
>                 * 当有一天current值大于整数最大值即请求过多时从0开始计数
>                 */
>                 next = current >= 2147483647 ? 0 : current + 1;
>                 
>                 /**
>                  * 利用了自旋锁+乐观锁CAS：
>                  *		期望值为：current，新值为：next
>                  *      compareAndSetInt(this, VALUE, expectedValue, newValue)
>                  * 如果 VALUE == expectedValue，则以原子方式将VALUE设置为newValue
>                  * */
>             } while (!this.atomicInteger.compareAndSet(current, next)); // 乐观锁CAS+自旋锁
>             System.out.println("当前请求访问的次数为：" + next);
>             return next;
>         }
>     
>         /**
>          * 初始化的时候，必须指定可达机器集合
>          *
>          * @param serviceInstanceList
>          */
>         @Override
>         public ServiceInstance instances(List<ServiceInstance> serviceInstanceList) {
>             /**
>              * 返回服务器下标 = 当前请求次数 % 可达服务集群中微服务总数
>              * */
>             int index = getAndIncrement() % serviceInstanceList.size();
>             
>             /**
>             * 以下标index为参，获取对应的微服务实例
>             */ 
>             return serviceInstanceList.get(index);
>         }
>     }
>     ```
>
> * `controller`
>
>   ```java
>   package com.mofany.controller;
>   
>   import com.mofany.lb.MyLoadBalancer;
>   import lombok.extern.slf4j.Slf4j;
>   import org.springframework.cloud.client.ServiceInstance;
>   import org.springframework.cloud.client.discovery.DiscoveryClient;
>   import org.springframework.web.bind.annotation.*;
>   import org.springframework.web.client.RestTemplate;
>   
>   import javax.annotation.Resource;
>   import java.net.URI;
>   import java.util.List;
>   
>   /**
>    * @author MoFany-J
>    * @date 2023/2/15
>    * @description OrderController 客户端controller模拟向服务端发请求
>    */
>   @Slf4j
>   @RestController
>   @RequestMapping("consumer/payment")
>   public class OrderController {
>   
>       /**
>        * 不同端口的微服务之间通信
>        */
>       @Resource
>       private RestTemplate restTemplate;
>   
>       /**
>        * 自定义负载均衡依赖注入
>        */
>       @Resource
>       private MyLoadBalancer myLoadBalancer;
>       /**
>        * 获取客户端
>        */
>       @Resource
>       private DiscoveryClient discoveryClient;
>   
>       /**
>        * 测试自定义负载均衡器
>        */
>       @GetMapping("lb")
>       public String getPaymentLB() {
>           /**
>            * 获取指定service集群中的服务器列表
>            * */
>           List<ServiceInstance> serviceInstanceList = 
>               discoveryClient.getInstances("CLOUD-PAYMENT-SERVICE"); // 指定微服务集群的名字
>           // 排除无效的服务
>           if (serviceInstanceList == null || serviceInstanceList.size() <= 0) {
>               return null;
>           }
>           //获取有效的服务
>           ServiceInstance serviceInstance = myLoadBalancer.instances(serviceInstanceList);
>           //获取当前服务的URI
>           URI uri = serviceInstance.getUri();
>   
>           return restTemplate.getForObject(uri + "/payment/lb", String.class);
>       }
>   }
>   ```
>
>   #### 对应的服务提供者`8001`与`8002`controller层
>
>   ```java
>   package com.mofany.controller;
>   
>   import lombok.extern.slf4j.Slf4j;
>   import org.springframework.beans.factory.annotation.Value;
>   import org.springframework.web.bind.annotation.*;
>   
>   import java.util.List;
>   
>   /**
>    * @author MoFany-J
>    * @date 2023/2/15
>    * @description PaymentController 支付模块对外的controller
>    */
>   @Slf4j
>   @RestController
>   @RequestMapping("payment")
>   public class PaymentController {
>   
>       /**
>        * 读取全局配置的属性
>        * */
>       @Value("${server.port}")
>       private String serverPort;
>   
>       /**
>        * 测试自定义轮询算法
>        */
>       @GetMapping(value = "lb")
>       public String getPaymentLB() {
>           return serverPort;
>       }
>   }
>   ```
>
> #### 服务消费者的主启动类
>
> ```java
> package com.mofany;
> 
> import com.myrule.packages.MySelfRule;
> import org.springframework.boot.SpringApplication;
> import org.springframework.boot.autoconfigure.SpringBootApplication;
> import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
> import org.springframework.cloud.netflix.ribbon.RibbonClient;
> 
> /**
>  * @author MoFany-J
>  * @date 2023/2/15
>  * @description OrderMain80
>  */
> @EnableEurekaClient // 服务的消费者
> @SpringBootApplication
> public class OrderMain80 {
>     public static void main(String[] args) {
>         SpringApplication.run(OrderMain80.class, args);
>     }
> }
> ```
>
> #### 测试`基于服务消费者的负载均衡之自定义轮询算法`
>
> * 第一次访问：`http://localhost/consumer/payment/lb`
>
>   ```json
>   8001
>   ```
>
>   ```properties
>   当前请求访问的次数为：1
>   ```
>
> * 第二次访问：`http://localhost/consumer/payment/lb`
>
>   ```json
>   8002
>   ```
>
>   ```properties
>   当前请求访问的次数为：1
>   当前请求访问的次数为：2
>   ```
>
> * 第三次访问：`http://localhost/consumer/payment/lb`
>
>   ```json
>   8001
>   ```
>
>   ```properties
>   当前请求访问的次数为：1
>   当前请求访问的次数为：2
>   当前请求访问的次数为：3
>   ```
>
> * 第四次访问：`http://localhost/consumer/payment/lb`
>
>   ```json
>   8002
>   ```
>
>   ```properties
>   当前请求访问的次数为：1
>   当前请求访问的次数为：2
>   当前请求访问的次数为：3
>   当前请求访问的次数为：4
>   ```
>
> ### 总结：Ribbon的负载均衡策略，在其底层是采用`自旋锁+乐观锁CAS`实现的
>
> 1. **自旋锁中使用了求余运算来计算返回的服务下标**
>
> 2. **自旋锁的内部又采用了`compareAndSet()`CAS原子操作**

## 服务调用`LoadBalancer`:ballot_box_with_check:

>
>
>

## 服务调用`Feign`:x:

>* 请直接查看`OpneFeign`
>* ***Feign已经淘汰，请使用OpenFeign***

## :accept:服务调用`OpenFeign`:ballot_box_with_check::zap:

>* ##### Feign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。
>
>* ##### Feign的使用方式是`定义一个服务接口然后在上面添加注解`。
>
>* Feign也支持可插拔式的编码器与解码器。Sprig Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HTTP MessageConverters。
>
>* ##### Feign也可以与Eurek和Ribbon组合使用以支持负载均衡。
>
>* 现在可以的替换方案：`OpenFeign`===>Ribbon+RestTemplate
>
>* Fegin在此基础上做了封装，由他们帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，**我们只需要创建一个接口并使用注解的方式来配置它`以前我们直接在Dao接口上标注一个@Mapperz注解，二现在只需要在一个微服务接口上表主一个Feign注解即可`，即可完成对服务提供方的接口绑定，从而大大简化了使用Spring Cloud Ribbon时，自动封装服务调用客户端的开发量。**
>
>* ##### Feign集成了Reibbon，通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现服务调用。
>
>#### Feign与Open Feign的区别
>
>1. *Feign是Spring Cloud组件中的一个轻量级RestFul的HTTP服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务。*
>
>   ```xml
>   <!-- Feign 依赖 -->
>   <dependency>
>   	<groupId>org.springframework.cloud</groupId>
>       <artifactId>spring-cloud-starter-feign</artifactId>
>   </dependency>
>   ```
>
>2. ***OpenFeign是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如：`@RequestMapping`等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其它服务。***
>
>   ```xml
>   <!-- OpenFeign 依赖 -->
>   <dependency>
>   	<groupId>org.springframework.cloud</groupId>
>       <artifactId>spring-cloud-starter-openfeign</artifactId>
>   </dependency>
>   ```
>
>#### OpenFeign使用原理
>
>* **接口+注解  <==== > `微服务调用接口 + @FeignClient注解`实现服务调用**
>* **新建一个`XXXFeignService接口+@FeignClient`**
>
>#### 定义`服务消费者`
>
>* `opm.xml`依赖
>
>  ```xml
>  <dependencies>
>      <!--    openfeign依赖    -->
>      <dependency>
>          <groupId>org.springframework.cloud</groupId>
>          <artifactId>spring-cloud-starter-openfeign</artifactId>
>      </dependency>
>      <!--    eureka client依赖，作为服务消费者    -->
>      <dependency>
>          <groupId>org.springframework.cloud</groupId>
>          <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
>      </dependency>
>      <!--    引入自定义Api通用包，使用Payment支付Entity    -->
>      <dependency>
>          <groupId>com.mofany</groupId>
>          <artifactId>cloud-api-commons</artifactId>
>          <version>1.0.0</version>
>      </dependency>
>      <!--一般基础通用配置-->
>      <dependency>
>          <groupId>org.projectlombok</groupId>
>          <artifactId>lombok</artifactId>
>      </dependency>
>      <dependency>
>          <groupId>org.springframework.boot</groupId>
>          <artifactId>spring-boot-starter-web</artifactId>
>      </dependency>
>      <dependency>
>          <groupId>org.springframework.boot</groupId>
>          <artifactId>spring-boot-starter-actuator</artifactId>
>      </dependency>
>      <dependency>
>          <groupId>org.springframework.boot</groupId>
>          <artifactId>spring-boot-devtools</artifactId>
>          <scope>runtime</scope>
>          <optional>true</optional>
>      </dependency>
>      <dependency>
>          <groupId>org.springframework.boot</groupId>
>          <artifactId>spring-boot-starter-test</artifactId>
>          <scope>test</scope>
>      </dependency>
>  </dependencies>
>  ```
>
>* `application.yaml`全局配置
>
>  ```yaml
>  server:
>    port: 80
>  # eureka配置
>  eureka:
>    client:
>      register-with-eureka: false
>      service-url:
>        defaultZone: # 集群
>          - http://eureka7001.com:7001/eureka/
>          - http://eureka7002.com:7002/eureka/
>  ```
>
>* **业务类**
>
>  * service
>
>    * **`@FeignClient(value = "ServiceName服务名称")`使用OpenFeign**
>    * value的值为服务提供者全局配置中设置的：`spring.application.name=ServiceName`
>
>    ```java
>    package com.mofany.service;
>    
>    import com.mofany.entities.CommonResult;
>    import com.mofany.entities.Payment;
>    import feign.Param;
>    import org.springframework.cloud.openfeign.FeignClient;
>    import org.springframework.stereotype.Component;
>    import org.springframework.web.bind.annotation.GetMapping;
>    import org.springframework.web.bind.annotation.PathVariable;
>    import org.springframework.web.bind.annotation.PostMapping;
>    import org.springframework.web.bind.annotation.RequestBody;
>    
>    /**
>     * @author MoFany-J
>     * @date 2023/2/19
>     * @description PaymentFeignService
>     *
>     * 服务消费者FeignService接口的方法应与目标服务提供者的XxxService接口方法一致
>     */
>    @Component // 组件声明，这样可以Spring中的组件扫描识别并被Spring容器托管
>    @FeignClient(value = "CLOUD-PAYMENT-SERVICE") //服务调用,指定调用的微服务名
>    public interface PaymentFeignService {
>    
>        /**
>         * 新增，注意URL与请求的服务提供者controllre层控制器方法URL一致
>         */
>        @PostMapping("payment/create")
>        CommonResult create(@RequestBody Payment payment);
>    
>        /**
>         * 按id查Payment，注意URL与请求的服务提供者controllre层控制器方法URL一致
>         */
>        @GetMapping("payment/get/{id}")
>        CommonResult<Payment> getPaymentById(@PathVariable("id") Long id);
>    }
>    
>    ```
>
>    	#### 被Feign的XxxFeignService接口封装`目标服务提供者的controller层方法，与其controller层中的方法一致`
>
>    ```java
>    package com.mofany.controller;
>    
>    import com.mofany.entities.CommonResult;
>    import com.mofany.entities.Payment;
>    import com.mofany.service.PaymentService;
>    import lombok.extern.slf4j.Slf4j;
>    import org.springframework.beans.factory.annotation.Value;
>    import org.springframework.web.bind.annotation.*;
>    
>    import javax.annotation.Resource;
>    import java.util.List;
>    
>    /**
>     * @author MoFany-J
>     * @date 2023/2/15
>     * @description PaymentController 支付模块对外的controller
>     */
>    @Slf4j
>    @RestController
>    @RequestMapping("payment")
>    public class PaymentController {
>        @Resource
>        private PaymentService paymentService;
>    
>        /**
>         * 读取全局配置的属性
>         * */
>        @Value("${server.port}")
>        private String serverPort;
>    
>        /**
>         * 插入数据
>         * 测试接口：http://localhost:8001/payment/create
>         */
>        @PostMapping("create")
>        public CommonResult create(@RequestBody Payment payment) {
>            int result = paymentService.create(payment);
>            log.info("********插入结果：" + result);
>            if (result > 0) {
>                return new CommonResult(200, "插入数据成功，serverPort："+serverPort, result);
>            }
>            return new CommonResult(444, "插入数据失败", null);
>        }
>    
>        /**
>         * 查询
>         * 测试接口：http://localhost:8001/payment/get/1
>         */
>        @GetMapping("get/{id}")
>        public CommonResult<Payment> getPaymentById(@PathVariable("id") Long id) {
>            Payment payment = paymentService.getPaymentById(id);
>            log.info("********插入结果：" + payment);
>            if (payment != null) {
>                return new CommonResult(200, "查询成功，serverPort："+serverPort, payment);
>            }
>            return new CommonResult(444, "无对应记录，查询ID：" + id, null);
>        }
>    }
>    ```
>
>  * controller
>
>    ```java
>    package com.mofany.controller;
>    
>    import com.mofany.entities.CommonResult;
>    import com.mofany.entities.Payment;
>    import com.mofany.service.PaymentFeignService;
>    import lombok.extern.slf4j.Slf4j;
>    import org.springframework.web.bind.annotation.*;
>    
>    import javax.annotation.Resource;
>    
>    /**
>     * @author MoFany-J
>     * @date 2023/2/19
>     * @description OrderFeignController
>     */
>    @RestController
>    @Slf4j
>    @RequestMapping("consumer/payment")
>    public class OrderFeignController {
>        /**
>         * OpenFeign业务逻辑接口成员
>         */
>        @Resource
>        private PaymentFeignService paymentFeignService;
>    
>        /**
>        * 更加清晰更加简洁
>        */
>        @PostMapping("create")
>        public CommonResult create(@RequestBody Payment payment) {
>            return paymentFeignService.create(payment);
>        }
>    
>        /**
>        * 更加清晰更加简洁
>        */
>        @GetMapping("get/{id}")
>        public CommonResult<Payment> getPaymentById(@PathVariable("id") Long id) {
>            return paymentFeignService.getPaymentById(id);
>        }
>    }
>    ```
>
>* 主启动类
>
>  * **`@EnableFeignClients`激活OpenFeign使用**
>
>  ```java
>  package com.mofany;
>  
>  import org.springframework.boot.SpringApplication;
>  import org.springframework.boot.autoconfigure.SpringBootApplication;
>  import org.springframework.cloud.openfeign.EnableFeignClients;
>  
>  /**
>   * @author MoFany-J
>   * @date 2023/2/19
>   * @description OrderFeignMain80
>   */
>  
>  /**
>   * 不论我们使用什么都要激活：@EnableXXX
>   * 激活OpenFeign的使用
>   */
>  @EnableFeignClients
>  @SpringBootApplication
>  public class OrderFeignMain80 {
>      public static void main(String[] args) {
>          SpringApplication.run(OrderFeignMain80.class, args);
>      }
>  }
>  ```
>
>* **测试Feign的负载均衡效果**
>
>  * 第一次请求访问：`http://localhost/consumer/payment/get/1`
>
>    ```json
>    {
>      "code": 200,
>      "message": "查询成功，serverPort：8001", # 端口号号不同表示负载均衡策略为轮询
>      "data": {
>        "id": 1,
>        "serial": "笑傲江湖"
>      }
>    }
>    ```
>
>  * 第二次请求访问：`http://localhost/consumer/payment/get/1`
>
>    ```json
>    {
>      "code": 200,
>      "message": "查询成功，serverPort：8002", # 端口号号不同表示负载均衡策略为轮询
>      "data": {
>        "id": 1,
>        "serial": "笑傲江湖"
>      }
>    }
>    ```
>
>  * 第三次请求访问：`http://localhost/consumer/payment/get/1`
>
>    ```json
>    {
>      "code": 200,
>      "message": "查询成功，serverPort：8001", # 端口号号不同表示负载均衡策略为轮询
>      "data": {
>        "id": 1,
>        "serial": "笑傲江湖"
>      }
>    }
>    ```
>
>  * 第四次请求访问：`http://localhost/consumer/payment/get/1`
>
>    ```json
>    {
>      "code": 200,
>      "message": "查询成功，serverPort：8002", # 端口号号不同表示负载均衡策略为轮询
>      "data": {
>        "id": 1,
>        "serial": "笑傲江湖"
>      }
>    }
>    ```
>
>    ##### OpenFeign自带的负载均衡配置项`Feign天生集成了Ribbon，故OpenFeign也集成了`
>
>#### OpenFeign的超时控制
>
>* **服务消费者与服务提供者要进行超时范围的统一约束，否则可能因为超时而报错，该错误不会影响程序运行。**
>
>* ##### **Feign客户端默认只等待1秒，但服务端处理却超过了1秒，导致Feign不想等了，直接报错。**
>
>  ```properties
>  # 浏览器报错
>  Sun Feb 19 17:47:08 CST 2023
>  There was an unexpected error (type=Internal Server Error, status=500).
>  Read timed out executing GET http://CLOUD-PAYMENT-SERVICE/payment/feign/timeout
>  feign.RetryableException: Read timed out executing GET http://CLOUD-PAYMENT-SERVICE/payment/feign/timeout
>  
>  # IDEA控制台报错
>  java.net.SocketTimeoutException: Read timed out
>  ```
>
>* ***解决方法：`修改服务消费者的全局配置：application.yaml`***
>
>  * **方法一`未过时`：**
>
>    ```yaml
>    feign:
>      client:
>        config:
>          default:	# 这里就是指的所有被加载的默认FeignClient实现的服务配置都生效
>            connectTimeout: 5000
>            readTimeout: 5000
>    ```
>
>  * 方法二`过时`：
>
>    ```yaml
>    # 设置feign客户端超时时间（OpenFeign默认支持Ribbon）
>    ribbon:
>      # 指的是建立连接所用的时间，适用于网络正常的情况下，两端连接所用的时间，单位：ms
>      ReadTimeout: 5000
>      # 指的是建立连接后从服务器读取到可用资源所用的时间，单位：ms
>      ConnecTimeout: 5000
>    ```
>
>#### OpenFeign日志打印功能
>
>* 日志打印级别：
>  * `NONE`：默认的，不显示任何日志
>  * `BASIC`：仅记录请求方法、URL、响应状态码、执行时间
>  * `HEADERS`：除了BASIC中定义的信息外，还有：请求头与响应头信息
>  * `FULL`：除了HEADERS中定义的信息外，还有：请求正文、请求元数据、响应正文、响应元数据
>
>* ##### `服务消费者`***自定义日志配置类：***`config`
>
>  ```java
>  package com.mofany.config;
>  
>  import feign.Logger;
>  import org.springframework.context.annotation.Bean;
>  import org.springframework.context.annotation.Configuration;
>  
>  /**
>   * @author MoFany-J
>   * @date 2023/2/19
>   * @description FeignConfig 自定义日志配置类
>   */
>  @Configuration
>  public class FeignConfig {
>      @Bean
>      Logger.Level feignLoggerLevel() {
>          /**
>          * Feign的详细日志打印
>          */
>          return Logger.Level.FULL;
>      }
>  }
>  ```
>
>* ##### `服务消费者`***全局配置文件：***`application.xml`
>
>  ```yaml
>  logging:
>    level:
>      # Feign日志打印以什么级别监控哪个接口，由用户指定
>      com.mofany.service.PaymentFeignService: debug
>  ```
>
>* 测试：
>
>  * 请求访问：`http://localhost/consumer/payment/get/1`
>  * 控制台打印的日志
>
>  ```properties
>  2023-02-19 18:12:18.342 DEBUG 19124 --- [p-nio-80-exec-1] com.mofany.service.PaymentFeignService   : [PaymentFeignService#getPaymentById] ---> GET http://CLOUD-PAYMENT-SERVICE/payment/get/1 HTTP/1.1
>  2023-02-19 18:12:18.343 DEBUG 19124 --- [p-nio-80-exec-1] com.mofany.service.PaymentFeignService   : [PaymentFeignService#getPaymentById] ---> END HTTP (0-byte body)
>  2023-02-19 18:12:18.917 DEBUG 19124 --- [p-nio-80-exec-1] com.mofany.service.PaymentFeignService   : [PaymentFeignService#getPaymentById] <--- HTTP/1.1 200 (571ms)
>  2023-02-19 18:12:18.918 DEBUG 19124 --- [p-nio-80-exec-1] com.mofany.service.PaymentFeignService   : [PaymentFeignService#getPaymentById] connection: keep-alive
>  2023-02-19 18:12:18.918 DEBUG 19124 --- [p-nio-80-exec-1] com.mofany.service.PaymentFeignService   : [PaymentFeignService#getPaymentById] content-type: application/json
>  2023-02-19 18:12:18.918 DEBUG 19124 --- [p-nio-80-exec-1] com.mofany.service.PaymentFeignService   : [PaymentFeignService#getPaymentById] date: Sun, 19 Feb 2023 10:12:18 GMT
>  2023-02-19 18:12:18.918 DEBUG 19124 --- [p-nio-80-exec-1] com.mofany.service.PaymentFeignService   : [PaymentFeignService#getPaymentById] keep-alive: timeout=60
>  2023-02-19 18:12:18.918 DEBUG 19124 --- [p-nio-80-exec-1] com.mofany.service.PaymentFeignService   : [PaymentFeignService#getPaymentById] transfer-encoding: chunked
>  2023-02-19 18:12:18.918 DEBUG 19124 --- [p-nio-80-exec-1] com.mofany.service.PaymentFeignService   : [PaymentFeignService#getPaymentById] vary: Access-Control-Request-Headers
>  2023-02-19 18:12:18.918 DEBUG 19124 --- [p-nio-80-exec-1] com.mofany.service.PaymentFeignService   : [PaymentFeignService#getPaymentById] vary: Access-Control-Request-Method
>  2023-02-19 18:12:18.918 DEBUG 19124 --- [p-nio-80-exec-1] com.mofany.service.PaymentFeignService   : [PaymentFeignService#getPaymentById] vary: Origin
>  2023-02-19 18:12:18.918 DEBUG 19124 --- [p-nio-80-exec-1] com.mofany.service.PaymentFeignService   : [PaymentFeignService#getPaymentById] 
>  2023-02-19 18:12:18.919 DEBUG 19124 --- [p-nio-80-exec-1] com.mofany.service.PaymentFeignService   : [PaymentFeignService#getPaymentById] {"code":200,"message":"查询成功，serverPort：8001","data":{"id":1,"serial":"笑傲江湖"}}
>  2023-02-19 18:12:18.919 DEBUG 19124 --- [p-nio-80-exec-1] com.mofany.service.PaymentFeignService   : [PaymentFeignService#getPaymentById] <--- END HTTP (97-byte body)
>  ```

## 服务降级`Hystrix`:x:豪猪哥:cowboy_hat_face:

>##### 虽然停止更新与维护，但其优秀的设计理念值得学习
>
>* ##### `Hystrix`能够保证在一个依赖出现问题的情况下，不会导致整体服务失败`（即不会发生服务雪崩效应）`，避免级联故障，以提高分布式系统的弹性。
>
>* ##### `断路器`其实就是一种开关装置，当某个服务单元发生故障后，通过断路器的故障监控（类型熔断保险丝），`向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常`，这样就保证了服务调用的线程不会被长时间、不必要的占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。
>
>#### Hystrix的作用
>
>* `Hystrix`的核心
>  * **服务降级（fallback）：服务器忙，请稍后再试，不让客户端等待并立即返回一个友好提示** 
>    * 程序运行异常
>    * 超时
>    * 服务熔断触发服务降级
>    * 线程池/信号量打满也会导致服务降级
>  * **服务熔断（break）：类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示**
>  * **服务限流（flowlimit）：秒杀高并发等操作，严谨一窝蜂的过来拥挤，大家排队，一秒种N个，有序进行**
>* 接近实时的监控
>
>#### Hystrix依赖
>
>```xml
><dependency>
>    <groupId>org.springframework.cloud</groupId>
>    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
>    <version>2.2.10.RELEASE</version>
></dependency>
>```
>
>#### `服务注册中心`全局配置`application.yaml`
>
>```yaml
>server:
>  port: 7001
>
># 配置Eureka服务注册中心
>eureka:
>  instance:
>    hostname: eureka7001.com # eureka服务端的实例名称
>  client:
>    register-with-eureka: false # false表示不向注册中心注册自己
>    fetch-registry: false # false表示自己是注册中心，我的职责就是维护服务实例，并不需要去检索服务
>    service-url:
>      # 设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址
>      # 单机版
>      defaultZone: http://eureka7001.com:7001/eureka/
>  server:	# 禁止自我保护
>    enable-self-preservation: false       # 禁用Eureka自我保护
>    eviction-interval-timer-in-ms: 2000   # 多长时间清除无用服务，ms
>```
>
>#### `服务注册中心`启动类
>
>```java
>package com.mofany;
>
>import org.springframework.boot.SpringApplication;
>import org.springframework.boot.autoconfigure.SpringBootApplication;
>import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;
>
>/**
> * @author MoFany-J
> * @date 2023/2/15
> * @description EurekaMain7001
> */
>@EnableEurekaServer //服务注册中心7001
>@SpringBootApplication
>public class EurekaMain7001 {
>    public static void main(String[] args) {
>        SpringApplication.run(EurekaMain7001.class, args);
>    }
>}
>```
>
>#### `服务提供者`全局配置`application.yaml`
>
>```yaml
>server:
>  port: 8001
>spring:
>  application:
>    name: cloud-provider-hystrix-payment
># Eureka服务注册中心
>eureka:
>  client:
>    service-url:
>      defaultZone: http://eureka7001.com:7001/eureka  # 指定服务注册中心的交互地址
>    register-with-eureka: true  # 向上面指定的服务注册中心注册自己未服务提供者
>    fetch-registry: true		# 自己不是服务注册中心，需要检索服务
>
>```
>
>#### `服务提供者`业务类
>
>* controller
>
>  ```java
>  package com.mofany.controller;
>  
>  import com.mofany.service.PaymentService;
>  import lombok.extern.slf4j.Slf4j;
>  import org.springframework.beans.factory.annotation.Value;
>  import org.springframework.web.bind.annotation.GetMapping;
>  import org.springframework.web.bind.annotation.PathVariable;
>  import org.springframework.web.bind.annotation.RequestMapping;
>  import org.springframework.web.bind.annotation.RestController;
>  
>  import javax.annotation.Resource;
>  
>  /**
>   * @author MoFany-J
>   * @date 2023/2/19
>   * @description PaymentController
>   */
>  @RestController
>  @Slf4j
>  @RequestMapping("payment")
>  public class PaymentController {
>      @Resource
>      private PaymentService paymentService;
>  
>      @Value("${server.port}")
>      private String serverPort;
>  
>      /**
>       * 正常的，无异常的
>       */
>      @GetMapping("hystrix/ok/{id}")
>      public String paymentInfo_OK(@PathVariable("id") Integer id) {
>          String result = paymentService.paymentInfo_OK(id);
>          log.info("******result" + result);
>          return result;
>      }
>  
>      /**
>       * 不正常的，有异常的
>       */
>      @GetMapping("hystrix/timeout/{id}")
>      public String paymentInfo_TimeOut(@PathVariable("id") Integer id) {
>          String result = paymentService.paymentInfo_TimeOut(id);
>          log.info("******result" + result);
>          return result;
>      }
>  }
>  ```
>
>* service
>
>  ```java
>  package com.mofany.service;
>  
>  import org.springframework.stereotype.Service;
>  
>  import java.util.concurrent.TimeUnit;
>  
>  /**
>   * @author MoFany-J
>   * @date 2023/2/19
>   * @description PaymentService
>   */
>  @Service
>  public class PaymentService {
>      /**
>       * 正常访问一定OK的方法
>       */
>      public String paymentInfo_OK(Integer id) {
>          return "线程池" + Thread.currentThread().getName() 
>              + "paymentInfo_OK,id：" + id + "\t" + "O(n_n)O哈哈";
>      }
>  
>      /**
>       * 超时报错的方法
>       */
>      public String paymentInfo_TimeOut(Integer id) {
>          int timeNumber = 3;
>          try {
>              TimeUnit.SECONDS.sleep(timeNumber);
>          } catch (InterruptedException e) {
>              e.printStackTrace();
>          }
>          return "线程池" + Thread.currentThread().getName() + "paymentInfo_Timeout,id：" + id 
>              + "\t" + "O(n_n)O哈哈" + "耗时" + timeNumber + "秒钟";
>      }
>  }
>  ```
>
>#### 主启动类
>
>```java
>package com.mofany;
>
>import org.springframework.boot.SpringApplication;
>import org.springframework.boot.autoconfigure.SpringBootApplication;
>import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
>
>/**
> * @author MoFany-J
> * @date 2023/2/19
> * @description PaymentHystrixMain8001
> */
>@EnableEurekaClient // 服务提供者
>@SpringBootApplication
>public class PaymentHystrixMain8001 {
>    public static void main(String[] args) {
>        SpringApplication.run(PaymentHystrixMain8001.class, args);
>    }
>}
>```
>
>#### 使用`Apache Jmeter`工具进行请求压测服务提供者
>
>* 利用Apache Jmeter向`服务提供者的超时接口`一次性发送`20000`条请求
>  * 线程数：`200`
>  * 时间：`1s`
>  * 循环次数：`200`
>  * 发送HTTP请求的URL：`http://localhost:8001/payment/hystrix/timeout/1`
>* **压测正常接口`http://localhost:8001/payment/hystrix/ok/1`**
>  * ***此时连续访问`http://localhost:8001/payment/hystrix/ok/1`时发现秒级响应的正常接口现在也需要一定的等待响应时间才能成功响应。***
>  * ***上面还是服务提供者8001压测自己，加入此时外部的服务消费者也参与进来进行并发访问，此时消费者只能默默的等待；最终导致服务消费者80非常不满意，同时服务提供者8001也直接被耗死！***
>
>#### ***Hystrix即可用在服务消费者，又可用在服务提供者！但是一本情况下均用在服务消费者！***
>
>* 创建一个新的服务消费者
>
>  * `服务消费者`全局配置
>
>    ```java
>    server:
>      port: 80
>    eureka:
>      client:
>        register-with-eureka: false
>        service-url:
>          defaultZone: http://eureka7001.com:7001/eureka/
>    ```
>
>  * `服务消费者`业务逻辑
>
>    * Feign的业务接口
>
>      ```java
>      package com.mofany.service;
>      
>      import org.springframework.cloud.openfeign.FeignClient;
>      import org.springframework.stereotype.Component;
>      import org.springframework.web.bind.annotation.GetMapping;
>      import org.springframework.web.bind.annotation.PathVariable;
>      
>      /**
>       * @author MoFany-J
>       * @date 2023/2/21
>       * @description PaymentHystrixService
>       */
>      @Component
>      @FeignClient(value = "CLOUD-PROVIDER-HYSTRIX-PAYMENT") // 使用Feign
>      public interface PaymentHystrixService {
>          /**
>           * 正常的，无异常的
>           */
>          @GetMapping("/payment/hystrix/ok/{id}")
>          String paymentInfo_OK(@PathVariable("id") Integer id);
>      
>          /**
>           * 不正常的，有异常的
>           */
>          @GetMapping("/payment/hystrix/timeout/{id}")
>          String paymentInfo_TimeOut(@PathVariable("id") Integer id);
>      }
>      ```
>
>    * controller
>
>      ```java
>      package com.mofany.controller;
>      
>      import com.mofany.service.PaymentHystrixService;
>      import lombok.extern.slf4j.Slf4j;
>      import org.springframework.web.bind.annotation.GetMapping;
>      import org.springframework.web.bind.annotation.PathVariable;
>      import org.springframework.web.bind.annotation.RequestMapping;
>      import org.springframework.web.bind.annotation.RestController;
>      
>      import javax.annotation.Resource;
>      
>      /**
>       * @author MoFany-J
>       * @date 2023/2/21
>       * @description OrderHystrixController
>       */
>      @RestController
>      @Slf4j
>      @RequestMapping("consumer/payment")
>      public class OrderHystrixController {
>      
>          @Resource
>          private PaymentHystrixService paymentHystrixService;
>      
>          /**
>           * 正常的，无异常的
>           */
>          @GetMapping("hystrix/ok/{id}")
>          String paymentInfo_OK(@PathVariable("id") Integer id) {
>              return paymentHystrixService.paymentInfo_OK(id);
>          }
>      
>          /**
>           * 不正常的，有异常的
>           */
>          @GetMapping("hystrix/timeout/{id}")
>          String paymentInfo_TimeOut(@PathVariable("id") Integer id) {
>              return paymentHystrixService.paymentInfo_TimeOut(id);
>          }
>      }
>      ```
>
>  * `服务消费者`主启动类
>
>    ```java
>    package com.mofany;
>    
>    import org.springframework.boot.SpringApplication;
>    import org.springframework.boot.autoconfigure.SpringBootApplication;
>    import org.springframework.cloud.openfeign.EnableFeignClients;
>    
>    /**
>     * @author MoFany-J
>     * @date 2023/2/21
>     * @description OrderHystrixMain80
>     */
>    @SpringBootApplication
>    @EnableFeignClients // 激活Feign
>    public class OrderHystrixMain80 {
>        public static void main(String[] args) {
>            SpringApplication.run(OrderHystrixMain80.class);
>        }
>    }
>    ```
>
>    #### 压测
>
>    1. 先并发访问`20000次`请求：`http://localhost:8001/payment/hystrix/timeout/1`
>
>    2. 接着去并发访问：`http://localhost:8001/payment/hystrix/ok/1`**出现服务提供者接口访问过慢的现象**
>    3. 然后正常访问服务消费者
>       * `http://localhost/consumer/payment/hystrix/ok/1`**出现服务消费者接口访问等待，访问延时过大**
>       * **此时我们要做的就是服务限流！！！**
>
>    #### 故某服务上某接口访问过慢时，应该怎么优化？？？
>
>    * `fallback`服务降级`什么情况需要服务降级`
>
>      * 对方服务器超时，调用者不能一直卡死等待，此时必须有服务降级
>
>      * 对方服务宕机时，调用者不能一直卡死等待，此时必须有服务降级
>
>      * 对方服务Ok，而调用者自己故障（自己的等待时间小于服务提供者）
>
>      * ##### 服务降级核心注解`@HystrixCommand`该注解标识的方法抛出错误信息、异常或超时等待后，其会自动调用`@HystrixCommand 对应方法独享`中指定好的`fallbackMethod`，即用于服务降级的方法；当前SpringBoot微服务模块的主配置类，即主启动类上还要加上`@EnableCircuitBreaker注解`。
>
>      * ##### 全局通用服务降级注解：`@DefaultProperties(defaultFallback="全局通用服务降级方法名")`
>
>      * ##### 服务消费者进行统一降级
>
>        ```java
>        @FeignClient(value = "CLOUD-PROVIDER-HYSTRIX-PAYMENT",
>                     fallback = PaymentFallbackService.class) // 标识Hystrix的统一接口
>        ```
>
>    * 解决思路：先从自身找问题；设置自身调用超时时间的峰值，峰值内可以正常运行，而超过峰值就需要有兜底的方法进行处理，作服务降级fallback 
>
>      * 服务提供者进行服务降级
>
>          ```java
>          package com.mofany.service;
>          
>          import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
>          import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;
>          import org.springframework.stereotype.Service;
>          
>          import java.util.concurrent.TimeUnit;
>          
>          /**
>           * @author MoFany-J
>           * @date 2023/2/19
>           * @description PaymentService
>           */
>          @Service
>          public class PaymentService {
>              /**
>               * 正常访问一定OK的方法
>               */
>              public String paymentInfo_OK(Integer id) {
>                  return "线程池" + Thread.currentThread().getName() 
>                      + "paymentInfo_OK,id：" + id + "\t" + "正常访问！";
>              }
>          ```
>
>        ```java
>        /**
>         * 超时报错的方法
>         * @HystrixCommand注解中指定了当前方法异常时的备用方法，同时还指定了正常响应的时间
>         * 3秒内走正常业务逻辑，超过3秒中则出错
>         */
>        @HystrixCommand(fallbackMethod = "paymentInfo_TimeOutHandler",
>                            commandProperties = {
>            @HystrixProperty(
>                /**
>                * 超过指定时间就进行服务降级
>                */
>                name = "execution.isolation.thread.timeoutInMilliseconds",
>                value = "3000")
>            })
>            public String paymentInfo_TimeOut(Integer id) {
>                /**
>                 * 超过3秒为异常
>                 * */
>                int timeNumber = 5;
>                try {
>                    TimeUnit.SECONDS.sleep(timeNumber);
>                } catch (InterruptedException e) {
>                    e.printStackTrace();
>                }
>                return "线程池" + Thread.currentThread().getName() 
>                    + "paymentInfo_Timeout,id：" + id + "\t" + "耗时访问！" + "耗时" 
>                    + timeNumber + "秒钟";
>            }
>            /**
>             * 服务降级对应的处理方法
>             */
>            public String paymentInfo_TimeOutHandler(Integer id) {
>                return "线程池" + Thread.currentThread().getName() 
>                    + "paymentInfo_TimeoutHandler,id：" + id + "\t" + "发生了服务降级！";
>            }
>        }
>        ```
>
>          * 访问测试：`http://localhost:8001/payment/hystrix/timeout/1`
>    
>            ```properties
>            线程池HystrixTimer-1paymentInfo_TimeoutHandler,id：1 发生了服务降级！
>            ```
>    
>          * ##### 服务消费者进行服务降级
>    
>            * 全局配置
>    
>              ```yaml
>              feign:
>                circuitbreaker:
>                  enabled: true
>              ```
>    
>            * ##### 主启动上加入`@EnableHystrix`
>
>      * 服务熔断
>
>        * 熔断机制是应对雪崩效应的一种微服务链路保护机制，当扇出链路的某个微服务出错不可用或响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。
>
>        * 当检测到该节点微服务调用响应正常后，恢复调用链路。
>
>        * SpringCloud框架中，熔断机制依然采用Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到达一定阈值时，缺省是5秒内20次调用失败，就会启用熔断机制，熔断机制的注解是`@HystrixCommand`。
>
>          ```java
>          /**
>           * 服务熔断
>           */
>          @HystrixCommand(fallbackMethod = "paymentCircuitBreaker_fallback", 
>                          commandProperties = {
>              // 是否开启短路器
>                  @HystrixProperty(name = "circuitBreaker.enabled", 
>                                   value = "true"), 
>              // 请求次数（快照时间窗口，默认10秒）
>                  @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold", 
>                                   value = "10"), 
>              // 时间窗口期（请求总数阈值）
>                  @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds", 
>                                   value = "10000"),
>              // 失败率达到多少后跳闸（错误百分比阈值，达到60%时，就会打开）
>                  @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage", 
>                                   value = "60"), 
>          })
>          ```
>
>          #### 服务降级 ——> 服务熔断 ——> `自动恢复调用链路`
>
>          * 服务降级与服务熔断配合使用，但又彼此不同。
>
>      * 服务限流
>
>### 服务降级，服务熔断`@HystrixProperty注解`详解
>
>```java
>/**
> * 服务熔断
> */
>@HystrixCommand(
>        fallbackMethod = "paymentCircuitBreaker_fallback",
>        groupKey = "strGroupCommand",
>        threadPoolKey = "strThreadPool",
>        commandProperties = {
>                // 设置隔离策略，Thread表示线程池SEMAPHORE：信号池隔离
>                @HystrixProperty(name = "execution.isolation.strategy", value = "THREAD"),
>                // 当隔离策略选择信号池隔离策略时，用来设置信号池的大小（最大并发数）
>                @HystrixProperty(name = "execution.isolation.semaphore.maxConcurrentRequests", 
>                                 value = "10"),
>                // 配值命令执行的超时时间
>                @HystrixProperty(name = "execution.isolation.thread.timeoutinMilliseconds", 
>                                 value = "10"),
>                // 是否启用超时时间
>                @HystrixProperty(name = "execution.timeout.enable", value = "true"),
>                // 执行超时的时候是否中断
>                @HystrixProperty(name = "execution.isolation.thread.interruptOnTimeout", 
>                                 value = "true"),
>                // 执行被取消的时候是否中断
>                @HystrixProperty(name = "execution.isolation.thread.interruptOnCancel", 
>                                 value = "true"),
>                // 允许回调方法执行的最大并发数
>                @HystrixProperty(name = "fallback.isolation.semaphore.maxConcurrentRequests", 
>                                 value = "10"),
>                // 服务降级是否启用
>                @HystrixProperty(name = "fallback.enabled", value = "true"),
>                // 是否启用断路器
>                @HystrixProperty(name = "circuitBreaker.enabled", value = "true"),
>                // 请求次数，在滚动时间窗（默认10秒）内收到9个请求，即使这9个请求都失败了断路器也不会打开
>                @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold", value = "10"),
>                // 该属性用来设置在滚动时间窗内，请求数量超过：
>            	// circuitBreaker.requestVolumeThreshold的情况下，如果错误请求数的百分比超过50，
>                // 就将断路器设置为“打开”状态，否则就设置为"关闭"状态, 失败率达到多少后跳闸
>                @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage", value = "50"),
>                // 时间窗口期，该属性用来设置当断路器打开之后的休眠时间窗，
>            	// 休眠时间窗结束后，会将断路器设置为"半开"状态，尝试熔断的请求命令，如果依然失败
>                // 就将断路器继续设置为“打开状态”
>                @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds",
>                                 value = "10000"),
>                // 断路器强制打开
>                @HystrixProperty(name = "circuitBreaker.forceOpen", value = "false"),
>                // 断路器强制关闭
>                @HystrixProperty(name = "circuitBreaker.forceClosed", value = "false"),
>                // 设置滚动时间窗，该时间用于断路器判断将抗度时需要收集信息的持续时间
>                @HystrixProperty(name = "metrics.rollingStats.timeinMilliseconds", value = "1000"),
>                // 该属性用来设置滚动时间窗统计指标信息时划分“桶”的数量，断路器在收集指标信息时会根据设置的时间窗
>            	// 长度拆分成多个“桶”来累计各度量值，每个桶记录了一段时间内的采集指标，
>            	// 如10秒内拆分成10个“桶”收集这样，所以timeinMilliseconds必须能被numBuckets整除，否则抛异常
>                @HystrixProperty(name = "metrics.rollingStats.numBuckets", value = "10"),
>                // 该属性用来设置对命令执行的延迟是否使用百分位数来跟踪和计算，如果设置为false，
>            	// 那么所有的概要统计都将返回-1
>                @HystrixProperty(name = "metrics.rollingPercentile.enabled", value = "false"),
>                // 该属性用来设置百分位统的滚动窗口的持续时间，单位毫秒
>                @HystrixProperty(name = "metrics.rollingPercentile.timeInMilliseconds", 
>                                 value = "6000"),
>                // 该属性用来设置百分位统计滚动窗口中使用“桶”的数量
>                @HystrixProperty(name = "metrics.rollingPercentile.numBuckets", value = "6000"),
>                // 该属性用来设置在执行过程中每个桶中保留的最大执行次数，
>            	// 如果在滚动时间窗内发生超过该设定值的执行次数，就会从最初的位置开始重写，例如将该值设置位100，
>            	// 滚动窗口位10秒，若在10秒内一个桶中发生了500次执行，那么该桶中只保留最后的100次执行的统计，
>            	// 另外，增加该值的大小将会增加内存量的消耗，并增加排序百分位数所需的计算时间
>                @HystrixProperty(name = "metrics.rollingPercentile.BucketSize", value = "100"),
>                // 该属性用来设置采集影响断路器状态的健康快照（请求的成功、错误百分比）的间隔等待时间
>                @HystrixProperty(name = "metrics.healthSnapshot.intervalinMilliseconds", 
>                                 value = "500"),
>                // 是否开启请求缓存
>                @HystrixProperty(name = "requestCache", value = "true"),
>                // HystrixCommand的指定和事件是否打印日志到HystrixRequestLog中
>                @HystrixProperty(name = "requestLog.enabled", value = "true")
>        },
>        threadPoolProperties = {
>                @HystrixProperty(name = "coreSize", value = "10"),
>                @HystrixProperty(name = "maxQueueSize", value = "-1"),
>                @HystrixProperty(name = "queueSizeRejectionThreshold", value = "5"),
>        }
>
>)
>```
>
>#### 服务监控`Hystrix-Dashboard`
>
>* 依赖
>
>  * 主启动类中启动Dashboard`@EnableHystrixDashboard`
>
>  ```xml
>  <!--     hystrix-dashboard监控仪表盘   -->
>  <dependency>
>      <groupId>org.springframework.cloud</groupId>
>      <artifactId>spring-cloud-netflix-hystrix-dashboard</artifactId>
>      <version>2.2.10.RELEASE</version>
>  </dependency>
>  ```
>
>* 被监控的服务的核心配置类，即主启动类中加入
>
>  ```java
>  /**
>   * 此配置是为了服务监控而配置，与服务容错本省无关，springcloud升级后的坑
>   * ServletRegistrationBean因为springboot的默认路径不是/hystrix.stream
>   * 只要在自己项目的核心配置类，即主启动类中配置上下面的servlet就可以了
>   */
>  @Bean
>  public ServletRegistrationBean getServlet() {
>      HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();
>      ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);
>      registrationBean.setLoadOnStartup(1);
>      registrationBean.addUrlMappings("/hystrix.stream");
>      registrationBean.setName("HystrixMetricsStreamServlet");
>      return registrationBean;
>  }
>  ```
>

## 服务降级`resilience4j`:ballot_box_with_check:

>
>
>

## 服务降级`sentinel`:ballot_box_with_check:

>
>
>

## 服务网关`Zuul`:x:

>
>
>

## 服务网关`Zuul2`:radioactive:

>
>
>

## 服务网关`gateway`:ballot_box_with_check:

>
>
>

## 服务配置`Config`:x:

>
>
>

## 服务配置`Nacos`:ballot_box_with_check:

>
>
>

## 服务总线`Bus`:x:

>
>
>

## 服务总线`Nacos`:ballot_box_with_check:

>
>
>