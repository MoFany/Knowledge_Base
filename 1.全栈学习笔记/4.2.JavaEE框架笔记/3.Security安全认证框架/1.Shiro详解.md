# Apache Shiro



## `Apache Shiro简介`

>### `Shiro`是一个java的安全框架
>
>* **其适用于`java SE`与`java EE`**
>* **其特点是小而简功能全且实用**
>* **简单安全业务推荐使用`Apache Shiro`（复杂安全业务则推荐使用`Spring Security`）**
>
>### `Shiro`主要的功能模块
>
>- **认证（验证用户名与密码）**`Authentication`
>- **授权（根据用户所属角色分发权限）**`Authorization`
>- **密码管理与加密**`Crytography`
>- **会话管理**`Session Management`
>- :boxing_glove:**Web整合**`Web Intergration`
>- **其它**`Intergrations`

## `Shiro `核心API

>### `Subject`主题
>
>* 代表了当前 “用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者；
>* **应用代码直接交互的对象是 Subject，也就是说 Shiro 的对外 API 核心就是 Subject；**
>
>### `SecurityManager`安全管理器
>
>* **即所有与安全有关的操作都会与`SecurityManager`交互；且它管理着所有`Subject`；可以看出它是 `Shiro`的核心，它负责与后边介绍的其他组件进行交互，其相当于`SpringMVC`中的`DispatcherServlet`前端控制器。**
>
>### **`Realm`域**
>
>* Shiro 从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色 / 权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。
>
>#### 也就是说对于我们而言，最简单的一个 Shiro 应用：
>
>1. **应用代码通过 Subject 来进行认证和授权，而 Subject 又委托给 SecurityManager。**
>2. **我们需要给 Shiro 的 SecurityManager 注入 Realm，从而让 SecurityManager 能得到合法的用户及其权限进行判断。**
>
>#### ***Shiro 不提供维护用户 / 权限，而是通过 Realm 让开发人员自己注入。***

## `Shiro`其它API

>### Authenticator 认证器
>
>* 负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了；
>
>### Authorizer 授权器
>
>* 或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；
>
>### SessionManager 会话管理器
>
>* 如果写过 Servlet 就应该知道 Session 的概念，Session 呢需要有人去管理它的生命周期，这个组件就是 SessionManager；而 Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境、EJB 等环境；所以呢，Shiro 就抽象了一个自己的 Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台 Web 服务器；接着又上了台 EJB 服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器）；
>
>### SessionDAO 会话数据访问对象
>
>* DAO 大家都用过，数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如 JDBC 写到数据库；比如想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能；
>
>### CacheManager 缓存控制器
>
>* 来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能
>
>### Cryptography 密码模块
>
>* Shiro 提供了一些常见的加密组件用于如密码加密 / 解密的。

# `Shiro`的`Core`



## :boxing_glove:Shiro配置与基本使用

>#### 官方`pom.xml`
>
>```xml
><?xml version="1.0" encoding="UTF-8"?>
>    <project xmlns="http://maven.apache.org/POM/4.0.0"
>        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
>         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
>
>    <modelVersion>4.0.0</modelVersion>
>    <groupId>org.apache.shiro.tutorials</groupId>
>    <artifactId>shiro-tutorial</artifactId>
>    <version>1.0.0-SNAPSHOT</version>
>    <name>First Apache Shiro Application</name>
>    <packaging>jar</packaging>
>
>    <properties>
>        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
>    </properties>
>
>    <build>
>        <plugins>
>            <plugin>
>                <groupId>org.apache.maven.plugins</groupId>
>                <artifactId>maven-compiler-plugin</artifactId>
>                <version>3.8.0</version>
>                <configuration>
>                    <source>1.8</source>
>                    <target>1.8</target>
>                </configuration>
>            </plugin>
>
>        <!-- This plugin is only to test run our little application.  It is not
>             needed in most Shiro-enabled applications: -->
>            <plugin>
>                <groupId>org.codehaus.mojo</groupId>
>                <artifactId>exec-maven-plugin</artifactId>
>                <version>1.1</version>
>                <executions>
>                    <execution>
>                        <goals>
>                            <goal>java</goal>
>                        </goals>
>                    </execution>
>                </executions>
>                <configuration>
>                    <classpathScope>test</classpathScope>
>                    <mainClass>Tutorial</mainClass>
>                </configuration>
>            </plugin>
>        </plugins>
>    </build>
>
>		<!--shiro依赖-->        
>    <dependencies>
>        <dependency>
>            <groupId>org.apache.shiro</groupId>
>            <artifactId>shiro-core</artifactId>
>            <version>1.10.1</version>
>        </dependency>
>        <!-- Shiro uses SLF4J for logging.  We'll use the 'simple' binding
>             in this example app.  See http://www.slf4j.org for more info. -->
>        <!--日志包-->
>        <dependency>
>            <groupId>org.slf4j</groupId>
>            <artifactId>slf4j-simple</artifactId>
>            <version>1.7.21</version>
>            <scope>test</scope>
>        </dependency>
>        <dependency>
>            <groupId>org.slf4j</groupId>
>            <artifactId>jcl-over-slf4j</artifactId>
>            <version>1.7.21</version>
>            <scope>test</scope>
>        </dependency>
>    </dependencies>
>
></project>
>```
>
>#### 官方`shiro.ini`配置文件
>
>* **shiro.ini**
>
>  ```ini
>  # =============================================================================
>  # Tutorial INI configuration
>  #
>  # Usernames/passwords are based on the classic Mel Brooks' film "Spaceballs" :)
>  # =============================================================================
>  
>  # -----------------------------------------------------------------------------
>  # Users and their (optional) assigned roles
>  # username = password, role1, role2, ..., roleN
>  # -----------------------------------------------------------------------------
>  [users]
>  root = secret, admin
>  guest = guest, guest
>  presidentskroob = 12345, president
>  darkhelmet = ludicrousspeed, darklord, schwartz
>  lonestarr = vespa, goodguy, schwartz
>  
>  # -----------------------------------------------------------------------------
>  # Roles with assigned permissions
>  # roleName = perm1, perm2, ..., permN
>  # -----------------------------------------------------------------------------
>  [roles]
>  admin = *
>  schwartz = lightsaber:*
>  goodguy = winnebago:drive:eagle5
>  ```
>
>  ##### `shiro.ini`文件配置详情
>
>  ```ini
>  [main]
>  #提供了对根对象securityManager及其依赖的配置
>  securityManager=org.apache.shiro.mgt.DefaultSecurityManager
>  # 该值是一个列表，多个realms之间使用逗号进行分隔
>  securityManager.realms=$jdbcRealm
>  
>  [users]
>  #提供了对用户/密码及其角色的配置，用户名=密码，角色1，角色2
>  username=password,role1,role2
>  
>  [roles]
>  #提供了角色及权限之间关系的配置，角色=权限1，权限2，其中*代表所有角色
>  role1=permission1,permission2
>  
>  [urls]
>  #用于web，提供了对web url拦截相关的配置，url=拦截器[参数]，拦截器
>  #index.html资源无需认证即可访问
>  /index.html = anon
>  #admin下的所有资源必须先认证且属于角色admin并拥有permission1的权限才能访问
>  /admin/** = authc, roles[admin], perms["permission1"]
>  ```
>
>  * 关于`shiro.ini`中`main`的配置：
>    * 变量名 = 全限定类名会自动创建一个类实例
>    * 变量名. 属性 = 值 自动调用相应的 `setter` 方法进行赋值
>    * $ 变量名 引用之前的一个对象实例
>
>#### 官方提供的登录失败时要捕获的异常
>
>```java
>try {
>    currentUser.login( token );
>    //if no exception, that's it, we're done!
>} catch ( UnknownAccountException uae ) {
>    //username wasn't in the system, show them an error message?
>} catch ( IncorrectCredentialsException ice ) {
>    //password didn't match, try again?
>} catch ( LockedAccountException lae ) {
>    //account for that username is locked - can't login.  Show them a message?
>}
>    
>//... more types exceptions to check if you want ...
>
>} catch ( AuthenticationException ae ) {
>    //unexpected condition - error?
>}
>```
>
>#### Shiro的`Remember Me`功能
>
>* ##### Remembered
>
>  * `Subject`不是匿名的，并且具有已知的身份（即`subject.` [getPrincipals()](http://shiro.apache.org/static/current/apidocs/org/apache/shiro/subject/Subject.html#getPrincipals--)是非空的）。但是在“先前”会话期间，通过先前的身份验证会记住此身份。如果`subject.` [isRemembered()](http://shiro.apache.org/static/current/apidocs/org/apache/shiro/subject/Subject.html#isRemembered--)返回`true`，则认为该主题已被记住。
>
>* ##### Authenticated
>
>  * 已认证的`Subject`是已经成功认证的对象(即`login`方法被调用而没有引发异常)*在主体当前会话期间*。如果`subject.` [isAuthenticated()](http://shiro.apache.org/static/current/apidocs/org/apache/shiro/subject/Subject.html#isAuthenticated--)返回`true`，则认为该主题已认证。
>
>  ###### *记住和已认证状态是互斥的-一个的`true`值表示另一个的`false`值，反之亦然。*
>
>#### 引用配置文件`javaSE`程序
>
>* **My First Apache Shiro Application**
>
>  ```java
>  package com.mofany.shiro;
>  
>  import org.apache.shiro.SecurityUtils;
>  import org.apache.shiro.config.IniSecurityManagerFactory;
>  import org.apache.shiro.mgt.SecurityManager;
>  import org.apache.shiro.util.Factory;
>  
>  /**
>   * @author MoFany-J
>   * @date 2022/11/25
>   * @description ShiroDemo shiro初体验
>   */
>  public class ShiroDemo {
>      public static void main(String[] args) {
>  
>          //log.info("My First Apache Shiro Application");
>  
>          //1.初始化安全管理器工厂
>          Factory<SecurityManager> factory=new IniSecurityManagerFactory("classpath:shiro.ini");
>  
>          //2.创建安全管理器实例
>          SecurityManager securityManager=factory.getInstance();
>  
>          //3.指定安全管理器
>          SecurityUtils.setSecurityManager(securityManager);
>  
>          //System.exit(0);
>      }
>  }
>  ```
>
>#### 授权
>
>* 授权的三要素：`权限`、`角色`、`用户`

## :boxing_glove:Shiro常用方法

>#### 面向角色的`Subject`方法
>
>| 方法名                                    | 描述                                                         |
>| ----------------------------------------- | ------------------------------------------------------------ |
>| hasRole(roleName)                         | 如果为Subject分配了指定角色，则返回true                      |
>| hasRoles(List<String> roleNames)          | 返回与方法参数中的索引相对应的hasRole个结果的数组。如果需要执行许多角色检查，可作为性能增强的有用工具 |
>| hasAllRoles(Collection<String> roleNames) | 如果为Subject分配了所有指定角色，则返回true                  |
>
>#### 面向角色的`Subject`assert 方法
>
>| 方法名                           | 描述                                                         |
>| -------------------------------- | ------------------------------------------------------------ |
>| checkRole(String roleName)       | 如果为`Subject`分配了指定的角色，则静默返回；否则，则返回`AuthorizationException`。 |
>| checkRoles(Collection roleNames) | 如果`Subject`被分配了指定的全部角色，则静默返回；否则，则返回`AuthorizationException`。 |
>| checkRoles(String... roleNames)  | 与`checkRoles`方法效果相同，但允许使用 Java 5 var-args 样式参数。 |
>
>#### 基于`对象`的权限检查
>
>| 方法名                           | 描述                                                         |
>| -------------------------------- | ------------------------------------------------------------ |
>| isPermitted(Permission p)        | 如果`Subject`被允许执行操作或访问由指定`Permission`实例汇总的资源，则返回`true`，否则返回_4. |
>| isPermitted(List perms)          | 返回与方法参数中的索引相对应的`isPermitted`个结果的数组。如果需要执行许多权限检查(例如，自定义复杂视图时)，可以用作性能增强 |
>| isPermittedAll(Collection perms) | 如果`Subject`被允许所有指定的权限，则返回`true`，否则返回`false`。 |
>
>#### 基于`字符串`的权限检查
>
>| 方法名                          | 描述                                                         |
>| ------------------------------- | ------------------------------------------------------------ |
>| isPermitted(String perm)        | 如果`Subject`被允许执行操作或访问由指定的`String`权限汇总的资源，则返回`true`，否则返回_4. |
>| isPermitted(String... perms)    | 返回与方法参数中的索引相对应的`isPermitted`个结果的数组。如果需要执行许多`String`权限检查(例如，自定义复杂视图时)，则可作为性能增强的工具 |
>| isPermittedAll(String... perms) | 如果指定的`String`许可*全部*允许`Subject`，则返回`true`，否则返回`false`。 |
>
>#### 面向权限的`Subject`assert 方法
>
>| 方法名                             | 描述                                                         |
>| ---------------------------------- | ------------------------------------------------------------ |
>| checkPermission(Permission p)      | 如果允许`Subject`执行操作或访问由指定`Permission`实例汇总的资源，则静默返回，否则返回`AuthorizationException`。 |
>| checkPermission(String perm)       | 如果允许`Subject`执行操作或访问由指定的`String`权限汇总的资源，则安静地返回，否则返回`AuthorizationException`。 |
>| checkPermissions(Collection perms) | 如果允许`Subject` *全部*指定的权限，则安静地返回；否则，则返回`AuthorizationException`。 |
>| checkPermissions(String... perms)  | 与上面的`checkPermissions`方法相同，但使用的是基于`String`的权限。 |
>
>

## :boxing_glove:Shiro常用注解

> | 注解名                  | 描述                                                         |
> | ----------------------- | ------------------------------------------------------------ |
> | @RequiresAuthentication | [@RequiresAuthentication](http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authz/annotation/RequiresAuthentication.html)注解要求当前的`Subject`在其当前会话期间已经过身份验证，以便可以访问或调用带 Comments 的类/实例/方法 |
> | @RequiresGuest          | [@RequiresGuest](http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authz/annotation/RequiresGuest.html)注解要求当前的 Subject 是“来宾”，也就是说，对于要访问或调用的带 Comments 的类/实例/方法，它们在上一会话中没有经过身份验证或记住。 |
> | @RequiresPermissions    | [@RequiresPermissions](http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authz/annotation/RequiresPermissions.html)注解要求当前的主题被授予一个或多个权限，以便执行带注解的方法。 |
> | @RequiresRoles          | [@RequiresRoles](http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authz/annotation/RequiresRoles.html)Comments 要求当前的 Subject 具有所有指定的角色。如果他们没有角色，则该方法将不会执行，并且会抛出 AuthorizationException。 |
> | @RequiresUser           | [@RequiresUser](http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authz/annotation/RequiresUser.html) Comments 要求当前的 Subject 为要访问或调用的带 Comments 的类/实例/方法的应用程序用户。 “应用程序用户”定义为具有已知身份的`Subject`，该身份由于在当前会话期间进行了身份验证而已知，或者从上一会话的“ RememberMe”服务中被记住。 |
>
> #### 注解使用示例
>
> * ##### @RequiresAuthentication
>
>   * 使用示例
>
>     ```java
>     @RequiresAuthentication
>     public void updateAccount(Account userAccount) {
>         // 这个方法只被保证经过验证的Subject所调用
>         ...
>     }
>     ```
>
>   * 等价于以下基于`Subject`的逻辑
>
>     ```java
>     public void updateAccount(Account userAccount) {
>         if (!SecurityUtils.getSubject().isAuthenticated()) {
>             throw new AuthorizationException(...);
>         }
>     
>         // Subject在这里保证得到认证
>         ...
>     }
>     ```
>
> * ##### @RequiresGuest
>
>   * 使用示例
>
>     ```java
>     @RequiresGuest
>     public void signUp(User newUser) {
>         //这个方法只被一个未知/匿名的Subject所调用
>         ...
>     }
>     ```
>
>   * 等价于以下基于`Subject`的逻辑
>
>     ```java
>     public void signUp(User newUser) {
>         Subject currentUser = SecurityUtils.getSubject();
>         PrincipalCollection principals = currentUser.getPrincipals();
>         if (principals != null && !principals.isEmpty()) {
>             //已知身份--不是 guest
>             throw new AuthorizationException(...);
>         }
>     
>         //Subject 保证是这里的 guest
>         ...
>     }
>     ```
>
> * ##### @RequiresPermissions
>
>   * 使用示例
>
>     ```java
>     @RequiresPermissions("account:create")
>     public void createAccount(Account account) {
>         //该方法仅由允许创建账户的Subject调用
>         ...
>     }
>     ```
>
>   * 等价于以下基于`Subject`的逻辑
>
>     ```java
>     public void createAccount(Account account) {
>         Subject currentUser = SecurityUtils.getSubject();
>         if (!subject.isPermitted("account:create")) {
>             throw new AuthorizationException(...);
>         }
>     
>         // Subject在这里保证是被允许的
>         ...
>     }
>     ```
>
> * ##### @RequiresRoles
>
>   * 使用示例
>
>     ```java
>     @RequiresRoles("administrator")
>     public void deleteUser(User user) {
>         // 这个方法只被管理员调用
>         ...
>     }
>     ```
>
>   * 等价于以下基于`Subject`的逻辑
>
>     ```java
>     public void deleteUser(User user) {
>         Subject currentUser = SecurityUtils.getSubject();
>         if (!subject.hasRole("administrator")) {
>             throw new AuthorizationException(...);
>         }
>     
>         // Subject保证是这里的 "管理员"
>         ...
>     }
>     ```
>
> * ##### @RequiresUser
>
>   * 使用示例
>
>     ```java
>     @RequiresUser
>     public void updateAccount(Account account) {
>         // 这个方法将只被 user 调用，即一个有已知身份的 Subject
>         ...
>     }
>     ```
>
>   * 等价于以下基于`Subject`的逻辑
>
>     ```java
>     public void updateAccount(Account account) {
>         Subject currentUser = SecurityUtils.getSubject();
>         PrincipalCollection principals = currentUser.getPrincipals();
>         if (principals == null || principals.isEmpty()) {
>             // 没有身份 - 他们是匿名的，不允许
>             throw new AuthorizationException(...);
>         }
>     
>         // Subject保证有一个已知的身份
>         ...
>     }
>     ```
>
>
>

## :boxing_glove:配置全局权限解析器`PermissionResolver`

>#### Shiro.ini
>
>```ini
>globalPermissionResolver = com.foo.bar.authz.MyPermissionResolver
>...
>securityManager.authorizer.permissionResolver = $globalPermissionResolver
>...
>```
>
>* 如果要配置全局`PermissionResolver`，则每个`Realm`都必须接收已配置的`PermissionResolver` **必须实现PermisionResolverAware接口。**这保证了可以将配置的实例中继到每个支持这种配置的`Realm`。
>
>* 如果您不想使用全局`PermissionResolver`或不想被`PermissionResolverAware`接口打扰，则始终可以使用`PermissionResolver`实例显式配置领域(假定存在与 JavaBeans 兼容的 setPermissionResolver 方法)：
>
>```ini
>permissionResolver = com.foo.bar.authz.MyPermissionResolver
>
>realm = com.foo.bar.realm.MyCustomRealm
>realm.permissionResolver = $permissionResolver
>...
>```

## :boxing_glove:配置全局角色权限解析器`RolePermissionResolver`

>#### Shiro.ini
>
>```ini
>globalRolePermissionResolver = com.foo.bar.authz.MyPermissionResolver
>...
>securityManager.authorizer.rolePermissionResolver = $globalRolePermissionResolver
>...
>
>```
>
>* 如果要配置全局`RolePermissionResolver`，则每个`Realm`都必须接收已配置的`RolePermissionResolver` **必须实现`RolePermisionResolverAware`接口。**这样可以确保已配置的全局`RolePermissionResolver`实例可以中继到每个支持这种配置的`Realm`。
>
>* 如果您不想使用全局`RolePermissionResolver`或不想被`RolePermissionResolverAware`接口打扰，则始终可以使用`RolePermissionResolver`实例显式配置一个领域(假定存在与 JavaBeans 兼容的 setRolePermissionResolver 方法)：
>
>```ini
>rolePermissionResolver = com.foo.bar.authz.MyRolePermissionResolver
>
>realm = com.foo.bar.realm.MyCustomRealm
>realm.rolePermissionResolver = $rolePermissionResolver
>...
>```

## :boxing_glove:认证`Authentication`

>#### 通过自定义Realm的方式自定义认证`继承AuthorizingRealm`
>
>```java
>/**
> * 自定义认证
> * */
>@Override
>protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
>    //参数类型转换为用户的token
>    UsernamePasswordToken userToken=(UsernamePasswordToken) token;
>    //获取用户名
>    String username=userToken.getUsername();
>    //返回查询指定用户名的用户是否存在
>    User user=userDao.queryByUserName(username);
>    //判断查询到的用户
>    if(user==null){
>        throw new UnknownAccountException("用户未注册");
>    }
>    System.out.println("数据库中查询到的用户信息为：\n"+user);
>    //获取数据库中查询到的用户密码
>    String password=user.getPassword();
>    System.out.println("数据库中查到的用户信息：\n"
>                       +"用户名："+user.getUser_name()
>                       +"\n用户密码："+user.getPassword());
>
>    /**
>     * 定义盐，即加密的佐料（该用户密码和账号进行再加密）
>     * */
>    System.out.println("*****************************************************");
>    ByteSource salt=ByteSource.Util.bytes(username);
>    System.out.println("加密的盐为："+salt);
>    //将加密密码写入数据库（加密的算法，初始时要加密的密码，参与本次加密的盐，要进行加密的次数）
>    SimpleHash simpleHash=new SimpleHash("SHA1","123456",salt,1024);
>    System.out.println("加密后的密文密码（写入数据库）为："+simpleHash);
>    System.out.println("*****************************************************");
>    if(userDao.executorEncryption(username,simpleHash.toString())){
>        System.out.println("加密密码已写入数据库！");
>    }
>
>    //返回一个简单的认证信息
>    return new SimpleAuthenticationInfo(username,password,salt,this.getName());
>}
>```
>
>

## :boxing_glove:授权`Authorization`

>#### 通过自定义Realm的方式自定义授权`继承AuthorizingRealm`
>
>```java
>/**
> * 自定义授权
> * */
>@Override
>protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
>    return null;
>}
>```
>
>#### 自定义授权程序
>
>* 如果您的应用程序使用多个领域来执行授权，并且`ModularRealmAuthorizer`的默认基于简单迭代的短路授权行为不符合您的需求，则您可能需要创建自定义`Authorizer`并相应地配置`SecurityManager`。
>
>  * Shiro.ini
>
>    ```ini
>    [main]
>    ...
>    authorizer = com.foo.bar.authz.CustomAuthorizer
>    
>    securityManager.authorizer = $authorizer 
>    ```

## :boxing_glove:Session managerment

>#### 获取当前Subject的Session
>
>```java
>// 先获取当前用户
>Subject currentUser = SecurityUtils.getSubject();
>
>// 然后获取当前用户的Session
>Session session = currentUser.getSession();
>// 给当前用户的Session设置一些属性值
>session.setAttribute( "someKey", someValue);
>```
>
>- 如果`Subject`已经具有`Session`，则布尔参数将被忽略并且`Session`立即返回
>- 如果`Subject`还没有`Session`并且`create`布尔参数为`true`，则将创建并返回一个新会话。
>- 如果`Subject`还没有`Session`并且`create`布尔参数为`false`，则不会创建新的会话，并返回`null`。
>
>#### 在Shiro中配置新的Session Management
>
>```ini
>[main]
>...
>sessionManager = com.foo.my.SessionManagerImplementation
>securityManager.sessionManager = $sessionManager
>```
>
>#### Session TimeOut
>
>* 默认情况下，Shiro 的`SessionManager`实现默认为 30 分钟的会话超时。也就是说，如果创建的任何`Session`保持空闲状态(未使用，其[lastAccessedTime](http://shiro.apache.org/static/current/apidocs/org/apache/shiro/session/Session.html#getLastAccessTime--)未被更新)超过 30 分钟或更长时间，则`Session`被视为已到期，将不再被使用。
>
>* 可以设置默认的`SessionManager`实现的`globalSessionTimeout`属性，以定义所有会话的默认超时值。例如，如果您希望超时是一个小时而不是 30 分钟：
>
>  * ###### shiro中设置默认Session超时时间
>
>    ```ini
>    [main]
>    ...
>    # 3,600,000 milliseconds = 1 hour
>    securityManager.sessionManager.globalSessionTimeout = 3600000
>    ```

## 我的第一个`Shiro`程序`javaSE`

>### 父模块的`pom.xml`中所需内容
>
>```xml
><!--  指定父项目的打包方式 -->
><packaging>pom</packaging>
>
><!-- 父项目中管理子项目的依赖 -->
><dependencyManagement>
>    <dependencies>
>        <dependency>
>            <groupId>junit</groupId>
>            <artifactId>junit</artifactId>
>            <version>4.13.2</version>
>            <scope>test</scope>
>        </dependency>
>        <!-- shiro的核心jar包 -->
>        <dependency>
>            <groupId>org.apache.shiro</groupId>
>            <artifactId>shiro-core</artifactId>
>            <version>1.9.1</version>
>        </dependency>
>        <!-- shiro-web的jar包，用于整合web -->
>        <dependency>
>            <groupId>org.apache.shiro</groupId>
>            <artifactId>shiro-web</artifactId>
>            <version>1.9.1</version>
>        </dependency>
>        <!-- mysql -->
>        <dependency>
>            <groupId>mysql</groupId>
>            <artifactId>mysql-connector-java</artifactId>
>            <version>8.0.30</version>
>        </dependency>
>        
>        <!-- 德鲁伊，创建数据库链接池 -->
>        <dependency>
>            <groupId>com.alibaba</groupId>
>            <artifactId>druid</artifactId>
>            <version>1.2.7</version>
>        </dependency>
>        
>        <!-- DBUtils数据库操作类，用于结果集的操作 -->
>        <dependency>
>            <groupId>commons-dbutils</groupId>
>            <artifactId>commons-dbutils</artifactId>
>            <version>1.7</version>
>        </dependency>
>        
>        <!-- lombok -->
>        <dependency>
>            <groupId>org.projectlombok</groupId>
>            <artifactId>lombok</artifactId>
>            <version>1.18.24</version>
>        </dependency>
>        
>        <!-- 处理json数据 -->
>        <dependency>
>            <groupId>com.alibaba.fastjson2</groupId>
>            <artifactId>fastjson2</artifactId>
>            <version>2.0.13</version>
>        </dependency>
>        
>        <!-- 日志包 -->
>        <dependency>
>            <groupId>commons-logging</groupId>
>            <artifactId>commons-logging</artifactId>
>            <version>1.2</version>
>        </dependency>
>    </dependencies>
></dependencyManagement>
>```
>
>### 当前子模块的`popm.xml`
>
>```xml
><!-- 指定所属父模块 -->
><parent>
>    <artifactId>shiro-parentmodules</artifactId>
>    <groupId>com.mofany</groupId>
>    <version>1.0-SNAPSHOT</version>
></parent>
>
><!-- 子模块引用父模块的依赖 -->
><dependencies>
>	<!-- 子项目所需的shiro包 -->
>    <dependency>
>        <groupId>org.apache.shiro</groupId>
>        <artifactId>shiro-core</artifactId>
>    </dependency>
>	<!-- 子项目所需的日志包 -->
>    <dependency>
>        <groupId>commons-logging</groupId>
>        <artifactId>commons-logging</artifactId>
>    </dependency>
></dependencies>
>```
>
>### `shiro.ini`配置文件内容
>
>```ini
># =============================================================================
># Tutorial INI configuration
>#
># Usernames/passwords are based on the classic Mel Brooks' film "Spaceballs" :)
># =============================================================================
>
># -----------------------------------------------------------------------------
>#
># main()方法
># -----------------------------------------------------------------------------
>[main]
>
># -----------------------------------------------------------------------------
># Users and their (optional) assigned roles
># username = password, role1, role2, ..., roleN
># 配置用户信息：用户名=密码
># -----------------------------------------------------------------------------
>[users]
>admin=123456
>
># -----------------------------------------------------------------------------
># Roles with assigned permissions
># roleName = perm1, perm2, ..., permN
># -----------------------------------------------------------------------------
>[roles]
>
>
># -----------------------------------------------------------------------------
>#
># url统一资源定位符
># -----------------------------------------------------------------------------
>[url]
>```
>
>### `main()`方法中引用配置文件代码
>
>```java
>package com.mofany.shiro;
>
>
>import org.apache.shiro.SecurityUtils;
>import org.apache.shiro.authc.*;
>import org.apache.shiro.config.IniSecurityManagerFactory;
>import org.apache.shiro.mgt.SecurityManager;
>import org.apache.shiro.subject.Subject;
>import org.apache.shiro.util.Factory;
>
>/**
> * @author MoFany-J
> * @date 2022/11/25
> * @description ShiroDemo shiro初体验
> */
>public class ShiroDemo {
>    public static void main(String[] args) {
>
>        //1.根据初始化的配置文件获取SecurityManager的工厂
>        Factory<SecurityManager> factory =
>                new IniSecurityManagerFactory("classpath:shiro.ini");
>
>        //2.根据工厂获取SecurityManager
>        SecurityManager securityManager = factory.getInstance();
>
>        //3.注册SecurityManager
>        SecurityUtils.setSecurityManager(securityManager);
>
>        //4.获取Subje
>        Subject subject = SecurityUtils.getSubject();
>
>        //5.准备要一个要验证的用户名和密码的token（token为密码的加密字符串表示）
>        //正确用户信息的验证测试
>        UsernamePasswordToken token = new UsernamePasswordToken("admin", "123456");
>        //错误用户信息的验证测试
>        //UsernamePasswordToken token = new UsernamePasswordToken("root", "123456");
>
>        //6.执行登录操作并捕获登录异常的情况
>        try {
>            subject.login(token);
>            System.out.println("登录成功！");
>        } catch (UnknownAccountException uae) {
>            //username wasn't in the system, show them an error message?
>            System.out.println("用户找不到！");
>        } catch (IncorrectCredentialsException ice) {
>            //password didn't match, try again?
>            System.out.println("密码错误！");
>        } catch (LockedAccountException lae) {
>            //account for that username is locked - can't login.  Show them a message?
>            System.out.println("账户被锁定！");
>        } catch (AuthenticationException ae) {
>            //unexpected condition - error?
>            System.out.println("登录失败：未知错误！");
>        }
>    }
>}
>```
>
>* **登录成功运行结果**
>
>  ```properties
>  #正确用户信息的验证测试
>  #UsernamePasswordToken token = new UsernamePasswordToken("admin", "123456");
>  
>  SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
>  SLF4J: Defaulting to no-operation (NOP) logger implementation
>  SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
>  登录成功！
>  
>  Process finished with exit code 0
>  ```
>
>* **登录成功运行结果**
>
>  ```properties
>  #错误用户信息的验证测试
>  #UsernamePasswordToken token = new UsernamePasswordToken("root", "123456");
>  
>  SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
>  SLF4J: Defaulting to no-operation (NOP) logger implementation
>  SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
>  用户找不到！
>  
>  Process finished with exit code 0
>  ```

# `Shiro`整合`Java Web`

## `Shiro`整合Web项目`官方`

>### `Shiro1.2及之后版本`配置`Web.xml`的方法:accept:
>
>```xml
><listener>
>    <listener-class>org.apache.shiro.web.env.EnvironmentLoaderListener</listener-class>
></listener>
>
>
><filter>
>    <filter-name>ShiroFilter</filter-name>
>    <filter-class>org.apache.shiro.web.servlet.ShiroFilter</filter-class>
></filter>
>
><filter-mapping>
>    <filter-name>ShiroFilter</filter-name>
>    <url-pattern>/*</url-pattern>
>    <dispatcher>REQUEST</dispatcher>
>    <dispatcher>FORWARD</dispatcher>
>    <dispatcher>INCLUDE</dispatcher>
>    <dispatcher>ERROR</dispatcher>
>    <dispatcher>ASYNC</dispatcher>
></filter-mapping>
>```
>
>#### `Shiro1.1及之前版本`配置`web.xml`的方法
>
>```xml
><?xml version="1.0" encoding="UTF-8"?>
><web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
>  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
>  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
>                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" 
>  version="4.0">
>    
>	<!-- 上下文参数 -->
>	<context-param>
>	    <!-- 参数名可改 -->
>	    <param-name>shiroConfigLocations</param-name>
>	    <!-- 参数值可改 -->   
>	    <param-value>classpath:shiro.ini</param-value>
>	</context-param>
>    
>    <!-- shiro的核心监听器 -->
>    <listener>
>    	<listener-class>org.apache.shiro.web.env.EnvironmentLoaderListener</listener-class>
>  	</listener>
>	
>    <!-- shiro的核心过滤器 -->
>	<filter>
>	    <filter-name>ShiroFilter</filter-name>
>	    <filter-class>org.apache.shiro.web.servlet.IniShiroFilter</filter-class>
>	</filter>
>	
>	<!-- Make sure any request you want accessible to Shiro is filtered. /* catches all -->
>	<!-- requests.  Usually this filter mapping is defined first (before all others) to -->
>	<!-- ensure that Shiro works in subsequent filters in the filter chain:             -->
>	
>    <!-- shiro核心过滤器的映射url地址 -->
>	<filter-mapping>
>	    <filter-name>ShiroFilter</filter-name>
>	    <url-pattern>/*</url-pattern>
>	    <dispatcher>REQUEST</dispatcher>
>	    <dispatcher>FORWARD</dispatcher>
>	    <dispatcher>INCLUDE</dispatcher>
>	    <dispatcher>ERROR</dispatcher>
>	</filter-mapping>
></web-app>
>```
>
>### `Shiro.ini`配置文件的创建方式（以首先找到的为准）
>
>* **默认情况下，此类将按顺序自动在以下两个位置查找`Shiro.ini`**
>
>  1. **`/WEB-INF/shiro.ini`**
>  2. **`classpath:shiro.ini`**
>
>* :accept:**若想将`Shiro.ini`放置在其它位置，则可以使用`context-param`在`web.xml`指定**
>
>  ```xml
>  <!-- 上下文参数 -->
>  <context-param>
>      
>      <!-- 参数名可改 -->
>      <param-name>shiroConfigLocations</param-name>
>   	
>      <!-- 参数值可改 -->   
>      <param-value>classpath:shiro.ini</param-value>
>      
>  </context-param>
>  ```
>
>  * **Shiro 的[ResourceUtils](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/io/ResourceUtils.html) 类支持的适当资源前缀来指定特定的文件系统、类路径或 URL 位置：**
>
>    1. **`file:/home/foobar/myapp/shiro.ini`**
>
>    2. **`classpath:com/foo/bar/shiro.ini`**
>
>    3. **`url:http://confighost.mycompany.com/myapp/shiro.ini`**
>
>### `Shiro.ini`中的内容组成
>
>```ini
># [main], [users] and [roles] above here
>...
>[urls]
>...
>```

## 我的第一个关于`shiro`的Web整合项目

>### 父模块的`pom.xml`文件
>
>```xml
><?xml version="1.0" encoding="UTF-8"?>
><project xmlns="http://maven.apache.org/POM/4.0.0"
>         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
>         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
>    <modelVersion>4.0.0</modelVersion>
>
>    <groupId>com.mofany</groupId>
>    <artifactId>shiro-parentmodules</artifactId>
>    <version>1.0-SNAPSHOT</version>
>    <modules>
>        <module>01-shiro-hello</module>
>        <module>02-shiro-web-hello</module>
>    </modules>
>
>    <properties>
>        <maven.compiler.source>11</maven.compiler.source>
>        <maven.compiler.target>11</maven.compiler.target>
>    </properties>
>    <!--    指定父项目的打包方式-->
>    <packaging>pom</packaging>
>    <!--    父项目中管理子项目的依赖-->
>    <dependencyManagement>
>        <dependencies>
><!--            单元测试包-->
>            <dependency>
>                <groupId>junit</groupId>
>                <artifactId>junit</artifactId>
>                <version>4.13.2</version>
>                <scope>test</scope>
>            </dependency>
>            <!--           shiro的核心jar包 -->
>            <dependency>
>                <groupId>org.apache.shiro</groupId>
>                <artifactId>shiro-core</artifactId>
>                <version>1.9.1</version>
>            </dependency>
>            <!--            shiro-web的jar包，用于整合web-->
>            <dependency>
>                <groupId>org.apache.shiro</groupId>
>                <artifactId>shiro-web</artifactId>
>                <version>1.9.1</version>
>            </dependency>
>            <!--            mysql-->
>            <dependency>
>                <groupId>mysql</groupId>
>                <artifactId>mysql-connector-java</artifactId>
>                <version>8.0.30</version>
>            </dependency>
>            <!--            德鲁伊，创建数据库链接池-->
>            <dependency>
>                <groupId>com.alibaba</groupId>
>                <artifactId>druid</artifactId>
>                <version>1.2.7</version>
>            </dependency>
>            <!--            DBUtils数据库操作类，用于结果集的操作-->
>            <dependency>
>                <groupId>commons-dbutils</groupId>
>                <artifactId>commons-dbutils</artifactId>
>                <version>1.7</version>
>            </dependency>
>            <!-- Servlet包 -->
>            <dependency>
>                <groupId>javax.servlet</groupId>
>                <artifactId>javax.servlet-api</artifactId>
>                <version>4.0.1</version>
>            </dependency>
><!--            jsp的标签库-->
>            <dependency>
>                <groupId>javax.servlet</groupId>
>                <artifactId>jstl</artifactId>
>                <version>1.2</version>
>            </dependency>
>            <!--            lombok-->
>            <dependency>
>                <groupId>org.projectlombok</groupId>
>                <artifactId>lombok</artifactId>
>                <version>1.18.24</version>
>            </dependency>
>            <!--            处理json数据-->
>            <dependency>
>                <groupId>com.alibaba.fastjson2</groupId>
>                <artifactId>fastjson2</artifactId>
>                <version>2.0.13</version>
>            </dependency>
>            <!-- logging日志包 -->
>            <dependency>
>                <groupId>commons-logging</groupId>
>                <artifactId>commons-logging</artifactId>
>                <version>1.2</version>
>            </dependency>
>            <!-- slf4j日志包 -->
>            <dependency>
>                <groupId>org.slf4j</groupId>
>                <artifactId>slf4j-api</artifactId>
>                <version>1.7.21</version>
>            </dependency>
>            <!-- logback日志包 -->
>            <dependency>
>                <groupId>ch.qos.logback</groupId>
>                <artifactId>logback-core</artifactId>
>                <version>1.2.11</version>
>            </dependency>
>            <dependency>
>                <groupId>ch.qos.logback</groupId>
>                <artifactId>logback-classic</artifactId>
>                <version>1.2.11</version>
>            </dependency>
>        </dependencies>
>    </dependencyManagement>
>
></project>
>```
>
>### 当前字母模块的`pom.xml`文件
>
>```xml
><?xml version="1.0" encoding="UTF-8"?>
>
><project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
>  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
>  <modelVersion>4.0.0</modelVersion>
>  <parent>
>    <artifactId>shiro-parentmodules</artifactId>
>    <groupId>com.mofany</groupId>
>    <version>1.0-SNAPSHOT</version>
>  </parent>
>
>  <groupId>com.mofany</groupId>
>  <artifactId>02-shiro-web-hello</artifactId>
>  <version>1.0-SNAPSHOT</version>
>  <packaging>war</packaging>
>
>  <name>02-shiro-web-hello Maven Webapp</name>
>  <!-- FIXME change it to the project's website -->
>  <url>http://www.example.com</url>
>
>  <properties>
>    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
>    <maven.compiler.source>11</maven.compiler.source>
>    <maven.compiler.target>11</maven.compiler.target>
>  </properties>
>
>  <dependencies>
>    <dependency>
>      <groupId>junit</groupId>
>      <artifactId>junit</artifactId>
>      <version>4.11</version>
>      <scope>test</scope>
>    </dependency>
>    <dependency>
>      <groupId>javax.servlet</groupId>
>      <artifactId>javax.servlet-api</artifactId>
>    </dependency>
>    <dependency>
>      <groupId>javax.servlet</groupId>
>      <artifactId>jstl</artifactId>
>      <version>1.2</version>
>    </dependency>
>    <dependency>
>      <groupId>org.apache.shiro</groupId>
>      <artifactId>shiro-core</artifactId>
>    </dependency>
>    <dependency>
>      <groupId>org.apache.shiro</groupId>
>      <artifactId>shiro-web</artifactId>
>    </dependency>
>    <dependency>
>      <groupId>commons-logging</groupId>
>      <artifactId>commons-logging</artifactId>
>    </dependency>
>  </dependencies>
>
>  <build>
>    <finalName>02-shiro-web-hello</finalName>
>    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
>      <plugins>
>        <plugin>
>          <artifactId>maven-clean-plugin</artifactId>
>          <version>3.1.0</version>
>        </plugin>
>        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging -->
>        <plugin>
>          <artifactId>maven-resources-plugin</artifactId>
>          <version>3.0.2</version>
>        </plugin>
>        <plugin>
>          <artifactId>maven-compiler-plugin</artifactId>
>          <version>3.8.0</version>
>        </plugin>
>        <plugin>
>          <artifactId>maven-surefire-plugin</artifactId>
>          <version>2.22.1</version>
>        </plugin>
>        <plugin>
>          <artifactId>maven-war-plugin</artifactId>
>          <version>3.2.2</version>
>        </plugin>
>        <plugin>
>          <artifactId>maven-install-plugin</artifactId>
>          <version>2.5.2</version>
>        </plugin>
>        <plugin>
>          <artifactId>maven-deploy-plugin</artifactId>
>          <version>2.8.2</version>
>        </plugin>
>      </plugins>
>    </pluginManagement>
>  </build>
></project>
>```
>
>### `web.xml`
>
>```xml
><?xml version="1.0" encoding="UTF-8"?>
>
><web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
>  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
>  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
>                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
>  version="4.0">
>  <!-- 上下文参数,配置本地shiro.ini文件 -->
>  <context-param>
>    <!-- 参数名可改 -->
>    <param-name>shiroConfigLocations</param-name>
>    <!-- 参数值可改 -->
>    <param-value>classpath:shiro.ini</param-value>
>  </context-param>
>    
><!-- shiro的核心配置文件 -->
>  <!-- 监听器 -->
>  <listener>
>    <listener-class>org.apache.shiro.web.env.EnvironmentLoaderListener</listener-class>
>  </listener>
>  <!-- shiro的核心过滤器 -->
>  <filter>
>    <filter-name>ShiroFilter</filter-name>
>    <filter-class>org.apache.shiro.web.servlet.ShiroFilter</filter-class>
>  </filter>
>  <!-- shiro的核心过滤器映射url -->
>  <filter-mapping>
>    <filter-name>ShiroFilter</filter-name>
>    <url-pattern>/*</url-pattern>
>    <dispatcher>REQUEST</dispatcher>
>    <dispatcher>FORWARD</dispatcher>
>    <dispatcher>INCLUDE</dispatcher>
>    <dispatcher>ERROR</dispatcher>
>    <dispatcher>ASYNC</dispatcher>
>  </filter-mapping>
>  </web-app>
>```
>
>### `shiro.ini`
>
>```ini
>[main]
>
>#以下资源都是复数
>[users]
>#用户名=密码,角色
>admin=123456,super
>
>[roles]
>#角色名称=权限列表（*代表所有权限，即囊括CRUD操作）
>super=user:*
>
>[urls]
>```
>
>### `index.jsp`
>
>```jsp
><%@ page contentType="text/html; charset=utf-8" %>
><html>
><head>
>    <title>Title</title>
></head>
><body>
><form action="LoginServlet" method="post">
><input type="text" name="username" placeholder="用户名">
><br>
><input id="" type="password" name="password" placeholder="密码">
><br>
><input type="submit" value="登录">
></form>
></body>
></html>
>
>```
>
>### `success.jsp`
>
>```jsp
><%--
>  Created by IntelliJ IDEA.
>  User: jiang
>  Date: 2022/11/27
>  Time: 0:11
>  To change this template use File | Settings | File Templates.
>--%>
><%@ page contentType="text/html;charset=UTF-8" language="java" %>
><html>
><head>
>    <title>Title</title>
></head>
><body>
><h2> Welcome login</h2>
></body>
></html>
>```
>
>### 自定义`Servlet`
>
>```java
>package com.mofany.shiroservlet;
>
>import org.apache.shiro.SecurityUtils;
>import org.apache.shiro.authc.*;
>import org.apache.shiro.subject.Subject;
>
>import javax.servlet.ServletException;
>import javax.servlet.annotation.WebServlet;
>import javax.servlet.http.HttpServlet;
>import javax.servlet.http.HttpServletRequest;
>import javax.servlet.http.HttpServletResponse;
>import java.io.IOException;
>
>/**
> * @author MoFany-J
> * @date 2022/11/26
> * @description LoginServlet
> */
>@WebServlet(name = "LoginServlet",urlPatterns = "/LoginServlet")
>public class LoginServlet extends HttpServlet {
>    @Override
>    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
>        super.doPost(req, resp);
>    }
>
>    @Override
>    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
>        //设置请求与响应的编码格式
>        request.setCharacterEncoding("utf-8");
>        response.setCharacterEncoding("utf-8");
>        //获取请求参数，即用户名与密码
>        String userName=request.getParameter("username");
>        String password=request.getParameter("password");
>
>        try{
>            //生成token
>            UsernamePasswordToken token=new UsernamePasswordToken(userName,password);
>            //获取subject用户
>            Subject subject=SecurityUtils.getSubject();
>            //利用token（用户信息加密后的字符串）执行登录
>            subject.login(token);
>            //登录成功重定向到首页
>            response.sendRedirect("success.jsp");
>        }catch (UnknownAccountException uae) {
>            //username wasn't in the system, show them an error message?
>            System.out.println("用户未注册！");
>        } catch (IncorrectCredentialsException ice) {
>            //password didn't match, try again?
>            System.out.println("密码错误！");
>        } catch (LockedAccountException lae) {
>            //account for that username is locked - can't login.  Show them a message?
>            System.out.println("账户被锁定！");
>        } catch (AuthenticationException ae) {
>            //unexpected condition - error?
>            System.out.println("登录失败：未知错误！");
>        }
>    }
>}
>```

## 配置`shiro.ini`的默认拦截器/过滤器

>### 核心过滤器对应的名称
>
>| Filter Name        | Class                                                        |
>| ------------------ | ------------------------------------------------------------ |
>| anon`无需认证`     | [org.apache.shiro.web.filter.authc.AnonymousFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/AnonymousFilter.html) |
>| authc`必须认证`    | [org.apache.shiro.web.filter.authc.FormAuthenticationFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/FormAuthenticationFilter.html) |
>| authcBasic         | [org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/BasicHttpAuthenticationFilter.html) |
>| authcBearer        | [org.apache.shiro.web.filter.authc.BearerHttpAuthenticationFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/BearerHttpAuthenticationFilter.html) |
>| invalidRequest     | [org.apache.shiro.web.filter.InvalidRequestFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/InvalidRequestFilter.html) |
>| logout`登出`       | [org.apache.shiro.web.filter.authc.LogoutFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/LogoutFilter.html) |
>| noSessionCreation  | [org.apache.shiro.web.filter.session.NoSessionCreationFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/session/NoSessionCreationFilter.html) |
>| perms`权限`        | [org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/PermissionsAuthorizationFilter.html) |
>| port`端口`         | [org.apache.shiro.web.filter.authz.PortFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/PortFilter.html) |
>| rest               | [org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/HttpMethodPermissionFilter.html) |
>| roles`角色`        | [org.apache.shiro.web.filter.authz.RolesAuthorizationFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/RolesAuthorizationFilter.html) |
>| ssl                | [org.apache.shiro.web.filter.authz.SslFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/SslFilter.html) |
>| user`当作当前用户` | [org.apache.shiro.web.filter.authc.UserFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/UserFilter.html) |
>
>### 过滤器的使用方式
>
>```ini
>#...
>[urls]
>
>#index.html页面不需要认证就可以访问
>/index.html = anon
>#user下的create资源无需认证就可以访问
>/user/create = anon
>#user下的所有资源必须先认证才可以访问
>/user/** = authc
>#admin下的所有资源必须先认证且还得是属于管理员角色才可以访问
>/admin/** = authc, roles[administrator]
>#rest下的所有资源必须先认证才可以访问
>/rest/** = authc, rest
>#remoting下的rpc所有资源必须先认证且还得拥有指定权限才可以访问
>/remoting/rpc/** = authc, perms["remote:invoke"]
>```

## `shiro`结合数据库动态改变用户名

>
>### 数据库层（创建三张表`t_user`、`t_role`、`t_user_role`）
>
>* **参照表结构**
>
>  ```properties
>  # t_user表
>  +----------+-------------+------+-----+---------+----------------+
>  | Field    | Type        | Null | Key | Default | Extra          |
>  +----------+-------------+------+-----+---------+----------------+
>  | id       | int         | NO   | PRI | NULL    | auto_increment |
>  | username | varchar(50) | YES  |     | NULL    |                |
>  | password | varchar(50) | YES  |     | NULL    |                |
>  | email    | varchar(50) | YES  |     | NULL    |                |
>  +----------+-------------+------+-----+---------+----------------+
>  
>  # t_role表
>  +-----------+--------------+------+-----+---------+----------------+
>  | Field     | Type         | Null | Key | Default | Extra          |
>  +-----------+--------------+------+-----+---------+----------------+
>  | id        | int          | NO   | PRI | NULL    | auto_increment |
>  | role_name | varchar(50)  | YES  |     | NULL    |                |
>  | role_desc | varchar(255) | YES  |     | NULL    |                |
>  +-----------+--------------+------+-----+---------+----------------+
>  
>  #t_user_role表
>  +---------+------+------+-----+---------+----------------+
>  | Field   | Type | Null | Key | Default | Extra          |
>  +---------+------+------+-----+---------+----------------+
>  | id      | int  | NO   | PRI | NULL    | auto_increment |
>  | user_id | int  | YES  | MUL | NULL    |                |
>  | role_id | int  | YES  | MUL | NULL    |                |
>  +---------+------+------+-----+---------+----------------+
>  ```
>
>* **MySQL语句**
>
>  * ***创建表***
>
>    ```mysql
>    #创建t_user表
>    create table t_user(
>    	id int primary key auto_increment,
>    	username varchar(50),
>    	password varchar(50),
>    	email varchar(50)
>    );
>    
>    #创建t_role表
>    create table t_role(
>    	id int primary key auto_increment,
>    	role_name varchar(50),
>    	role_desc varchar(255)
>    );
>    
>    #创建t_user_role表
>    create table t_user_role(
>    	id int primary key auto_increment,
>    	user_id int,
>    	role_id int,
>        constraint user_userid foreign key(user_id) references t_user(id),
>        constraint user_roleid foreign key(role_id) references t_role(id)
>    );
>    ```
>
>  * ***查询表结构***
>
>    ```mysql
>    #查询t_user表的表结构
>    mysql> desc t_user;
>    +----------+-------------+------+-----+---------+----------------+
>    | Field    | Type        | Null | Key | Default | Extra          |
>    +----------+-------------+------+-----+---------+----------------+
>    | id       | int         | NO   | PRI | NULL    | auto_increment |
>    | username | varchar(50) | YES  |     | NULL    |                |
>    | password | varchar(50) | YES  |     | NULL    |                |
>    | email    | varchar(50) | YES  |     | NULL    |                |
>    +----------+-------------+------+-----+---------+----------------+
>    4 rows in set (0.01 sec)
>    
>    #查询t_role表的表结构
>    mysql> desc t_role;
>    +-----------+--------------+------+-----+---------+----------------+
>    | Field     | Type         | Null | Key | Default | Extra          |
>    +-----------+--------------+------+-----+---------+----------------+
>    | id        | int          | NO   | PRI | NULL    | auto_increment |
>    | role_name | varchar(50)  | YES  |     | NULL    |                |
>    | role_desc | varchar(255) | YES  |     | NULL    |                |
>    +-----------+--------------+------+-----+---------+----------------+
>    3 rows in set (0.02 sec)
>    
>    #查询t_user_role表的表结构
>    mysql> desc t_user_role;
>    +---------+------+------+-----+---------+----------------+
>    | Field   | Type | Null | Key | Default | Extra          |
>    +---------+------+------+-----+---------+----------------+
>    | id      | int  | NO   | PRI | NULL    | auto_increment |
>    | user_id | int  | YES  | MUL | NULL    |                |
>    | role_id | int  | YES  | MUL | NULL    |                |
>    +---------+------+------+-----+---------+----------------+
>    3 rows in set (0.00 sec)
>    ```
>
>  * ***插入数据***
>
>    ```mysql
>    #向t_user表插入数据
>    insert into t_user (id,username,password,email) values 
>    												(NULL,"lucy","123456","lucy@outlook.com"),
>    												(NULL,"jhon","123456","jhon@outlook.com");
>    
>    #向t_role表插入数据
>    insert into t_role (id,role_name,role_desc) values (NULL,"Administrator","超级管理员");
>    
>    
>    #向t_user_role表插入数据
>    insert into t_user_role (id,user_id,role_id) values (NULL,1,1);
>    ```
>
>  * ***查询表数据***
>
>    ```mysql
>    #查询t_user表数据
>    mysql> select * from t_user;
>    +----+----------+----------+------------------+
>    | id | username | password | email            |
>    +----+----------+----------+------------------+
>    |  1 | lucy     | 123456   | lucy@outlook.com |
>    |  2 | jhon     | 123456   | jhon@outlook.com |
>    +----+----------+----------+------------------+
>    2 rows in set (0.00 sec)
>    
>    #查询t_role表的数据
>    mysql> select * from t_role;
>    +----+---------------+------------+
>    | id | role_name     | role_desc  |
>    +----+---------------+------------+
>    |  1 | Administrator | 超级管理员 |
>    +----+---------------+------------+
>    1 row in set (0.01 sec)
>    
>    #查询t_user_role表的数据
>    mysql> select * from t_user_role;
>    +----+---------+---------+
>    | id | user_id | role_id |
>    +----+---------+---------+
>    |  1 |       1 |       1 |
>    +----+---------+---------+
>    1 row in set (0.00 sec)
>    ```
>
>
>### 项目配置层
>
>* **Web项目的`pom.xml`中项目所需依赖**
>
>  ```xml
>    <dependencies>
>  <!--    单元测试-->
>      <dependency>
>        <groupId>junit</groupId>
>        <artifactId>junit</artifactId>
>        <version>4.11</version>
>        <scope>test</scope>
>      </dependency>
>  <!--    shiroWeb-->
>      <dependency>
>        <groupId>org.apache.shiro</groupId>
>        <artifactId>shiro-web</artifactId>
>      </dependency>
>  <!--    servlet-->
>      <dependency>
>        <groupId>javax.servlet</groupId>
>        <artifactId>javax.servlet-api</artifactId>
>      </dependency>
>  <!--    jstl-->
>      <dependency>
>        <groupId>javax.servlet</groupId>
>        <artifactId>jstl</artifactId>
>      </dependency>
>  <!--    mysql-->
>      <dependency>
>        <groupId>mysql</groupId>
>        <artifactId>mysql-connector-java</artifactId>
>      </dependency>
>  <!--    druid-->
>      <dependency>
>        <groupId>com.alibaba</groupId>
>        <artifactId>druid</artifactId>
>      </dependency>
>  <!--    dbutils-->
>      <dependency>
>        <groupId>commons-dbutils</groupId>
>        <artifactId>commons-dbutils</artifactId>
>      </dependency>
>  <!--    lombok-->
>      <dependency>
>        <groupId>org.projectlombok</groupId>
>        <artifactId>lombok</artifactId>
>      </dependency>
>  <!--    logging-->
>      <dependency>
>        <groupId>commons-logging</groupId>
>        <artifactId>commons-logging</artifactId>
>      </dependency>
>    </dependencies>
>  ```
>
>* **Web项目的`web.xml`**
>
>  ```xml
>     <!--欢迎页--> 
>    <welcome-file-list>
>      <welcome-file>login.jsp</welcome-file>
>    </welcome-file-list>
>    <!-- 上下文参数,配置本地shiro.ini文件 -->
>    <context-param>
>      <!-- 参数名可改 -->
>      <param-name>shiroConfigLocations</param-name>
>      <!-- 参数值可改 -->
>      <param-value>classpath:shiro.ini</param-value>
>    </context-param>
>  
>    <!-- shiro的核心配置文件 -->
>    <!-- 监听器 -->
>    <listener>
>      <listener-class>org.apache.shiro.web.env.EnvironmentLoaderListener</listener-class>
>    </listener>
>    <!-- shiro的核心过滤器 -->
>    <filter>
>      <filter-name>ShiroFilter</filter-name>
>      <filter-class>org.apache.shiro.web.servlet.ShiroFilter</filter-class>
>    </filter>
>    <!-- shiro的核心过滤器映射url -->
>    <filter-mapping>
>      <filter-name>ShiroFilter</filter-name>
>      <url-pattern>/*</url-pattern>
>      <dispatcher>REQUEST</dispatcher>
>      <dispatcher>FORWARD</dispatcher>
>      <dispatcher>INCLUDE</dispatcher>
>      <dispatcher>ERROR</dispatcher>
>      <dispatcher>ASYNC</dispatcher>
>    </filter-mapping>
>  ```
>
>* ***被加载的数据源文件***
>
>  * **`shiro.ini`**
>
>    ```ini
>    [main]
>    #将自定义realm注册给SecurityManager
>    MyRealm=com.mofany.realm.MyRealm
>    securityManager.realms=$MyRealm
>    #配置登录页面
>    authc.loginUrl=/login.jsp
>    
>    [users]
>    
>    [roles]
>    
>    [urls]
>    #配置过滤器
>    #无需认证即可访问
>    /login.jsp=anon
>    #必须认证才能访问
>    /success.jsp=authc
>    ```
>
>  * **`db.properties`**
>
>    ```properties
>    username=root
>    password=Jiangmh220
>    driverClassName=com.mysql.cj.jdbc.Driver
>    url=jdbc:mysql://localhost:3306/java67?serverTimezone=GMT%2B8
>    ```
>
>### 代码层
>
>* **dao层**
>
>  * **impl层**
>
>    ```java
>    package com.mofany.dao.impl;
>    
>    import com.mofany.dao.UserDao;
>    import com.mofany.entity.User;
>    import com.mofany.util.QueryRunnerUtil;
>    import org.apache.commons.dbutils.QueryRunner;
>    import org.apache.commons.dbutils.handlers.BeanHandler;
>    
>    import java.sql.SQLException;
>    
>    /**
>     * @author MoFany-J
>     * @date 2022/11/28
>     * @description UserDaoImpl
>     */
>    public class UserDaoImpl implements UserDao {
>        /**
>         * 查询执行器实例成员变量
>         * */
>        private QueryRunner queryRunner= QueryRunnerUtil.getQueryRunner();
>    
>        /**
>         * 按用户名查找
>         *
>         * @param userName 传入要查询的用户名
>         */
>        @Override
>        public User queryByUserName(String userName) {
>            User user=null;
>            try {
>                //执行sql语句并将结果集映射到一个JavaBean对象中
>                user=queryRunner.query("select * from t_user where username = ?",
>                                       				new BeanHandler<>(User.class),userName);
>    
>            } catch (SQLException e) {
>                e.printStackTrace();
>            }
>    
>            //返回查询结果
>            return user;
>        }
>    }
>    
>    ```
>
>  ```java
>  package com.mofany.dao;
>  
>  import com.mofany.entity.User;
>  
>  /**
>   * @author MoFany-J
>   * @date 2022/11/28
>   * @description UserDao 数据访问层接口
>   */
>  public interface UserDao {
>      /**
>       * 按用户名查找
>       * @param userName  传入要查询的用户名
>       * */
>      User queryByUserName(String userName);
>  
>  }
>  ```
>
>  * **单元测试层test**
>
>    ```java
>    package com.mofany.test;
>    
>    import com.mofany.dao.UserDao;
>    import com.mofany.dao.impl.UserDaoImpl;
>    import org.junit.Test;
>    
>    /**
>     * @author MoFany-J
>     * @date 2022/11/29
>     * @description UserDaoTest
>     */
>    public class UserDaoTest {
>        private UserDao userDao=new UserDaoImpl();
>    
>        @Test
>        public void findByUserName(){
>            System.out.println(userDao.queryByUserName("jhon"));
>        }
>    
>    }
>    ```
>
>* **entity层**
>
>  ```java
>  package com.mofany.entity;
>  
>  import lombok.Getter;
>  import lombok.NoArgsConstructor;
>  import lombok.Setter;
>  import lombok.ToString;
>  
>  /**
>   * @author MoFany-J
>   * @date 2022/11/28
>   * @description User 实体类
>   *
>   * 通过lombok注解添加setter、getter、toString、无参构造器
>   */
>  @Setter
>  @Getter
>  @ToString
>  @NoArgsConstructor
>  public class User {
>      private int id;
>      private String userName;
>      private String password;
>      private String email;
>  }
>  ```
>
>* **reaml层**
>
>  ```java
>  package com.mofany.realm;
>  
>  import com.mofany.dao.UserDao;
>  import com.mofany.dao.impl.UserDaoImpl;
>  import com.mofany.entity.User;
>  import org.apache.shiro.authc.*;
>  import org.apache.shiro.authz.AuthorizationInfo;
>  import org.apache.shiro.realm.AuthorizingRealm;
>  import org.apache.shiro.subject.PrincipalCollection;
>  
>  /**
>   * @author MoFany-J
>   * @date 2022/11/28
>   * @description MyRealm
>   */
>  public class MyRealm extends AuthorizingRealm {
>      /**
>       * 创建一个用户对象的实例成员
>       * */
>      private UserDao userDao=new UserDaoImpl();
>  
>      /**
>       * 自定义授权
>       * */
>      @Override
>      protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
>          return null;
>      }
>  
>      /**
>       * 自定义认证
>       * */
>      @Override
>      protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken 
>                                   		authenticationToken) throws AuthenticationException {
>          
>          //创建用户token对象
>          UsernamePasswordToken userToken=(UsernamePasswordToken) authenticationToken;
>          //获取由subject.login(userToken)传过来的用户名，即请求参数对应的用户名
>          String userName=userToken.getUsername();
>          //查询该用户
>          User user=userDao.queryByUserName(userName);
>          //判断该用户是否为空
>          if (user==null){
>              throw new UnknownAccountException("未注册的用户!");
>          }
>          //获取密码
>          String password=user.getPassword();
>          //输出数据库中查询到的用户信息
>          System.out.println("数据库中查询到的信息为："+user);
>          //返回一个简单的认证信息
>          return new SimpleAuthenticationInfo(user,password,this.getName());
>          
>          /**
>          * 通过盐来加密
>          */
>      }
>  }
>  ```
>
>* **servlet层**
>
>  ```java
>  package com.mofany.servlet;
>  
>  import org.apache.shiro.SecurityUtils;
>  import org.apache.shiro.authc.*;
>  import org.apache.shiro.subject.Subject;
>  
>  import javax.servlet.ServletException;
>  import javax.servlet.annotation.WebServlet;
>  import javax.servlet.http.HttpServlet;
>  import javax.servlet.http.HttpServletRequest;
>  import javax.servlet.http.HttpServletResponse;
>  import java.io.IOException;
>  
>  /**
>   * @author MoFany-J
>   * @date 2022/11/28
>   * @description LoginServlet
>   */
>  @WebServlet(name = "LoginServlet",urlPatterns = "/LoginServlet")
>  public class LoginServlet extends HttpServlet {
>      @Override
>      protected void doGet(HttpServletRequest req, HttpServletResponse resp) 
>          												throws ServletException, IOException {
>          doPost(req, resp);
>      }
>  
>      @Override
>      protected void doPost(HttpServletRequest request, HttpServletResponse response) 
>          												throws ServletException, IOException {
>          //获取请求参数
>          String userName=request.getParameter("username");
>          String password=request.getParameter("password");
>          //封装为token
>          UsernamePasswordToken userToken=new UsernamePasswordToken(userName,password);
>          //获取Subject对象
>          Subject subject= SecurityUtils.getSubject();
>  
>          //执行登录
>          try{
>              subject.login(userToken);
>              //登录成功后响应重定向到指定页面
>              response.sendRedirect("success.jsp");
>          }catch (UnknownAccountException e){
>              System.out.println("未注册用户!");
>          }catch (IncorrectCredentialsException e){
>              System.out.println("密码错误!");
>          }catch (LockedAccountException e){
>              System.out.println("账户锁定!");
>          }catch (AuthenticationException e){
>              System.out.println("登录失败：未知错误!");
>          }
>      }
>  }
>  ```
>
>* **util层**
>
>  ```java
>  package com.mofany.util;
>  
>  import com.alibaba.druid.pool.DruidDataSourceFactory;
>  import org.apache.commons.dbutils.QueryRunner;
>  
>  import javax.sql.DataSource;
>  import java.io.IOException;
>  import java.io.InputStream;
>  import java.util.Properties;
>  
>  /**
>   * @author MoFany-J
>   * @date 2022/11/28
>   * @description QueryRunnerUtil 负责与数据建立链接
>   */
>  public class QueryRunnerUtil {
>      /**
>       * 数据源，类变量
>       * */
>      private static DataSource dataSource;
>  
>      /**
>       * 禁止创建该类的实例，禁止通过反射创建该类的实例
>       * */
>      private QueryRunnerUtil(){
>          if(dataSource!=null){
>              throw new RuntimeException("禁止反射获取工具类QueryRunnerUtil实例!");
>          }
>      }
>  
>      /**
>       * 静态成员方法，获取关于数据库的查询执行器实例
>       * */
>      public static QueryRunner getQueryRunner(){
>          //加载数据源
>          InputStream resourceAsStream = 
>              QueryRunnerUtil.class.getClassLoader().getResourceAsStream("mysql.properties");
>          //创建属性对象
>          Properties properties=new Properties();
>          try{
>              //将数据源装入属性对象
>              properties.load(resourceAsStream);
>              //通过DruidDataSourceFactory工厂创建数据源实例
>              dataSource= DruidDataSourceFactory.createDataSource(properties);
>          } catch (IOException e) {
>              e.printStackTrace();
>          } catch (Exception e) {
>              e.printStackTrace();
>          }
>          //返回数据库查询执行器对象
>          return new QueryRunner(dataSource);
>      }
>  }
>  ```
>

## :boxing_glove:通过盐来加密

>#### 自定义Realm
>
>```java
>package com.mofany.realm;
>
>import com.mofany.dao.UserDao;
>import com.mofany.dao.impl.UserDaoImpl;
>import com.mofany.entity.User;
>import org.apache.shiro.authc.*;
>import org.apache.shiro.authz.AuthorizationInfo;
>import org.apache.shiro.crypto.hash.SimpleHash;
>import org.apache.shiro.realm.AuthorizingRealm;
>import org.apache.shiro.subject.PrincipalCollection;
>import org.apache.shiro.util.ByteSource;
>
>/**
> * @author MoFany-J
> * @date 2022/11/30
> * @description MyRealm
> */
>public class MyRealm extends AuthorizingRealm {
>    /**
>     * 私有实例成员
>     * */
>    private UserDao userDao=new UserDaoImpl();
>
>    /**
>     * 自定义授权
>     * */
>    @Override
>    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
>        return null;
>    }
>
>    /**
>     * 自定义认证
>     * */
>    @Override
>    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
>        //参数类型转换为用户的token
>        UsernamePasswordToken userToken=(UsernamePasswordToken) token;
>        //获取用户名
>        String username=userToken.getUsername();
>        //返回查询指定用户名的用户是否存在
>        User user=userDao.queryByUserName(username);
>        //判断查询到的用户
>        if(user==null){
>            throw new UnknownAccountException("用户未注册");
>        }
>        System.out.println("数据库中查询到的用户信息为：\n"+user);
>        //获取数据库中查询到的用户密码
>        String password=user.getPassword();
>        System.out.println("数据库中查到的用户信息：\n"
>                           +"用户名："+user.getUser_name()
>                           +"\n用户密码："+user.getPassword());
>
>        /**
>         * 定义盐，即加密的佐料（该用户密码和账号进行再加密）
>         * */
>        System.out.println("***************************************************************");
>        ByteSource salt=ByteSource.Util.bytes(username);
>        System.out.println("加密的盐为："+salt);
>        // 将加密密码写入数据库（加密的算法，初始时要加密的密码，参与本次加密的盐，要进行加密的次数）
>        SimpleHash simpleHash=new SimpleHash("SHA1","123456",salt,1024);
>        System.out.println("加密后的密文密码（写入数据库）为："+simpleHash);
>        System.out.println("***************************************************************");
>        if(userDao.executorEncryption(username,simpleHash.toString())){
>            System.out.println("加密密码已写入数据库！");
>        }
>
>        //返回一个简单的认证信息
>        return new SimpleAuthenticationInfo(username,password,salt,this.getName());
>    }
>}
>```
>
>

# `Shiro`整合`Spring`

## :boxing_glove:整合独立应用`Standalone Applications`

>#### 依赖
>
>```xml
><dependency>
>  <groupId>org.apache.shiro</groupId>
>  <artifactId>shiro-spring</artifactId>
>  <version>1.11.0</version>
></dependency>
><dependency>
>  <groupId>org.springframework</groupId>
>  <artifactId>spring-context</artifactId>
>  <version>${spring.version}</version>
></dependency>
>```
>
>#### 自定义Spring配置类`Config`
>
>```java
>package org.apache.shiro.samples.spring;
>
>import org.apache.shiro.realm.Realm;
>import org.apache.shiro.realm.text.TextConfigurationRealm;
>import org.apache.shiro.spring.config.ShiroAnnotationProcessorConfiguration;
>import org.apache.shiro.spring.config.ShiroBeanConfiguration;
>import org.apache.shiro.spring.config.ShiroConfiguration;
>import org.springframework.context.annotation.AnnotationConfigApplicationContext;
>import org.springframework.context.annotation.Bean;
>import org.springframework.context.annotation.ComponentScan;
>import org.springframework.context.annotation.Configuration;
>import org.springframework.context.annotation.Import;
>
>/**
> * Application bean definitions.
> */
>@Configuration
>@Import({ShiroBeanConfiguration.class,
>         ShiroConfiguration.class,
>         ShiroAnnotationProcessorConfiguration.class})
>@ComponentScan("org.apache.shiro.samples.spring")
>public class CliAppConfig {
>
>    /**
>     * 硬编码的Realm bean实例
>     */
>    @Bean
>    public Realm realm() {
>        // 文本配置域，自定义Realm
>        TextConfigurationRealm realm = new TextConfigurationRealm();
>        // 设置用户定义，认证里面去指定
>        realm.setUserDefinitions("joe.coder=password,user\n" +"jill.coder=password,admin");
>        // 设置角色定义，
>         .setRoleDefinitions("admin=read,write\n" +"user=read");
>        // 开启缓存
>        realm.setCachingEnabled(true);
>        return realm;
>    }
>}
>```
>
>###### `@Import注解导入`说明：
>
>| 配置类                                                       | 描述                                                   |
>| ------------------------------------------------------------ | ------------------------------------------------------ |
>| org.apache.shiro.spring.config.ShiroBeanConfiguration        | 配置 Shiro 的生命周期和事件                            |
>| org.apache.shiro.spring.config.ShiroConfiguration            | 配置 Shiro Beans（SecurityManager、SessionManager 等） |
>| org.apache.shiro.spring.config.ShiroAnnotationProcessorConfiguration | 启用 Shiro 的注释处理                                  |
>
>#### 简单服务`SimpleService`
>
>```java
>package org.apache.shiro.samples.spring;
>
>import org.apache.shiro.authz.annotation.RequiresPermissions;
>import org.slf4j.Logger;
>import org.slf4j.LoggerFactory;
>import org.springframework.stereotype.Component;
>
>/**
> * 简单的服务，其方法用注解保护
> */
>@Component
>public class SimpleService {
>
>    /**
>    * 日志
>    */
>    private static Logger log = LoggerFactory.getLogger(SimpleService.class);
>
>    /**
>    * 需要写权限才可访问
>    */
>    @RequiresPermissions("write")
>    public void writeRestrictedCall() {
>        log.info("executing method that requires the 'write' permission");
>    }
>
>    /**
>    * 需要读权限才可访问
>    */
>    @RequiresPermissions("read")
>    public void readRestrictedCall() {
>        log.info("executing method that requires the 'read' permission");
>    }
>}
>```
>
>#### 快速启动`QuickStart`
>
>```java
>package org.apache.shiro.samples.spring;
>
>import org.apache.shiro.SecurityUtils;
>import org.apache.shiro.authc.UsernamePasswordToken;
>import org.apache.shiro.authz.AuthorizationException;
>import org.apache.shiro.mgt.SecurityManager;
>import org.apache.shiro.subject.Subject;
>import org.apache.shiro.lang.util.Assert;
>import org.slf4j.Logger;
>import org.slf4j.LoggerFactory;
>import org.springframework.beans.factory.annotation.Autowired;
>import org.springframework.stereotype.Component;
>
>import javax.annotation.PostConstruct;
>
>/**
> * 用于演示Subject用法的简单Bean
> */
>@Component
>public class QuickStart {
>
>    /**
>    * 日志
>    */
>    private static Logger log = LoggerFactory.getLogger(QuickStart.class);
>
>    /**
>    * 安全管理器
>    */
>    @Autowired
>    private SecurityManager securityManager;
>
>    /**
>    * 操作数据库对应的业务逻辑
>    */
>    @Autowired
>    private SimpleService simpleService;
>
>    public void run() {
>
>        /**
>        * 获取当前当前正在执行的用户
>        */ 
>        Subject subject = SecurityUtils.getSubject();
>
>        // 断言： subject 是否已认证
>        Assert.isTrue(!subject.isAuthenticated());
>
>        // 使用 username / password 登录该 currentSubject
>        UsernamePasswordToken token = new UsernamePasswordToken("joe.coder", "password");
>        // 用户登录
>        subject.login(token);
>
>        // joe.coder 拥有用户角色
>        subject.checkRole("user");
>
>        // 断言： joe.coder 没有管理员的角色
>        Assert.isTrue(!subject.hasRole("admin"));
>
>        // joe.coder 有读权限
>        subject.checkPermission("read");
>
>        /**
>        * 数据库的业务逻辑操作
>        */
>        simpleService.readRestrictedCall();
>
>        try {
>            /**
>        	* 数据库的业务逻辑操作
>        	*/
>            simpleService.writeRestrictedCall();
>        }
>        catch (AuthorizationException e) {
>            // 日志级别为info
>            log.info("Subject was NOT allowed to execute method 'writeRestrictedCall'");
>        }
>
>        // 登出
>        subject.logout();
>        // 断言：subject 是否已认证
>        Assert.isTrue(!subject.isAuthenticated());
>    }
>
>
>    /**
>     * 初始化SecurityManager的静态实例
>     * Web应用程序不需要这样做
>     */
>    @PostConstruct
>    private void initStaticSecurityManager() {
>        SecurityUtils.setSecurityManager(securityManager);
>    }
>}
>```
>

## :boxing_glove:整合Web应用`Web Applications`

>#### 该整合方式也可以用于SpringBoot
>
>#### 依赖
>
>```xml
><dependency>
>  <groupId>org.apache.shiro</groupId>
>  <artifactId>shiro-spring</artifactId>
>  <version>1.11.0</version>
></dependency>
><dependency>
>  <groupId>org.apache.shiro</groupId>
>  <artifactId>shiro-web</artifactId>
>  <version>1.11.0</version>
></dependency>
><dependency>
>  <groupId>org.springframework</groupId>
>  <artifactId>spring-webmvc</artifactId>
>  <version>${spring.version}</version>
></dependency>
>```
>
>#### 全局配置`application.yaml`
>
>```yaml
># 指定Shiro登录时的URL
>shiro:
>  loginUrl: /login.html
>```
>
>#### 自定义`MyRealm`类，用于认证与授权
>
>```java
>public class MyRealm extends AuthorizingRealm {
>    
>    /**
>    * 操作数据库的业务逻辑
>    */
>    ...
>
>    /**
>     * 自定义授权
>     * */
>    @Override
>    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
>        return null;
>    }
>
>    /**
>     * 自定义认证
>     * */
>    @Override
>    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
>        //参数类型转换为用户的token
>        UsernamePasswordToken userToken=(UsernamePasswordToken) token;
>        
>        //获取用户名
>        String username=userToken.getUsername();
>        
>        // ... 查询数据库
>        
>        return null;
>    }
>}
>```
>
>#### 自定义配置类
>
>```java
>@Configuration
>@Import({ShiroBeanConfiguration.class,
>        ShiroAnnotationProcessorConfiguration.class,
>        ShiroWebConfiguration.class,
>        ShiroWebFilterConfiguration.class,
>        ShiroRequestMappingConfig.class})
>public class ApplicationConfig {
>    
>    /**
>    * Shiro过滤链定义，未启用注解集中管理，方法1：
>    */
>    @Bean
>		public ShiroFilterChainDefinition shiroFilterChainDefinition() {
>    	DefaultShiroFilterChainDefinition chainDefinition = 
>            								new DefaultShiroFilterChainDefinition();
>
>    	// 以'管理员'角色登录的用户
>    	chainDefinition.addPathDefinition("/admin/**", "authc, roles[admin]");
>
>    	// 有'document:read'权限的登录用户
>    	chainDefinition.addPathDefinition("/docs/**", "authc, perms[document:read]");
>
>    	// 所有其他路径都需要有一个登录的用户
>    	chainDefinition.addPathDefinition("/**", "authc");
>    	return chainDefinition;
>		}
>    
>    /**
>    * 所有请求访问过滤都是由注解统一管理，方法2：
>    */
>    @Bean
>		public ShiroFilterChainDefinition shiroFilterChainDefinition() {
>    	DefaultShiroFilterChainDefinition chainDefinition = 
>            								new DefaultShiroFilterChainDefinition();
>        // 所有的路径都是通过注解管理的
>    	chainDefinition.addPathDefinition("/**", "anon");
>
>    	// 或允许基本认证，但不要求基本认证
>    	// chainDefinition.addPathDefinition("/**", "authcBasic[permissive]");
>    	return chainDefinition;
>    }
>
>    
>    /**
>    * 自定义Realm
>    */
>    @Bean
>		public Realm realm() {
>  		//开发者自定义一个Realm类，来分别实现认证与授权
>        MyRealm myRealm=new MyRealm();
>        return myRealm;
>		}
>    
>    /**
>    * 启用缓存
>    */
>    @Bean
>		protected CacheManager cacheManager() {
>    	return new MemoryConstrainedCacheManager();
>		}
>}
>```
>
>##### `@Import注解导入`说明：
>
>| Configuration Class                                          | Description                                                  |
>| ------------------------------------------------------------ | ------------------------------------------------------------ |
>| org.apache.shiro.spring.config.ShiroBeanConfiguration        | 配置 Shiro 的生命周期和事件                                  |
>| org.apache.shiro.spring.config.ShiroAnnotationProcessorConfiguration | 启用 Shiro 的注释处理                                        |
>| org.apache.shiro.spring.web.config.ShiroWebConfiguration     | 配置 Shiro Beans 以供 Web 使用（SecurityManager、SessionManager 等） |
>| org.apache.shiro.spring.web.config.ShiroWebFilterConfiguration | 配置四郎的网页过滤器                                         |
>| org.apache.shiro.spring.web.config.ShiroRequestMappingConfig | 使用 Shiro 的实现配置 Spring，以确保 URL 在两个框架中的处理方式相同`UrlPathHelper` |
>
>

## :boxing_glove:整合`SpringBoot`

>#### 依赖
>
>```xml
><dependency>
>    <groupId>org.apache.shiro</groupId>
>    <artifactId>shiro-spring-boot-web-starter</artifactId>
></dependency>
>```
>
>#### 全局配置`application.properties`
>
>```properties
># 指定Shiro登录时的URL
>shiro.loginUrl = /login.html
>
># 让shiro管理这些 Session
>shiro.userNativeSessionManager = true
>
># 禁用URL会话重写
>shiro.sessionManager.sessionIdUrlRewritingEnabled = false
>```
>
>#### 控制器`Controller`
>
>* ###### account-info
>
>  ```java
>  package org.apache.shiro.samples;
>  
>  import org.apache.shiro.SecurityUtils;
>  import org.apache.shiro.authz.annotation.RequiresRoles;
>  import org.apache.shiro.subject.PrincipalCollection;
>  import org.apache.shiro.subject.Subject;
>  import org.springframework.stereotype.Controller;
>  import org.springframework.ui.Model;
>  import org.springframework.web.bind.annotation.RequestMapping;
>  
>  /**
>  * 接受信息控制器
>  */
>  @Controller
>  public class AccountInfoController {
>  
>      @RequiresRoles("admin")
>      @RequestMapping("/account-info")
>      public String home(Model model) {
>  
>          String name = "World";
>  		// 获取当前的subject
>          Subject subject = SecurityUtils.getSubject();
>  
>          PrincipalCollection principalCollection = subject.getPrincipals();
>  
>          if (principalCollection != null && !principalCollection.isEmpty()) {
>              name = principalCollection.getPrimaryPrincipal().toString();
>          }
>  
>          model.addAttribute("name", name);
>  
>          return "account-info";
>      }
>  }
>  ```
>
>* hello
>
>  ```java
>  package org.apache.shiro.samples;
>  
>  import org.apache.shiro.SecurityUtils;
>  import org.apache.shiro.subject.PrincipalCollection;
>  import org.apache.shiro.subject.Subject;
>  import org.apache.shiro.util.CollectionUtils;
>  import org.springframework.stereotype.Controller;
>  import org.springframework.ui.Model;
>  import org.springframework.web.bind.annotation.RequestMapping;
>  
>  import javax.servlet.http.HttpServletRequest;
>  import java.util.Collection;
>  import java.util.Map;
>  
>  /**
>  * hello控制器
>  */
>  @Controller
>  public class HelloController {
>  
>      @SuppressWarnings("Duplicates")
>      @RequestMapping("/")
>      public String home(HttpServletRequest request, Model model) {
>  
>          String name = "World";
>  		// 获取当前的subject
>          Subject subject = SecurityUtils.getSubject();
>  
>          PrincipalCollection principalCollection = subject.getPrincipals();
>  
>          if (principalCollection != null && !principalCollection.isEmpty()) {
>              Collection<Map> principalMaps = subject.getPrincipals().byType(Map.class);
>              if (CollectionUtils.isEmpty(principalMaps)) {
>                  name = subject.getPrincipal().toString();
>              }
>              else {
>                  name = (String) principalMaps.iterator().next().get("username");
>              }
>          }
>  
>          model.addAttribute("name", name);
>  
>          return "hello";
>      }
>  
>  }
>  ```
>
>* login
>
>  ```java
>  package org.apache.shiro.samples;
>  
>  import org.springframework.stereotype.Controller;
>  import org.springframework.web.bind.annotation.RequestMapping;
>  
>  /**
>  * 登录页控制器
>  */
>  @Controller
>  public class LoginController {
>  
>      @RequestMapping("/login.html")
>      public String loginTemplate() {
>  
>          return "login";
>      }
>  
>  }
>  ```
>
>* error
>
>  ```java
>  package org.apache.shiro.samples;
>  
>  import org.springframework.beans.factory.annotation.Autowired;
>  import org.springframework.boot.web.error.ErrorAttributeOptions;
>  import org.springframework.boot.web.servlet.error.ErrorAttributes;
>  import org.springframework.boot.web.servlet.error.ErrorController;
>  import org.springframework.stereotype.Controller;
>  import org.springframework.ui.Model;
>  import org.springframework.web.bind.annotation.RequestMapping;
>  import org.springframework.web.context.request.ServletWebRequest;
>  
>  import javax.servlet.http.HttpServletRequest;
>  import java.util.Map;
>  
>  /**
>   * 错误页重定向控制器 
>   */
>  @Controller
>  public class RestrictedErrorController implements ErrorController {
>      private static final String ERROR_PATH = "/error";
>  
>      @Autowired
>      private ErrorAttributes errorAttributes;
>  
>      public String getErrorPath() {
>          return ERROR_PATH;
>      }
>  
>      @RequestMapping(ERROR_PATH)
>      String error(HttpServletRequest request, Model model) {
>          Map<String, Object> errorMap = errorAttributes.getErrorAttributes(
>                  new ServletWebRequest(request),
>                  ErrorAttributeOptions.of(ErrorAttributeOptions.Include.MESSAGE));
>          model.addAttribute("errors", errorMap);
>          return "error";
>      }
>  }
>  ```
>
>#### 主启动类`核心配置类`
>
>```java
>package org.apache.shiro.samples;
>
>import org.apache.shiro.SecurityUtils;
>import org.apache.shiro.authz.AuthorizationException;
>import org.apache.shiro.realm.Realm;
>import org.apache.shiro.realm.text.TextConfigurationRealm;
>import org.apache.shiro.spring.web.config.DefaultShiroFilterChainDefinition;
>import org.apache.shiro.spring.web.config.ShiroFilterChainDefinition;
>import org.apache.shiro.subject.Subject;
>import org.slf4j.Logger;
>import org.slf4j.LoggerFactory;
>import org.springframework.boot.SpringApplication;
>import org.springframework.boot.autoconfigure.SpringBootApplication;
>import org.springframework.context.annotation.Bean;
>import org.springframework.context.annotation.Configuration;
>import org.springframework.http.HttpStatus;
>import org.springframework.ui.Model;
>import org.springframework.web.bind.annotation.ControllerAdvice;
>import org.springframework.web.bind.annotation.ExceptionHandler;
>import org.springframework.web.bind.annotation.ModelAttribute;
>import org.springframework.web.bind.annotation.ResponseStatus;
>
>import java.util.HashMap;
>import java.util.Map;
>
>@Configuration
>@ControllerAdvice
>@SpringBootApplication
>public class WebApp { //NOPMD
>
>    private static Logger log = LoggerFactory.getLogger(WebApp.class);
>
>    public static void main(String[] args) {
>        SpringApplication.run(WebApp.class, args);
>    }
>
>    /**
>    * 定义全局异常处理器
>    */
>    @ExceptionHandler(AuthorizationException.class)
>    @ResponseStatus(HttpStatus.FORBIDDEN)
>    public String handleException(AuthorizationException e, Model model) {
>        // you could return a 404 here instead 
>        // (this is how github handles 403, so the user does NOT know there is a
>        // resource at that location)
>        log.debug("AuthorizationException was thrown", e);
>        Map<String, Object> map = new HashMap<String, Object>();
>        map.put("status", HttpStatus.FORBIDDEN.value());
>        map.put("message", "No message available");
>        model.addAttribute("errors", map);
>        return "error";
>    }
>
>    /**
>    * 配置域
>    */
>    @Bean
>    public Realm realm() {
>        TextConfigurationRealm realm = new TextConfigurationRealm();
>        realm.setUserDefinitions("joe.coder=password,user\n" +"jill.coder=password,admin");
>        realm.setRoleDefinitions("admin=read,write\n" +"user=read");
>        realm.setCachingEnabled(true);
>        return realm;
>    }
>
>    /**
>    * 配置过滤器链
>    */
>    @Bean
>    public ShiroFilterChainDefinition shiroFilterChainDefinition() {
>        DefaultShiroFilterChainDefinition chainDefinition = 
>            									new DefaultShiroFilterChainDefinition();
>        // 需要接受来自登录表单的Post请求
>        chainDefinition.addPathDefinition("/login.html", "authc"); 
>        chainDefinition.addPathDefinition("/logout", "logout");
>        return chainDefinition;
>    }
>
>    /**
>    * 配置用户：Subject
>    */
>    @ModelAttribute(name = "subject")
>    public Subject subject() {
>        return SecurityUtils.getSubject();
>    }
>}
>```
>

# `Shiro`整合`apache CAS`到SpringBoot

## 配置与依赖

>#### Spring Boot
>
>* CAS 也在很大程度上基于 [Spring Boot](https://github.com/spring-projects/spring-boot)，它 允许它采取固执己见的观点 Spring 平台和第三方库创建独立的 Web 应用程序尽可能没有XML配置的麻烦。 Spring Boot 允许 CAS 隐藏其内部复杂性的大部分 组件及其配置，而是提供自动配置模块，这些模块可以自动配置正在运行的应用程序上下文，而无需太多手动干预。
>
>#### 依赖
>
>```xml
><dependency>
>    <groupId>org.apache.shiro</groupId>
>    <artifactId>shiro-cas</artifactId>
>    <version>version</version>
></dependency>
>```
>
>[^1]: *version*> = 1.2.0
>
>#### Springboot整合Shiro与CAS
>
>* 全局配置文件`application.properties`
>
>  ```properties
>  
>  ```
>
>
>