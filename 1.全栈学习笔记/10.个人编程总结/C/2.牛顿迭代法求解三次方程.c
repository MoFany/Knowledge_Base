//#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<math.h>
int execute_fun2()
{
	//函数原型声明
	float fun_fx(float a,float b,float c,float d);
	float a, b, c, d, fx;
	printf("请依次输入系数a,b,c,d：");
	scanf("%f%f%f%f", &a, &b, &c, &d);
	fx = fun_fx(a, b, c, d);
	printf("该一元三次方程的根为：%f\n", fx);
	return 0;
}

float fun_fx(float a, float b, float c, float d)
{
	//X1=1 先假设一个已知的靠近方程根的点的X轴坐标
	float x1 = 1, x0, f0, f1;
	do
	{
		//Xn  其是使用X1的值每次刷新X0的值
		x0 = x1;
		
		//原函数：F(Xn)=a*X^3+b*X^2+c*X+d（三次函数）
		f0 = ((a * x0 + b) * x0 + c) * x0 + d;
		
		//导函数：F`(Xn)=3*a*X^2+2*b*X+c    关于原函数某一点的导函数，其值是该点切线的斜率
		//导数的几何意义就是斜率，求函数在x0处的切线斜率，就是先求出该函数的导数，然后将x0的值代入导数，得到的就是该点的切线斜率。
		f1 = (3 * a * x0 + 2 * b) * x0 + c;
		
		//牛顿迭代公式：Xn+1=Xn - F(Xn)/F`(Xn)
		x1 = x0 - f0 / f1;
	} while (fabs(x1-x0)>=1e-4);//此方程认为|X1-X0|<0.0001是就认为是找到了此方程的根，牛顿迭代法收敛时证明此方程有解，否则此方程无解并且将陷入死循环
	return x1;
}//牛顿迭代法适用于多项式方程求解根的方法

//关于牛顿迭代法的总结：
/*
* 1.牛顿迭代法其实就是一种迭代求方程解的过程，简而为之就是求方程的函数图像与X轴的交点
* 2.迭代原理：
*	（1）以一元二次方程（一元二次函数抛物线）为例，设该函数图像有一点Xn,从该点出发求出点Xn的切线（L1）然后再求出该切线（L1）与X轴的新交点，设为Xn+1；
	（2）再计算新交点Xn+1处的切线（L2），并求出该切线（L2）与X轴的交点并更新Xn+2
	（3）如此往复，最终有一个切线（Lx）与X轴的交点Xn+x

	最后会发现切线与X轴的交点会越来越接近方程的根



	重点：导函数与斜率的理解
	
	1.导数的值是该点处切线的斜率
	
	2.导数又叫导函数，是一个函数，是原来的函数的导函数。
	  导数的几何意义就是斜率，求函数在x0处的切线斜率，就是先求出该函数的导数，然后将x0的值代入导数，得到的就是该点的切线斜率。
	  导数是基于斜率运算的一个极限结果，可以描述图形的连续性，具有图形上单点的描述特征。
	  也就是说，导函数每一点的函数值都是对应于原函数的对应点的切线斜率。
	  而斜率的意义是比较广泛的, 比如抛物线上任意两点连线可以求出一个斜率，但导数不可以这样做。
*/
int main()
{
	execute_fun2();
	return 0;
}