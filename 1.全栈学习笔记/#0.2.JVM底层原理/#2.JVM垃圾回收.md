# JVM垃圾回收

##### :panda_face:Author：MoFany-J

## 何为垃圾回收？

>1. 垃圾回收是指不定时去堆内存中清理不可达对象。不可达的对象并不会马上就会直接回收， 垃圾收集器在一个Java程序中的执行是自动的，不能强制执行，程序员唯一能做的就是通过调用`System.gc()`方法来建议执行垃圾收集器，但其是否可以执行，什么时候执行却都是不可知的。这也是垃圾收集器的最主要的缺点。
>2. 沿着`GC Roots`对象的引用栈去找，扫描整个堆对象的过程中，若发现对象确实被引用（即该对象并非闲置对象），那么它则需要保留。如果没有`GC Roots`直接或间接地引用它（即该对象闲置），那么这个闲置的对象就被当作一个垃圾从而进行回收掉了。
>3. 被`GC Roots`直接或间接引用的对象就会被列入下一次垃圾回收的白名单之中，当下一次垃圾回收来临时不会回收掉被列入白名单中的对象。
>
>#### 为什么要进行垃圾回收？
>
>* 如果不进行垃圾回收，内存迟早都会被消耗空，因为我们在不断的分配内存空间而不进行回收。除非内存无限大，我们可以任性的分配而不回收，但是事实并非如此。所以，垃圾回收是必须的
>
>#### 垃圾回收算法
>
>##### :one:标记清除（Mark Sweep）
>
>1. 特点：
>   - 速度快
>     - 清除操作只需要将垃圾对象内存的起始与结束地址作为一个记录就完成了，无需做更多的额外处理，所以整个垃圾回收的速度相对较快。
>   - 易产生内存碎片
>     - 清除以后不会再对空闲的内存空间做进一步的整理工作量，所以如果分配了一个较大的对象，比如数组在分配时需要一段连续的空间，塞到每一个空白位置都塞不下，但是总的空闲空间是足够分配数组内存的，由于空间不连续（内存碎片），造成了新对象依然不能分配一个有效的空白内存，还是会造成内存的溢出问题。
>2. 执行阶段：
>   - 标记：标记出没有被GC Root直接或间接引用的闲置对象。
>   - 清除：把垃圾对象所占用的空间释放。
>
>##### :two:标记整理（Mark Compact）
>
>1. 特点：
>   - 速度慢
>   - 无内存碎片
>2. 执行阶段：
>   - 标记：标记出没有被GC Root直接或间接引用的闲置对象。
>   - 整理：将被GC Root引用的对象的内存前移，使得内存空间整体变得更为紧凑（将非垃圾对象的内存前移的作用是将非垃圾对象在内存上连成一片，即非垃圾对象的内存是连续的），这样就不会产生碎片了。
>
>##### :three:复制（Copy）
>
>1. 特点：（复制算法将内存分为了两个大小相等的区域，左为From区，右为To区）
>   - 无内存碎片
>   - 需占两倍的内存空间
>2. 执行阶段：
>   - 标记：标记出没有被GC Root直接或间接引用的闲置对象。
>   - 复制：将被一次垃圾回收结束后将From幸存区中任然幸存的对象复制到To幸存区。
>   - 清理（From）：Minor GC垃圾回收时对伊甸园与From幸存区进行垃圾回收，回收掉没有被GC Root引用的闲置对象。
>   - 交换：将To幸存区与From幸存区进行交换
>
>##### :four:可达性分析
>
>1. 可达性算法是目前主流的虚拟机都采用的算法，程序把所有的引用关系看作一张图，从一个节点`GC Roots`开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。
>
>2. Java语言中，可作为`GC Roots`的对象包括下面几种：
>   ● 虚拟机栈中引用的对象（栈帧中的本地变量表）；
>   ● 方法区中类静态属性引用的对象；
>   ● 方法区中常量引用的对象；
>   ● 本地方法栈中JNI（Native方法）引用的对象。

## `HotSpot`垃圾回收原理

>* ##### GC （Garbage Collection：即垃圾回收）的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、老年代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停
>
>  ● 对新生代的对象的收集称为`Minor GC`（`Minor GC`只回收新生代，`Major GC`出现前会触发`Minor GC`）
>  ● 对老年代的对象的收集称为`Full GC`
>  ● 程序中主动调用`System.gc()`强制执行的`GC`为`Full GC`

## 堆中的`新生代`与`老年代`

>#### 新生代`young区`*年龄计数器小于15*
>
>* ###### `80%`eden区`伊甸园`
>
>  * 新生**对象A**，首次`Minor GC`后若存活，则移入`Survivor from区`置年龄为：`1`
>
>* ###### `10%`Survivor from`幸存者s0`
>
>  * 下一次`Minor GC`后**对象A**依旧存活，将通过复制算法移入`Survivor to区`，并使`年龄+1`
>
>* ###### `10%`Survivor to`幸存者s1，始终为空`
>
>  * 又一次`Minor GC`后**对象A**还是存活，此时将通过复制算法交换`Survivor to区`与`Surivior from区`中的幸存者对象，并使这两个区的幸存者对象年龄在原有基础上`+1`
>
>  * 然后按这种顺序往复进行年龄增加：
>
>    * 若在某一次`Minor GC`后**对象A**的年龄达到`15`（默认最大阈值为15，根据垃圾回收器的不同阈值不同）时，则将此对象移入`Old老年代`；
>
>    * 又或者在某一次`Minor GC`后，与**对象A**同龄的对象总占比已经大于整个`Survivor`区的一半时，也将此对象移入`Old老年代`。
>
>#### 老年代`old区`
>
>1. 年龄计数器：若对象在Eden区出生并经过第一次`Minor GC`后仍然存活且能被Survivor区容纳，该对象将被移入Survivor区且年龄设定为1。此后每熬过一次`Minor GC`，年龄就加1，当他的年龄到达一定程度时**（默认为15岁，也可以通过 `-XX:MaxTenuringThreshold`来设定）**，就会被移入老年代。
>
>2. 若Survivor 空间中相同年龄的所有对象大小总和大于Survivor的一半时，则将年龄大于等于x的所有对象直接移入老年代。

## JVM调优参数

>#### 大对象直接进入老年代JVM参数
>
>* `-XX:PretenureSizeThreshold` 直接晋身到老年代的对象大小，设置该参数后，大于该参数值的对象将直接在老年代中分配，目的是为了避免在Eden和Survivor区之间发生大量的内存复制。
>
>#### 自定义进入老年代的对象年龄
>
>* `-XX:MaxTenuringThreshold`	晋身到老年代的对象的年龄，每个对象在经过一次`Minor GC`后，年龄就加1，当超过该参数指定的值时就进入老年代。

# 常见垃圾回收器总结

## 垃圾回收器对比

>#### 新生代垃圾回收器
>
>* Serial`新生代串行垃圾回收器`
>  * 概述
>    * 单线程
>    * 只会使用一个CPU或一个垃圾回收器去完成垃圾回收工作
>    * 进行垃圾回收时，必须要暂停业务线程，直到回收结束
>  * 垃圾回收算法
>    * 采用标记复制算法`只能用于新生代`
>
>* ParNew`新生代并行垃圾回收器`
>  * 概述
>    * Serial回收器的多线程版本
>    * 多个线程进行垃圾回收工作
>    * 进行垃圾回收时，必须要暂停业务线程，直到回收结束
>    * 目前只有它能够与`CMS垃圾回收器`配合工作
>  * 垃圾回收算法
>    * 采用标记复制算法`只能用于新生代`
>  * 特点及使用场景
>    * CPU核数越多，越能发挥其优势和资源利用
>    * 运行在Server模式下的首选新生代垃圾回收器
>
>* Parallel Scavenge`新生代并行垃圾回收器`
>  * 概述
>    * 并行的多线程垃圾回收器
>    * 吞吐量优先，可以精准的控制
>    * `吞吐量=程序运行时间/（程序运行时间+垃圾回收时间）`
>  * 垃圾回收算法
>    * 采用标记复制算法`只能用于新生代`
>
>#### 老年代垃圾回收器
>
>* Serial Old`老年代串行垃圾回收器`
>  * 概述
>    * 单线程垃圾回收器
>    * 主要用于 Client 的 Jvm 回收
>  * 垃圾回收算法
>    * 采用标记压缩算法`只能用于老年代`
>
>* Parallel Old`老年代并行垃圾回收器`
>  * 概述
>    * parallel Scavenge的老年代垃圾回收器
>  * 垃圾回收算法
>    * 采用标记压缩算法`只能用于老年代`
>  * 特点及使用场景
>    * 在吞吐量优先的场景下使用
>
>* Cms`老年代最短响应并发垃圾回收器`
>  * 概述
>
>    * 以最短响应为目标的垃圾回收器
>    * 适用于BS架构的环境
>
>  * 垃圾回收算法
>
>    * 采用标记清除算法`只能用于老年代`
>
>  * 特点及使用场景
>
>    * `优点`并发垃圾回收，低停顿
>
>    * `缺点`cms由于是标记清除算法，会产生内存碎片，故需要加压缩参数
>    * `缺点`无法处理浮动垃圾，可能会出现`ConcurrentModeFailure`失败
>
>#### G1`横跨新生代与老年代的垃圾回收器`
>
>- 概述
>  - 面向服务端的垃圾回收器
>  - G1完全是为了大型应用而准备的
>- 特点
>  - 并行与并发：G1能够充分利用多CPU、多核环境的优势来缩短STW的停顿时间
>  - 分代数：G1垃圾回收器不需要与其他回收器配合就可以独立管理整个堆
>  - 可预测的停顿：这是G1相对于CMS的优势，降低停顿时间是二者共同的关注点，但G1除了降低停顿时间外还能建立可预测的停顿时间模型
>- G1与CMS区别
>  1. G1在压缩空间方面有优势
>  2. G1通过将内存空间分成区域（Region）的方式避免内存碎片问题
>  3. Eden、Survivor、Old区不在固定，在内存使用效率上来说更灵活
>  4. G1可以通过设置预期停顿时间（Pause Time）来控制垃圾回收时间避免应用雪崩现象
>  5. G1在回收内存后会马上同时做合并空闲内存的工作，而CMS默认是在STW（stop the world）的时候做