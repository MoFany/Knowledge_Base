# 常量池一般分为四类

## 类常量池`位于方法区`

>* 一个`.class`文件对应一个类常量池，故类常量池有多个，而运行时常量池在整个JVM中只有一个。
>

## 运行时常量池`位于方法区`

>* 运行时常量池主要存放两类信息：
>  * 字面量
>  * 符号引用
>
>>JVM在加载一个类时要做的事情：
>>
>>1. 通过全限定性名称来读取一个类的字节码文件。`.class`
>>2. 将读入的字节流从静态结构转换成JVM方法区的运行时数据结构。
>>3. 在JVM堆中生成对应的类对象。`java.lang.Class`
>
>* 运行时常量池是方法区的一部分。
>* `.class`文件中含有类的版本、字段、方法、接口等信息，这些信息将会被存放到运行时常量池中。同时JVM还会把原来`.class`文件中描述的符号引用转换成直接引用存储在运行时常量池中。
>
>>符号引用：
>>
>>* 用一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。而在编译的时候一个java类会被编译成一个`.class`文件，但在编译的时候虚拟机并不知道所引用类的地址，所以就用符号引用来代替，而在这个解析阶段就是为了把这个符号引用转换为真正的地址的阶段。
>>
>>直接引用：
>>
>>* 直接引用是可以直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。若有了直接引用，那引用的对象必然已经存在于虚拟机的内存中。
>>
>>句柄：（JVM中有两种主流的访问对象的方式：`直接指针访问`、`句柄访问`）
>>
>>* 直接指针访问：Java中的引用型变量的值就是堆中对象的地址，而这个对象的地址应该包含一个指向方法区中对象类型的数据，这样的优点是直接就能访问到对象本身，速度快。HostSpot就是采用这样的方式实现的。
>>* ==**句柄访问：在Java堆中会划分出一个区域存储句柄池，句柄池会存储对象的地址与对象类型数据的地址，而Java中引用型变量存储的也将会是句柄池的地址。这样的好处是，当对象发生移动时，只需要改变句柄池中的内容就好了。***==
>
>* ==**运行时常量池与类常量池不同，每一个`.class`文件都对应一个类常量池，但运行时常量池只有一份，多个类常量池中相同的字面量只会对应运行时常量池中的一个字面量。**==
>* 运行时常量池可以在运行时通过程序动态生成一些常量放入其中。

## String常量池`1.7后位于堆中`

>* String常量池整个JVM只有一个。
>* String常量池用于存放String类型对象的引用。
>* String常量池的底层是用C++的HashMap实现的，Key是字符串的字面量，Value是字符串对象的引用（HostSpot）。
>
>>原理：
>>
>>1. 当一个String对象被创建的时候，JVM首先根据运行时常量池中相关字面量去String常量池中去寻找是否有对应字符串的引用。
>>
>>2. 若有则直接返回该对象的引用。
>>
>>3. 若没有，那则会在Java堆中创建一个String对象，并且把这个对象的引用保存到String常量池，最后返回这个引用。
>>
>>懒加载：
>>
>>* 通常在字符串的字面量被导入到JVM的运行时常量池时，并不会马上在字符串常量池加入对应的字符串的引用，而是会等到程序实际运行时，在哪要用到这个字面量对应的字符串对象时，才会去字符串常量池中试图获取该字符串对象的引用。
>>
>>`String.intern()`
>>
>>* 判断字符串的字面量是否存在于字符串常量池中，若不存在就直接把这个字符串的引用保存到字符串常量池中去。

## 封装类常量池`位于堆中（在各自的内部类实现）`

>***以下几个包装类在Java中实现了常量池（Double和Float没有）***
>
>* Byte
>* Short
>* Integer
>* Long
>* Character
>* Boolean
>
>***不同包装类常量池的取值范围有限：***
>
>* Byte、Short、Integer、Long : [-128~127]
>* Character : [0~127]
>* Boolean : [True, False]