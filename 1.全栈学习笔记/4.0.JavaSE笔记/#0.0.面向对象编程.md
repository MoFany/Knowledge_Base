# 面向对象编程:japanese_goblin:

## 面向对象的特点：

>1. 抽象（abstract）
>
>   > ***接口（interface）：接口中不能存在普通方法（==接口中的成员变量必须是有值的常量，接口中的方法有 abstract、default、static==），所以是完全抽象的。默认所有方法都是抽象方法，==接口没有构造器，故不能实例化对象，必须被某一个类实现，然后创建接口的引用型变量指向实现类的实例化对象（向上转型）。==***
>   >
>   > 1. 接口的定义：
>   >    + ***接口不存在构造方法***。
>   >    + 接口使用interface关键字修饰定义。
>   >    + 接口中所有的属性与行为都是公共的，即被public修饰的属性与行为。
>   >    + 接口中的成员变量默认为：public static final（可以省略）
>   >    + 接口中的成员方法默认为：public abstract（可以省略）
>   >    + 接口中允许的成员方法：public default、public static（Jdk_1.8以后出现）
>   >    + 接口中的default默认方法可以选择性的被实现类重写，若不重写就是用接口中定义的默认方法。
>   >    + 接口中的static静态方法不用被实现类重写，其属于接口自身。
>   > 2. 接口的实现：
>   >    + 接口与类是实现关系。
>   >    + 接口通过关键字implements被一个类实现。
>   >    + 多个接口可以被同一个类实现，类与接口的实现关系是一对多。
>   >    + 接口被一个类实现时，该类必须实现（重写）接口中的所有抽象方法。
>   >    + 多个接口被一个类实现时，多个接口中的抽象类会出现叠加效应，即实现类必须实现所以的抽象方法。
>   > 3. 接口的继承：
>   >    + 接口与接口之间是继承关系。
>   >    + 接口之间的继承通过extends关键字。
>   >    + 一个接口可以继承自多个接口，即接口之间的继承关系是一对多。
>   >
>   > ==***一个类继承自另一个类的同时也可以实现自一个或多个接口。***==
>   >
>   > ==***接口是用于实现类与类只能单重继承这个不足的，因为在 C++中类与类之间是可以多重继承的。***==
>
>   > 抽象类：**半抽象，抽象类可以声明普通方法**，抽象类有构造器，但是不能实例化对象。
>   >
>   > + 抽象类不一定必须有抽象方法。
>   > + 抽象类中可以存在静态（static）属性与行为。
>   > + **抽象父类中的构造器，是提供给子类获取父类特征使用的。**
>   > + 一个类继承抽象类后必须重写抽象类中的所有抽象方法。
>   > + **抽象类也可以作为子类继承非抽象的类。**
>   > + 抽象类之间发生继承关系时，子抽象类不用去重写父抽象类的抽象方法，两个抽象类中所有抽象方法会产生叠加效应；若子抽象类被一个非抽象类继承，那这个非抽象子类必须重写继承链上的所有抽象类的抽象方法。
>
>   > 抽象方法：由abstract关键字声明，只有方法声明没有方法实现（方法体），**抽象方法只能存在于抽象类中**。
>
>2. 继承（Inheritance） 
>   + 同类（class与class之间、interface与interface之间）属于extends，不同类型（class与interface之间）属于implements。
>   + 编程中将多个类所共有的属性与行为抽取出来生成一个公共的类（父类），再让需要这些属性与行为的类去继承（使用extends关键字）父类，这些类成为父类的子类，那么此时这些子类具有了父类的属性与方法。
>   + Java属于单重继承，即一个子类只能继承对应的一个父类，而一个父类可以被多个子类所继承。
>   + this关键字代表当前类或当前类子类的实例化对象，具体的谁用就是谁，this回去堆空间中找寻其中保存的地址值从而用来匹配堆中的具体对象。
>
>3. 封装
>
>项目封装：项目的业务封装到一个项目中，maven分模块。
>
>包的封装：相同业务的代码封装到同一个包中。
>
>属性的封装：属性是类的细节的描述，属性要进行私有化。
>
>>+ 安全：不能随意的去访问，如果要访问，要使用类提供的属性的公开的访问方式getters和setters方法。**getXXX（）和setXXX（）**
>>+ 解耦（在java开发中，终身努力做到的特性），为了实现**“ 高内聚，低耦合 ”**。
>>  + **高内聚**：就是将一个类的特性与方法尽量写在一个类中，还要隐藏细节，需要外部访问的提供公开的访问方式。
>>  + **低耦合**：藕断丝连，低耦合就是尽量不要丝连，减少编程中的硬编码（通过反射可以解决，如平时我们尽量不要在代码中实例化太多对象，而应该什么时候需要实例化对象就在什么时候实例化对象，即动态的去实例化对象）。
>
>方法封装：通过访问修饰符和修饰符封装的方法，提供类的行为与描述。
>
>构造方法封装：构造方法是实例化对象的模版，封装的多个模块，可以提供实例化对象的快捷分配内存方式。
>
>4. 多态：
>   + **方法重写，即子类重写父类中与自身相关的方法（子类重写父类方法后，重写的子类继承父类的方法将覆盖父类原方法）。**
>
>   ```java
>   /**
>    * 父类
>    */
>   class SuperClass{
>   	public void print(){
>   		System.out.println("I am SuperClass!")
>       }
>   }
>   
>   /**
>    * 子类
>    */
>   public class SubClass extends SuperClass{
>       //重写父类的方法，重写（覆盖）只能在子类继承父类时进行
>       @Override
>       public void print(){
>   		System.out.println("I am SubClass!")
>       }
>   }
>   ```
>
>   + **父类的引用指向子类的实例化对象。**
>
>   > ***向上转型：子类的对象赋值给父类类型的变量；***
>   >
>   > *Java中父类的引用型变量可以指向子类的实例化对象，是因为子类被认为是与父类兼容的类型。*
>
>   > ==***编译看左（父类引用型变量），运行看右（子类实例对象）;***==
>
>   ```java
>   package polymorphism;
>   
>   /**
>    * @author MoFany-J
>    * @date 2022/9/22
>    * @description People
>    */
>   abstract class People{
>       /**
>        * 抽象类的抽象方法由子类实现
>        */
>       public abstract void strength();
>       /**
>        * 抽象类中的非抽象方法
>        * */
>       public void run(){
>           //this 父类引用指向子类实例对象（多态：作为当前调用者对象使用）
>           this.strength();
>       }
>   }
>   ```
>
>   ```java
>   package polymorphism;
>   
>   /**
>    * @author MoFany-J
>    * @date 2022/9/22
>    * @description Man
>    */
>   class Man extends People{
>       /**
>        * 抽象类的抽象方法由子类实现
>        */
>       @Override
>       public void strength() {
>           System.out.println("力量值：100%！");
>       }
>   }
>   ```
>
>   ```java
>   package polymorphism;
>   
>   /**
>    * @author MoFany-J
>    * @date 2022/9/22
>    * @description Woman
>    */
>   class Woman extends People{
>       /**
>        * 抽象类的抽象方法由子类实现
>        */
>       @Override
>       public void strength() {
>           System.out.println("力量值：80%！");
>       }
>   }
>   ```
>
>   ```java
>   package polymorphism;
>   
>   /**
>    * @author MoFany-J
>    * @date 2022/9/22
>    * @description MainClass
>    */
>   public class MainClass{
>       public static void main(String[] args){
>           //父类引用指向子类实例对象
>           People man=new Man();
>           man.strength();
>           People woman=new Woman();
>           woman.strength();
>           System.out.println("-----------------");
>           //父类引用指向子类对象
>           man.run();
>           woman.run();
>       }
>   }
>   ```
>
>   ```
>   力量值：100%！
>   力量值：80%！
>   -----------------
>   力量值：100%！
>   力量值：80%！
>   ```
>
>   > 多态的优点（接口总是这样实例化）：消除类型之间的耦合关系、增加代码复用率、简洁等。
>   >
>   > **在往后的实际开发中我们常用到的是接口的多态！**

## 类与对象：

>>类：由成员属性与成员方法构成，用于描述一类事物的抽象概念。
>
>>对象：类的具体体现，类的实例化表达
>>
>>+ 匿名对象是没有名字的对象，其只能使用一次。
>>+ 匿名对象在使用一次后就被GC回收了。
>>
>>**开辟对象时：栈内存线程独享(对象名)，堆内存线程共享（匿名对象）**

### ==内部类：==

> 定义在一个类内部的类称为内部类，即==**类可以嵌套定义（内部类可以使用类的成员修饰符）**==
>
> 内部类也可以继承一个类，内部类也可以实现接口。
>
> #### 普通内部类（作为成员定义在类中的成员类就称为：成员内部类）
>
> > * 实例化内部类的对象:
> >
> >   ==**外部类对象.内部类 内部类引用型变量=new 内部类构造器();**==
> >
> > * 内部类中访问外部类的成员属性或方法：
> >
> >   ==**外部类.this.外部类成员**==
> >
> > * 内部类可以声明为`private`或`protected`。
> > * 内部类若用`final`修饰，则表明该内部类不能被继承。
> > * 内部类可以定义为`abstract`，但需要被其它内部类继承或实现。
> > * 内部类也可以是一个接口，但该接口必须由另一个内部类实现。
> > * 内部类名不能与外部类名相同。
> > * 内部类不但可以在类中定义还可以在程序块内定义。（方法与循环体内部都可以定义内部类，**方法中定义的内部类只能访问方法中的final类型的局变量**）
> > * **内部类既可以访问外部类的成员变量，包括静态成员变量和实例成员变量，也可以访问内部类所在方法的局部变量。**
> > * ==**内部类若被static修饰，则静态内部类将自动转化为“顶层类”（即其没有父类），而且不能引用外部类的成员或其他内部类中的成员（静态内部类比较独立）。非静态内部类不能声明静态成员，只有静态内部类才能声明静态成员。**==
>
> ```java
> /**
>  * 定义外部类
>  */
> class OuterClass{
> 	/**
> 	 * 定义普通内部类（外部类的成员内部类）
> 	 */
>     public class InnerClass{
> 		...Class body...
>     }
> }
> ```
>
> #### 静态内部类（static关键字修饰的内部类，类的成员静态内部类）
>
> > * ==**静态内部类的类成员（静态成员）可直接通过类名访问。**==
> >
> >   ```java
> >   /**
> >    * 定义外部类
> >    */
> >   public class OuterClass{
> >   	/**
> >   	 * 定义静态内部类（外部类的成员内部类）
> >   	 * 静态内部类在外部类加载时已经被类加载器加载到内存之中了
> >   	 */
> >       public static class InnerClass{
> >           /**
> >            * 静态内部类的类方法（静态方法）
> >            */
> >           public static void test(){
> >               
> >   			System.out.println("Hello World!");
> >           } 
> >   	}
> >       
> >       /**
> >        * 定义main()方法
> >        */
> >       public static void main(String[] args){
> >           
> >           //类名.类成员
> >           InnerClass.test();
> >       }
> >   }
> >   ```
> >
> > * ==**静态内部类的实例成员依旧得通过静态内部类的实例化对象去调用。**==
> >
> >   ```java
> >   /**
> >    * 定义外部类
> >    */
> >   public class OuterClass{
> >   	/**
> >   	 * 定义静态内部类（外部类的成员内部类）
> >   	 * 静态内部类在外部类加载时已经被类加载器加载到内存之中了
> >   	 */
> >       public static class InnerClass{
> >           /**
> >            * 静态内部类的实例方法
> >            */
> >           public void test(){
> >               
> >   			System.out.println("Hello World!");
> >           } 
> >   	}
> >       
> >       /**
> >        * 定义main()方法
> >        */
> >       public static void main(String[] args){
> >           
> >           //实例化静态内部类
> >           InnerClass obj=new InnerClass();
> >           //对象.实例成员
> >           obj.test();
> >       }
> >   }
> >   ```
> >
> > * **外部类加载时会提前加载外部类中被static修饰的成员静态成员属性、静态成员方法、静态成员内部类。**
> >
> > * **只有静态内部类才能声明静态成员，且静态内部类是顶层类故其没有父类，静态内部类不能引用外部类的成员和内部类的成员。**
>
> ```java
> /**
>  * 定义外部类
>  */
> class OuterClass{
> 	/**
> 	 * 定义静态内部类（外部类的成员内部类）
> 	 */
>     public static class InnerClass{
>         
>         ...Class body...
> 	}
> }
> ```
>
> #### 局部内部类（方法中定义）
>
> > * 方法中可以定义类，称为局部内部类。
> >
> > * 局部内部类只能在当前方法中使用。
>
> ```java
> /**
>  * 定义外部类
>  */
> class OuterClass{
>     /**
>      * 定义外部类的成员方法
>      */
>     public void test(){
> 		
>         //方法中定义局部作用域下的内部类
>         class InnerClass{
>             
> 			...Class body...
>         }
>     } 
> }
> ```
>
> #### 匿名内部类（没有名字的内部类，类的成员匿名内部类）
>
> > * 定义类的同时创建该类的一个对象，以这种方式定义的类无需起名，故称之为内部类。
> >
> > * ==**匿名内部类不能使用修饰符，也不能定义构造方法，因为匿名内部类没有名字，正是这个原因在创建对象时也不能带参数，因为默认构造方法没有参数。**==
> >
> > * **匿名内部类中不能声明static成员变量与static成员方法，因为==非静态内部类不能声明静态成员，只有静态内部类才能声明静态成员。==**
> >
> > * 匿名内部类应该与所实现的接口或者所继承的父类同名。（匿名内部类必须继承一个父类，或实现一个接口）
> >
> > * 建立匿名内部类时会立即创建该类的实例，这个类定义即立即消失，**没有引用型变量去接收匿名内部类对象的地址时，该匿名内部类无法重复使用。**
> >
> >   ```java
> >   /**
> >    * 此时的匿名内部类只能使用一次，构造器的名字应与所继承类名或所实现的接口名同名
> >    */
> >   new 实现接口() | 父类构造器(){
> >   
> >   	...Class body...
> >   
> >   }
> >   ```
> >
> > * 定义匿名内部类时直接用其父类的名字或它所实现接口的名字。
> >
> > * ==**匿名内部类必须是继承自一个父类或实现自一个接口，但不能用extends关键字或implements关键字。**==
> >
> > * ***匿名内部类不能同时继承一个类又实现一个接口，也不能实现多个接口。***
> >
> > * **匿名内部类总是使用它父类的无参构造方法来创建一个实例；若匿名内部类实现的是一个接口，则调用的构造方法是Object()。**
> >
> > * **匿名内部类可以定义自己的方法，也可以继承父类的方法或重写（覆盖）父类的方法。**
> >
> > * ==***匿名内部类必须实现（重写）父类或接口中的所有抽象方法。***==
> >
> > * ==***匿名内部类的父类可以是一个抽象类。***==
> >
> >   ```java
> >   package innerclass;
> >   
> >   /**
> >    * @author MoFany-J
> >    * @date 2022/9/27
> >    * @description AbstractFather 抽象父类
> >    */
> >   abstract class AbstractFather {
> >       /**
> >        * 匿名内部类所要实现的抽象方法
> >        * */
> >       public abstract void print();
> >   }
> >   ```
> >
> >   ```java
> >   package innerclass;
> >   
> >   /**
> >    * @author MoFany-J
> >    * @date 2022/9/27
> >    * @description InstanceSub
> >    */
> >   public class InstanceSub {
> >       /**
> >        * 匿名内部若继承自一个抽象类，则要重写抽象类中所有抽象方法
> >        * */
> >       AbstractFather abstractfather=new AbstractFather(){
> >           //实现抽象父类的抽象方法
> >           @Override
> >           public void print() {
> >   
> >   			...Method body...
> >           }
> >       };
> >   }
> >   ```
> >
> > * 由于==**匿名内部类**==返回的是一个对象的引用，故可以直接使用或将其赋给一个引用型变量，从而来复用匿名内部类。
> >
> >   * **反复多次使用的匿名内部类：**
> >
> >   ```java
> >   class OuterClass{
> >       /**
> >        * 可多次使用：将匿名内部类返回的对象引用赋值给一个引用型变量
> >        */
> >   	InnerClass obj=new InnerClass(){
> >   
> >   		...Class body...
> >   
> >   	}
> >   }
> >   ```
> >
> >   * **仅能使用一次的匿名内部类：**
> >
> >   ```java
> >   class OuterClass{
> >       /**
> >        * 只能使用一次：因为返回的的对象引用无任何引用型变量可以接收
> >        */
> >       new InnerClass(){
> >   
> >   		...Class body...
> >   
> >   	}
> >   }
> >   ```
> >
> > * 还可以将匿名==**内部类对象**==作为方法调用的参数。
> >
> >   ```java
> >   //匿名内部类对象作为方法调用的实参
> >   someMethod(new TypeName(){
> >   
> >   	...Class body...
> >   
> >   });
> >   ```
> >
> > * 使用匿名内部类时，必然是在某个类中直接使用匿名内部类创建对象，所以**匿名内部类一定是内部类**，匿名内部类可以访问外部类的成员变量和成员方法。
> > * *在文件管理方面，匿名内部类在编译完成之后，所产生的文件名称为：***`外部类名$编号.class`**
> > * 因为匿名内部类没有类名，所以无法定义匿名内部类的构造器；但是匿名内部类可以定义初始化块，通过实例化初始 化块来完成构造器所需的事情。
>
> #### Lambda表达式
>
> > ==**(参数列表)->{语句与返回值};**<------这个东西相当于一个函数式接口的实例或函数式接口的匿名内部类对象==
> >
> > lambda表达式与函数式编程相关联。
> >
> > lambda表达式可作为参数使用。
> >
> > ==**Lambda表达式的使用：**==
> >
> > > * Lambda表达式与函数式接口息息相关，==**函数式接口就是只包含一个抽象方法且被注解@FunctionalInterface修饰，但是函数式接口除了抽象方法外还可以包含任意任意个默认方法与类方法（static修饰的方法）。**==
> > > * <font style="color:red;">**Lambda表达式中的方法体只有一条语句时，花括号可以省略。**</font>
> > > * <font style="color:red;">**Lambda表达式中的参数列表中若只有一个参数时，参数类型、圆括号都可以省略。**</font>
> > > * <font style="color:red;">**Lambda表达式中的参数列表中有多个同一类型的参数时，只有参数类型可以省略。**</font>
> > > * <font style="color:red;">**Lambda表达式中的方法体中只有返回值，此时return关键字与方法体花括号同时省略。**</font>
> >
> > ==**方法引用与构造器引用**==
> >
> > > * 利用“ :: ”**双冒号**调用方法，输出参数所要执行的操作。
> > >
> > > * 方法引用是一个Lambda表达式。
> > > * 如果Lambda表达式的代码块中只有一体代码，此时可以使用方法引用或构造器引用。
> > >
> > > * 使用前提是对象与成员方法都已经存在，此时就可以使用**对象::成员方法**的方式引用成员方法。
> >
> > | 格式               | 种类                   | 说明                                                         | 对应的Lambda表达式                     |
> > | :----------------- | :--------------------- | :----------------------------------------------------------- | :------------------------------------- |
> > | 类名::类方法       | 引用类方法             | 函数式接口中被实现方法的全部参数传给该类方法做为参数         | (a,b,...)->类名.方法名(a,b,...)        |
> > | 特定对象::实例方法 | 引用特定对象的实例方法 | 函数式接口中被实现方法的全部参数传给该方法做为参数           | (a,b,...)->特定对象.实例方法(a,b,....) |
> > | 类名::实例方法     | 引用某类对象的实例方法 | 函数式接口中被实现方法的第一个参数作为调用者，后面的参数全部传给该方法作为参数 | (a,b,...)->a.实例方法(b,...)           |
> > | 类名::new          | 引用构造器             | 函数式接口中被实现方法的全部参数传给该构造器作为参数         | (a,b,...)->new 类名(a,b,...)           |
> >
> > ==**Lambda表达式的缺点**==
> >
> > >* ==**Lambda表达式的目标类型必须是类型明确的函数式接口。**==
> > >
> > >* ==**Lambda只能为函数式接口创建对象，Lambda表达式只能实现一个方法，因此它只能为只有一个抽象方法的函数式接口创建实例。**==
> >
> > ==***保证 Lambda表达式的目标类型是一个明确的函数式接口的三种方式***==
> >
> > >* ==**将Lambda表达式赋值给函数式接口的引用型变量。（直接创建函数式接口的实例）**==
> > >
> > >  > 函数式接口名 变量名=Lambda表达式；
> > >
> > >* ==**将Lambda表达式作为函数式接口类型的参数传给某个方法。（函数式接口的引用型变量作为某方法的形式参数，此时Lambda表达式则是方法调用时传入的实际参数）**==
> > >
> > >* ==**使用函数式接口类型对Lambda表达式进行强制类型转换。（强转Lambda表达式）**==
> > >
> >
> > *接口作为参数使用*
>
> **JDK1.8提供的新函数式接口**
>
> >* ***`Predicate` 函数式接口扩展：xxxPredicate***
> >* ***`Consumer `函数式接口扩展：xxxConsumer***
> >* ***`Function` 函数式接口扩展：xxxFunction***
> >* **`Supplier` 函数式接口扩展：xxxSupplier***

### 构造方法：

>1. 将成员属性原始默认值覆盖，而不是成员属性类型规定的默认值。
>
>2. 构造方法的方法名与类名相同。
>
>3. **每一个类中都有一个默认无参的空构造方法**。
>
>4. **构造方法中方法体的this代表调用该构造方法的当前对象。**
>
>5. 重载的构造方法中调用（方法体第一行）同类中的另一构造方法用：this(参数列表)
>
>6. 子类的构造方法中调用父类的构造方法在方法体的第一行用：super(参数列表)
>
>7. 子类构造器第一行使用：super(参数列表)调用父类构造器的注意事项：
>
>   - super代表父类的引用,一般在任意类的构造器的第一行都默认有一个super()（隐式的,一般情况下可以省略）代表调用父类无参数的构造器，但是含有this()的构造方法情况比较特殊。
>
>   - Java中所有的类均是Object类的子类，故在所有类的默认构造器第一行都隐式含有super()，所有的类对象以及数组都可以使用Object类的方法。
>
>8. 子类可通过关键字super在构造器之外直接调用父类公共的属性与方法：（此时的super代表父类的引用）
>
>   - super.父类成员属性
>   - super.父类成员方法（）
>
>9. 在同一构造方法中方法体内只能存在this(参数列表)/super(参数列表)其中一个，且必须在方法体中的第一行。
>
>***若一个类中没有特定指明该类的无参构造器而给出了有参构造器，则此时有参构造器将会覆盖无参构造器。***

### this关键字与super关键字 ==可以用在任何方法中==：

>- this是一个对象中隐藏的引用变量，它保存了当前对象的内存地址，指向自身。也就是this代表当前类的对象，this存储在堆内存当中对象的内部。
>
>- this  只能在实例方法中使用。
>
>- super 是指向父类的引用
>
>- spuer.toString()与this都在当前类方法中输出时（都代表当前类的对象），会发现两者的地址值一样。
>
>- super  不能在静态上下文中引用，不然会出现编译错误。
>
>- super  关键字可以在构造器之外的方法中调用父类的属性与方法。

### this()与super() ==都只能用于构造方法内==：

>- this(参数列表)用于重载的方法间的调用，只能用于当前类的构造器出现重载时去调用当前类的指定构造器，但是具体调用哪一个构造器则由其调用参数中的实际参数的类型与相应重载构造器中形参类型去匹配。
>
>- super(参数列表) 用于在当在类的构造器中去调用父类的构造器，至于具体调用哪一个构造器，则由其调用参数中的实际参数的类型与父类构造器的形参去匹配。
>
>- super()  出现在构造器第一行时，意味着我们在实例化对象时必须先去父类中查看父类的特性，Java类中默认继承自Object，所以实例化对象就先拥有了Object类的特性，Object是java中类层次的根类，所有的类包含数组都可以使用Object类的方法。Object只有一个无参的构造器，所以Java中所有类都可以使用无参数的构造器去实例化对象。
>
>- this()、super()都位于构造方法第一行，且只能出现一个，不然会起冲突。

### 方法的重写

>1. 子类可以重写（覆盖）继承自父类的方法，要利用一个注解@Override来标识子类中某个方法是重写自其父类。
>
>2. 重写自父类的方法其方法声明完全与父类一致，只有方法实现不同。

### 重写Object类的toString()方法

> toString()方法是Object类提供的，**表示对象的字符串表示**，***由当前对象所属类的全限定性名称@无符号的十六进制的哈希值组成*** ：**getClass().getName()+‘@’+Integer.toHexString(hashCode())**
>
> ***类的全限定性名称：指类所在的完整包名+类名***

- toString()方法的底层源码（Object类中的toString()方法）：

```java
public String toString() {
	return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

- **Object文档中说明建议所有的子类去重写此方法：**

> > 我们明确的直到对象在调用toString()方法时就会输出对象的字符串表示，也就是对象的地址值。我们的关注点不应该在地址值而应该在堆内存中存储的值，堆内存中存储的就是对象的属性值。
>
> 1. 没有继承关系的类可以直接去重写toString()方法。
> 2. 没有继承关系的类，父类重写toSting()方法子类就可以直接使用。
> 3. 可以使用IDE的快捷键自动生成toString()方法的重写：
>    - Eclipse 中是alt+shift+s
>    - IDEA 中是alt+insert

### equals()方法与==的区别:

>+ 当==作用到两个基本数据类型的变量时是值的比较，当其作用到两个引用数据类型的变量时比较的是这两个引用数据类型变量在堆中的首地址。
>+ Object类的equals()方法是用于判断两个对象的地址值是否相等，equals()方法在Object中的源码依然是用==实现的。
>
>> <font style="color:red;">***由于Object类中equals()方法依然用==实现，由此我们发现只有在两个引用型变量指向堆内存中同一块地址时才返回true，此时其实就是同一个对象的比较，这样的使用不符合我们的要求！***</font>
>>
>> <font style="color:red;">一般比较的两个对象都是通过new关键字实例化的对象，每new一次JVM就在堆内存中创建一块空间用以表示当前new的对象，故：凡是通过new关键字实例化的两个对象不可能存在相等性，故此时我们调用equals()方法的返回值始终是false。</font>
>>
>> <font style="color:red;">在我们已经知道比较的两个对象的地址值不相等的情况下，我们更应该注重细节的比较。所以在两对象堆内存地址值不相等的情况下，我们一般会比较这两个对象的属性值是否相等，相等返回true，否则false！故此时我们就需要重写equals()方法。</font>

### equals()方法与hashCode

+ Object类中定义的equals()方法：

```java
/**
 * 直接判断当前调用这个方法的类对象this是否与对象obj指向堆中同一块地址；
 * 即判断两对象地址值是否相等。
 * */
public boolean equals(Object obj) {
    return (this == obj);
    //Obejct中equals的源码底层依然使用的是==去比较对象,并且只能是同一个对象比较的时候才返回true
}
```

>**用于表示其他对象是否“等于”当前这个对象**
>
> equals 方法在非空对象引用上实现等价关系：
>
>+ 它是**自反的**：对于任何非空引用值 x，x.equals(x) 应该返回 true。
>
>+ 它是**对称的**：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应该返回 true。
>
>+ 它是**可传递的**：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true 并且 y.equals(z) 返回 true，则 x.equals(z) 应该返回 true。
>
>+ 它是**一致的**：对于任何非空引用值 x 和 y，x.equals(y) 的多次调用始终返回 true 或始终返回 false，前提是没有修改对象上 equals 比较中使用的信息。对于任何非空引用值 x，x.equals(null) 应该返回 false。 
>
>Object 类的 equals 方法实现了对象上最有区别的可能等价关系；也就是说，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象（x == y 的值为 true）时，此方法才返回 true。***请注意，每当重写equals()方法时，通常都需要重写 hashCode 方法，以维护 hashCode 方法的一般约定，即相等的对象必须具有相等的哈希码。***

+ String类中重写的equals()方法（**用于比较两个String对象更细节的对象属性值是否相等**）：

```java
/**
 *该值用于字符存储
 **/
private final char value[];
/**
 *每创建一个带具体值的字符串对象，就会将该字符串的一个副本作为字符数组保存在字符数组value中
 */
public String(char value[]) {
	this.value = Arrays.copyOf(value, value.length);
}
/**
 *用于两字符串的比较
 **/
public boolean equals(Object anObject) {
    //当前对象与比较的对象是否是同一个对象
    if (this == anObject) {
    	return true;
    }
    //当前对象与比较对象是不是都是同一个类的实例
    if (anObject instanceof String) {
        //将比较对象强转
        String anotherString = (String)anObject;
        //字符串数组value中存储的是当前调用该方法的String类的对象实际值的副本
        int n = value.length;
        //判断两字符串的长度是否相同
        if (n == anotherString.value.length) {
            char v1[] = value;
            //将比较对象副本的字符数组表示赋值给另一字符数组
            char v2[] = anotherString.value;
            int i = 0;
            //两字符串长度一致时，就会判断对应位置上的字符是否相等
            while (n-- != 0) {
                //两字符串同一位置上的字符如有不相等，就返回false
                if (v1[i] != v2[i]){
                    return false;
                }
                i++;
            }
            return true;
        }
    }
    return false;
}
```

>在API中规定: 
>
>- 当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明**相等对象必须具有相等的哈希码**
>
>hashCode 的常规协定是：
>
>-  如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果
>
>>**重写规范：**
>>
>>1. **重写hashCode()方法应该返回的是：对象属性（all）的hash值的和**
>>2. **常规的做法就是乘一个数在加一个 数，以确保属性值不相等的时候hashCode值绝对不相等**
>>
>>> ***解决重写hashCode()方法时遇到的不同对象的的hashCode返回值不同：***
>>> ***给对象所有属性的 hash值之和，最后在乘一个数加一个数***
>
>```java
>@Override
>    public int hashCode() {
>        
>        //解决方法：给对象所有属性的hash值之和，最后在乘一个数加一个数
>        return age + name.hashCode() * 3 + 1;
>       
>        //假设若出现：
>        //情况1：age为2------name.hashCode()为8 ===> hashCode：2+8=10
>        //情况2：age为3------name.hashCode()为7 ===> hashCode：3+7=10
>        //规范规定只有相同的对象才具有相同的hashCode值，即不同的对象hashCode值应该不一样
>    }
>```
>

+ Object类（所有类的祖先类）中定义的hashCode()方法：

```java
/**
 * native声明该方法是一个外部发方法通常由c/c++编写
 */
public native int hashCode();
```

+ 利用Objects工具类去使用hash()方法：

```java
/**
 * Objects工具类中声明的方法
 * 返回输入值序列的散列值
 */
public static int hash(Object... values) {
    return Arrays.hashCode(values);
}
/**
 * Arrays类中声明的方法
 * 用于返回一个对象的hashCode
 */
public static int hashCode(Object a[]) {
    //如果当前对象为空，则直接返回hashCode为0
    if (a == null){
		return 0;
    }
    int result = 1;
    for (Object element : a){
        //对象所有属性的hashCode之和乘一个数再加上一个数
		result = 31 * result + (element == null ? 0 : element.hashCode());
    }
    return result;
}
```

+ String类中重写的hashCode()方法源码：

```java
public int hashCode() {
        int h = hash;
        if (h == 0 && value.length > 0) {
            char val[] = value;

            for (int i = 0; i < value.length; i++) {
                //乘一个数然后再加上一个数
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }
```

### instanceof关键字:ideograph_advantage:

> new Object() instanceof Object
>
> > 结果：true
>
> > 作用：
> >
> > instanceof 运算符的**前一个操作符是一个引用变量,后一个操作数通常是一个类或接口,用于判断前面的对象是否是后面的类、子类、实现类的实例。如果是返回true**,否则返回false。 
>
>  ***使用 instanceof关键字做判断时, instanceof 操作符的左右操作数必须有继承或实现关系。***

### static关键字

> 通过javac将xx.java文件便以xxx.class文件交给jvm去解析和运行，jvm在解析和运行xx.class文件的时候先由ClassLoader(类加载器)去加载我们的类到运行内存中。在加载类的时候,就要为我们特殊的字段去分配内存，特殊就是使用static修饰的变量或方法等，在类被JVM的ClassLoader加载的时候就被放置到了静态区中，并且有且只有一份。其属于当前类(称之为类变量、类方法)，可以被类的所有的实例化对象所共享。 
>
> static是修饰符：
>
> - 可修饰变量，被static修饰的变量称为类变量。
> - 可修饰的方法，被static修饰的方法称为类方法。
> - 可修饰内部类，被static修饰的内部类称为静态内部类。
> - static修饰的变量或方法，不建议去用类的实例对象的方式去访问，而我们通常使用类名.静态成员的方式去访问类变量与类方法。
> - 构造器中不能使用static关键字。
> - static所修饰的类成员应该是公共的（但不是public的依然可以是private的），可以被所有对象所共享的。
> - static静态代码块及static修饰的类成员，再类加载是被载入内存并完成各种初始化，但这种载入只有在类被加载时装入内存一次。
> - 在static方法中不能直接调用实例变量，实例变量属于对象必须利用对象去调用。
> - 在非static方法中可以直接使用类的静态成员。
> - 在发生继承时，子类不能重写父类的private方法与static方法，因为private与static都属于父类本身的内容。
>
> >发生继承时，可以在子类中直接使用super关键字调用父类静态属性与方法。
> >
> >- super.类变量
> >- super.类方法
>
> **static final 修饰的成员变量是常量，其值不能被改变。（静态的最终的变量）**
>
> **static final 修饰发方法是不能被子类继承与重写的方法。（静态的最终的方法）**
>
> ***被关键字 final所修饰的方法属于最终方法，最终方法不能被子类重写***
>
> ==***被 final关键字修饰的引用型变量，其指向的实例对象在堆内存中的地址值不能改变（即，我们不能让被 final所修饰的引用型变量指向不同的实例对象），但是对象的属性值可以变***==

### 单例（单例设计模式）:closed_lock_with_key:

>+ JavaSE高级部分，设计模式中使用工厂与单例的设计模式去进行编程开发。
>+ 这是一种编程模式，因为我们在编程中封装好了类之后，就需要通过new关键字去实例化对象，每使用一次new关键字就会实例化一个对象，这样对内存带来了巨大的消耗。
>
>> 此时我们就需要另外一种编程模型，在这种模式下我们只需要调用类中写好的方法，让其动态的为我们创建对象，即哪里需要就在哪里创建。static修饰的变量属于类，其在堆中只有一块内存空间被所有的类实例所共享着。
>>
>> + 而被static修饰的对象同样也是类的变量，即static修饰的对象在内存中只占独有的一份。
>
>**static所修饰的对象就属于单例(Singleton)的，单例模式就是使用工厂化的思想去生产对象。**
>
>```java
>package Singleton;
>
>import java.util.Objects;
>
>/**
> * @author MoFany-J
> * @date 2022/9/22
> * @description Base 当前包下类的基本类
> */
>class Base {
>    /**
>     * 实例成员变量
>     * */
>    private int age;
>    private String name;
>    /**
>     * 无参构造方法
>     * */
>    public Base() {
>    }
>    /**
>     * 实例成员变量的get与set方法
>     * */
>    public void setAge(int age) {
>        this.age = age;
>    }
>    public void setName(String name) {
>        this.name = name;
>    }
>    public int getAge() {
>        return age;
>    }
>    public String getName() {
>        return name;
>    }
>    /**
>     * 重写toString()方法，其用于返回调用者的属性值
>     * */
>    @Override
>    public String toString() {
>        return "BaseClass{" + "age=" + age + ", name='" + name + '\'' + '}';
>    }
>}
>
>```
>
>+ **懒汉式：比较懒，只有在某次使用的时才去实例化对象。(非线程安全)**
>
>```java
>package Singleton;
>
>/**
> * @author MoFany-J
> * @date 2022/9/22
> * @description LazyFactoryBase 工厂1：懒汉模式（啥时候饿了啥时候做）
> * 利用懒汉模式创建Base类的实例
> */
>class LazyFactoryBase {
>    /**
>     * 懒汉
>     * */
>    private static Base base=null;
>    /**
>     * 私有无参构造方法
>     * */
>    private LazyFactoryBase() {
>    }
>    /**
>     * 共有的：获取实例的方法
>     * 若要线程安全得使用synchronized关键字声明该静态方法成为同步方法
>     * */
>    public static Base getInstance(){
>        //多线程，若当前base对象不为空就证明有其它线程正在使用该对象
>        if(base==null){
>            base=new Base();
>        }
>        return base;
>    }
>}
>```
>
>+ **饿汉式：比较饿，提前实例化好对象并加载到内存中，在有需要的时候直接用。（非线程安全）**
>
>```java
>package Singleton;
>
>/**
> * @author MoFany-J
> * @date 2022/9/22
> * @description HungerFactoryBase 工厂2：饿汉模式（提前做好饿了就吃）
> * 利用饿汉模式创建Base类的实例
> */
>class HungerFactoryBase {
>    /**
>     * 饿汉
>     * */
>    private static Base base=new Base();
>    /**
>     * 私有无参构造方法
>     * */
>    private HungerFactoryBase() {
>    }
>    /**
>     * 公有的：获取实例的方法
>     * 若要线程安全得使用synchronized关键字声明该静态方法成为同步方法
>     * */
>    public static Base getInstance(){
>        return base;
>    }
>}
>```

### 访问修饰符

> java是一门安全的编程语言，在底层的JVM进行运行的检测机制和访问机制中，提供访问修饰符去进行访问的限制。
>
> + ==abstract：抽象的，即可***用于修饰类***也可用于修饰方法，但是abstract修饰的抽象方法只能存在于抽象类中，也就是说非抽象类不能定义抽象方法。==（类修饰符）
>
> + ==default：（即缺省：默认什么也不写）同包访问，无任何修饰符。使用对象：***类***、接口、成员变量、成员方法。==（类修饰符）
>
> + ==public：***同类可见，不同类不可见。***用于修饰成员变量、成员方法。==（类修饰符）
>
> + ==**final：将一个类修饰为最终类，即非继承的类，此类不能被子类所继承。**==（类修饰符）
>
>   >==**`abstract`与`final`不能同时作用到同一个类上。**==
>
> + private：所有类均可见。用于修饰成员内部类、接口、成员变量、常用方法。
>
> + protected：仅同一个包中类及其子类可见。用于修饰成员变量、成员方法，***不能用于修饰外部类***。
>
> > **protected与default**（protected不能修饰最外部的类）
> >
> > 使用场景：
> >
> > + 在同一个包下面，protected和default表现一致（同包的：当前类、子孙类都可以访问）。
> >
> > + 不在同一个包下面，对于default，均不能使用对象直接调用被protected修饰的属性和方法。
> >
> > + 不在同一个包下面，对于protected，只有子类可以访问父类被protected修饰的属性或方法。
>
> **接口中默认的访问修饰符是public**

### 代码块、静态代码块、局部代码块

>- 代码块就是用{}包含起来的多条语句。
>- 普通代码块（类中定义，全局作用域）在类实例化对象时执行，而执行顺序是在类实例化对象前执行。
>- 而在普通代码块前加一个static的代码块就是静态代码块（类中定义，全局作用域），静态代码块在只有类第一次加载的时候执行且只执行一次。
>  - 静态代码块的使用场景是使用它在类加载的时候去提前加载一些后续使用该类所需的外部资源到内存中，以便后续直接使用。
>  - Object 类中使用静态代码块注册Native
>  - jdbc中使用静态代码块注册数据库的驱动
>- 在方法中定义的代码块就是局部代码块。（方法中定义，局部作用域）

## transient关键字

> #### **transient 的作用**：
>
> - `transient的作用大家都知道是用来防止属性被序列化。`
>
> #### transient的局限性：
>
> - `transient`能作用的场景只能是和`Serializable`接口搭配使用，而另外一个序列化接口，`Externalizable`却不能对它起效。 仔细思考就明白原因，`Serializable`是JVM自动进行序列化的，而`Externalizable`需要我们通过 `readExternal`和`writeExternal`两个方法自己定义序列化和反序列化的实现方式，因此即使被transient修饰也和能否被序列化无关。
> - 局限二， 被 static修饰的变量也不能被序列化，与是否被 transient修饰无关。
>
>

## 枚举类

>#### 枚举实现接口
>
>* 接口
>
>  ```java
>  package enums;
>  
>  /**
>   * @author MoFany-J
>   * @date 2022/10/21
>   * @description EnumImpl
>   */
>  public interface EnumImpl {
>      void print();
>  }
>  ```
>
>* 枚举
>
>  ```java
>  package enums;
>  
>  /**
>   * @author MoFany-J
>   * @date 2022/10/21
>   * @description EnumDemo 定义枚举,
>   * 枚举是一个特殊类其用enum关键字定义；
>   * 枚举不可以继承其它一般类
>   * 枚举类中如果包含抽象方法时，其每一个实例都必须实现，
>   * 枚举可以实现一个接口,要么在枚举中重新一次方法（但返回值都一样），
>   * 要么在成员属性后进行方法重新（不同属性返回不同的结果）
>   */
>  public enum EnumDemo implements EnumImpl{
>      //定义枚举类的成员属性，默认属性都是静态的，并从属性中实现接口的方法
>      READ("红色"){
>          /**
>           * 接口方法的实现方式1
>           * */
>          @Override
>          public void print() {
>              System.out.println("READ:红色");
>          }
>      }, GREEN("绿色"){
>          @Override
>          public void print() {
>              System.out.println("GREEN:绿色");
>          }
>      };
>  
>      private String name;
>      /**
>      * 枚举的构造器默认私有且是必须条件，因为枚举通过类名访问属性不能创建对象
>      */
>      private EnumDemo(String name) {
>          this.name = name;
>      }
>  
>      /**
>       * 接口方法的实现方式2
>       * */
>      @Override
>      public void print() {
>  
>      }
>      
>      /**
>      * 枚举静止了序列化与反序列化的几个方法
>      * 1. writeObject() 序列化
>      * 2. readObject()  反序列化
>      * 3. readObjectNoData() 
>      * 4. writeReplace()
>      * 5. readResolve()
>      */
>  
>  }
>  ```