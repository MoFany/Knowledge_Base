# 多线程

>### 程序：
>
>- ##### 一个指令序列，程序是含有指令与数据的文件
>
>- ##### `程序是静态的代码`

## 进程:boxing_glove:

>- ##### 一个正在运行的程序就是一个进程，进程是在同一段时间内，可以同时执行一个以上的程序。
>
>- ##### `进程就是程序的一次执行过程。`
>
>- ##### 其是系统运行程序的基本单位，而一个进程又对应一个或多个线程。
>
>- ##### `进程是动态的，进程之间是相互独立的，进程是资源分配的基本单位。`
>
>* ==**简单而言一个进程就是一个正在执行中的程序，它在计算机中按一个指令接着一个指令的执行着。每个正在Windows操作系统上执行的程序都可以视为一个进程。**==

## 线程:boxing_glove:

>- ##### 线程是在同一程序内同时执行一个以上的程序段，故线程就是进程（程序）下的一个程序段，线程不能脱离进程而独立存在。
>
>- ##### `线程是处理器cpu调度的基本单位，一个线程只能使用所属进程下的资源。`
>
>* 主线程：每一个Java程序都有一个默认的主线程，对于应用程序来说**主线程就是main()方法所执行的线程**。
>
>* 单线程：即一个程序只有从头到位的一条执行路径。
>
>* **多线程：指在同一个进程中同时存在几个执行体，按几条不同的执行路径同时工作的情况。也就是可将一个程序任务分成几个可以同时并发执行的子任务。**
>
>* ==**守护线程：**==
>
>  >* ==线程分为两种：**普通线程**与**守护线程**==
>  >
>  >* ==**JVM启动时创建的所有线程中除了主线程以外，其它的线程都是守护线程。**==
>  >
>  >* ==当创建一个新线程时，新线程将继承创建它的线程的守护状态，因此在**默认情况下，主线程创建的所有线程都是普通线程。**==
>  >* ==普通线程与守护线程的差异仅仅在于当前线程退出时发生的操作。**当一个线程退出时JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM会正常执行退出操作。当JVM停止时，所有仍然存在的守护线程都将被抛弃，即不会执行finally代码块，也不会执行回卷栈，而JVM只是直接退出。**==
>  >* ==我们应尽量减少对守护线程的使用，因为很少有操作能够在不进行清理的情况下被安全抛弃。==
>
>### 多任务：
>
>- ##### ==**即同一时刻电脑中可以同时运行多个程序，存在多个进程，而每一个进程又对应多个线程。**==
>
>### 多任务与多线程是两个不同的概念
>
>* ==**多任务是针对操作系统而言的，表示操作系统可以同时运行多个应用程序。**==
>* ==**多线程是针对一个进程而言的，表示在一个进程内部可以同时执行多个线程。**==
>
>### 并行执行（同时执行）`宏观并行`
>
>- **并行执行表示同一时刻有多个代码块在处理器上执行，往往需要多个处理器。**
>
>### 并发执行（交替执行）`微观串行`
>
>- **并发执行表示，同一时刻只能在单个处理器上执行一个代码块，但在一个时间段内，这些代码块交替执行。**

# 线程的状态与生命周期

## 线程的生命周期与线程的状态图:closed_lock_with_key:

> ```flow
> #@author MoFany-J
> Start=>start: 新建状态（newborn）
> Op1=>operation: 就绪状态（runnable）
> Con=>condition: 执行状态（running）
> Op3=>operation: 阻塞等待状态（blocked）
> End=>end: 消亡状态（dead）
> 
> Start->Op1->Con
> Con(no)->Op3->Op1
> Con(yes)->End
> ```
>
> ### 线程的状态详解
>
> 1. **新建状态：**
>
>    >​	当一个Thread类或其子类的对象被声明并创建，但还未被执行的这段时间里，处于一种特殊的新建状态中。此时，线程对象已经被分配了内存空间和其它资源，并已被初始化，但是该线程尚未被调度，此时的线程可以被调度，从而变成就绪状态。
>    >
>
> 2. **就绪状态：**
>
>    >​	`就绪也被称为可运行状态。`处于新建状态的线程被启动后，将进入线程队列排队等待CPU资源，此时它已具备了运行的条件，也就是处于就绪状态。一旦轮到它来享用CPU资源时，就可以脱离创建它的主线程独立开始自己的生命周期了。**`（原来处于阻塞状态的线程被解除阻塞后也将进入就绪状态）`**
>    >
>
> 3. **执行状态：**
>
>    >​	当就绪状态的线程被调度并获得CPU资源时，便进入执行状态。该状态表示线程正在执行，该线程已经拥有了对CPU的控制权。每一个Thread类及其子类的对象都有一个重要的run()方法，该方法定义了这一类线程的操作与功能。线程对象被调度执行时，它将自动调用本对象的run()方法，从该方法的第一条语句开始执行，一直到执行完毕，除非该线程主动让出了CPU控制权或者CPU控制权被优先级更高的线程抢占了。
>    >
>    >* 让出CPU控制权的几种情况：
>    >  * 线程执行完毕
>    >  * 有比当前线程优先级更高的线程处于就绪状态
>    >  * 线程主动睡眠一段时间
>    >  * 线程在等待某一资源
>
> 4. **阻塞等待状态：**
>
>    >##### 	一个正在执行的线程在某些特殊情况下将CPU的控制权让出并且暂时中止自己的执行，此时将线程的这种不可执行的状态称为阻塞状态。等到阻塞原因消除后被阻塞的线程方可结束阻塞状态重新进入就绪状态，并重新去抢占CPU执行权。
>    >
>    >1. ###### 锁等待状态`BLOCKED`：线程处于锁等待状态
>    >
>    >2. ###### 条件等待状态`WAITING`：表示线程处于条件等待状态，当条件触发后唤醒，如`wait/notify`
>    >
>    >3. ###### 条件等待+超时条件触发状态`TIMEO_WAIT`：与条件等待状态`WAITING`相同，只是它多了一个超时条件触发
>    >
>    >* 让一线程进入阻塞状态的几种情况：
>    >  * `sleep(long millis)`**不会释放锁标记，只是放弃了CPU的执行权**
>    >    * 线程睡眠
>    >    * 为当前执行的线程指定睡眠时间，参数`millis`是线程睡眠的毫秒数。如果该线程已经被别的线程中中断则抛出`InterruptedException`异常。
>    >  * `yield()`**不会释放锁标记，只是放弃了CPU的执行权**
>    >    * **`只用于同优先级线程`**
>    >    * 暂停当前线程的执行，但该线程仍处于就绪状态（重新进入CPU执行权抢占调度模式），不转为阻塞状态，该方法只给同优先级线程以执行的机会。
>    >  * `join()`**会释放锁标记，因为join的底层是wait**
>    >    - 线程礼让
>    >    - 暂停当前线程的执行，等待调用该方法的线程结束后再继续执行本线程，此时线程状态为就绪状态。
>    >  * `wait()`**会释放锁标记**
>    >    * `必须在 synchronized 语句块内使用`，即调用 `wait()`，`notify() `和 `notifyAll() `的任务在调用这些方法前必须拥有对象的锁。
>    >    * 中断线程执行，暂时让出CPU执行权，使本线程转入阻塞状态并运行其它线程使用该同步方法，当调用wait()方法的线程所需条件满足后，应确保其它线程会调用`notify()`或`notifyAll()`方法通知一个或所有由于是使用这个同步方法而处于阻塞状态的线程结束等待并进入就绪状态（重新进入CPU执行权抢占调度模式），而曾中断的线程就会从刚才的中断处继续执行这个同步方法。
>
> 5. **消亡状态：**
>
>    >​	处于消亡状态的线程不具备继续执行的能力。
>    >
>    >* 导致线程消亡的原因有两个：
>    >  * 正常运行的线程完成了它的全部工作，即执行完了run()方法的最后一条语句并退出。
>    >  * 当进程因故停止运行时，该进程中的所有线程将被强行终止，当线程处于消亡状态、并且没有该线程对象的引用时，垃圾回收器会从内存中删除该线程对象。

# 对象互斥锁及其衍生锁

>* **java语言中每个对象都有一个“互斥锁”与之相连。当线程A获得一个对象的互斥锁后，线程B若也想获得该对象的互斥锁，就必须等待线程A完成规定的操作并释放出互斥锁后，线程B才能获得该对象的互斥锁，并执行线程B的操作。**
>* `一个对象的互斥锁只有一个，所以利用对某个对象互斥锁的争夺，可以实现不同线程的互斥效果。`
>* **`当一个线程获得互斥锁后，则其他需要该互斥锁的线程只能处于等待状态。`**

## 悲观锁：`synchronized`

>#### 早期属于重量级锁，1.6之后可进行锁升级`syschronized无法保证指令重排序，但可以保证有序性`
>
>```properties
>Java语言的关键字，可用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。然而，当一个线程访问object的一个加锁代码块时，另一个线程仍可以访问该object中的非加锁代码块。
>```
>
>#### 线程休眠后依然不会释放锁
>
>1. **语句同步**（临界代码段中的共享变量应该为`private`，确立了共享变量的数据安全）
>
>   ```java
>   /**
>    * 语句同步定义格式：为当前对象加锁
>    */
>   synchronized(this){
>       
>   	...Statement...//临界代码段
>   }
>   ```
>
>   ```java
>   /**
>    * 语句同步定义格式：为某个类加锁(全局有效)
>    */
>   synchronized(XXX.class){
>       
>   	...Statement...//临界代码段
>   }
>   ```
>
>2. **方法同步**（临界代码段中的共享变量应该为`private`，确立了共享变量的数据安全）
>
>   ```java
>   /**
>    * 方法同步定义格式1
>    */
>   public synchronized void testMethod(){
>   
>   	...Method body...//临界代码段
>   }
>   ```
>
>   ```java
>   /**
>    * 方法同步定义格式2
>    */
>   
>   public void testMethod(){
>   	
>       //synchronized(this)加锁
>       synchronized(this){
>   		
>           ...Statement...//临界代码段
>       }
>   }
>   
>   
>   public void testMethod(){
>   	
>       //synchronized(XXX.class)加锁
>       synchronized(XXX.class){
>   		
>           ...Statement...//临界代码段
>       }
>   }
>   ```
>
>3. **静态方法同步**（临界代码段中的共享变量应该为`private`，确立了共享变量的数据安全）
>
>   ```java
>   public static synchronized void testMethod(){
>   
>   	...Method body...//临界代码段
>   }
>   ```

## volatile`轻量级锁`

>>*  `volatile`关键字用于修饰类的成员变量，其可以保证被共享的成员变量在多个线程之间可见。
>>*  **支持可见性、有序性、`不具有原子性`**
>>*  **禁止指令重排序**
>>
>
>#### 主线程中通过标志量结合`Volatile`关键字修饰成员变量结束子线程：
>
>* ##### 形式1：(先运行子线程，再终止子线程)
>
>```java
>package threadandexception;
>
>import java.util.concurrent.TimeUnit;
>
>/**
> * @author MoFany-J
> * @date 2022/10/10
> * @description VolatileDemo
> */
>public class VolatileDemo implements Runnable{
>    /**
>     * volatile修饰类的成员变量,具有可见性、有序性不具有原子性
>     * 初始时标志量flag的值默认为false,即开始时默认执行子线程
>     * */
>    private static volatile boolean flag;
>    
>
>    /**
>     * 重写run()方法实现一个利用标志量flag来终止子线程
>     * */
>    @Override
>    public void run(){
>        //当不满足停止条件时线程会一直运行
>        while (!flag){
>            //死循环,(这个里面写的是线程永远执行时进行的内容)
>            System.out.println(Thread.currentThread().getName()+"（子线程）---->正在执行");
>        }
>        //满足停止条件时，即停止子线程
>        System.out.println(Thread.currentThread().getName()+"（子线程）---->终止成功,stop="+flag);
>
>    }
>    /**
>     * 主方法
>     * */
>    public static void main(String[] args) throws InterruptedException {
>
>        //共享的对象
>        VolatileDemo runnableObj=new VolatileDemo();
>        //创建线程对象
>        Thread thread1=new Thread(runnableObj,"线程1");
>        Thread thread2=new Thread(runnableObj,"线程2");
>        //激活并启动线程，实行抢占模式
>        thread1.start();
>        thread2.start();
>        //线程睡眠,用于睡眠当前线程即主线程
>        TimeUnit.MILLISECONDS.sleep(100);
>        //标志量为true时，关闭子线程
>        flag = true;
>        //标志量为false时，继续执行线程
>        //stop = false;
>        //输出父线程
>        System.out.println("主线程"+Thread.currentThread().getName()+"---->设置子线程的终止条件,stop="+flag);
>    }
>}
>```
>
>```properties
>线程2（子线程）---->正在执行
>线程2（子线程）---->正在执行
>线程2（子线程）---->正在执行
>线程2（子线程）---->正在执行
>线程2（子线程）---->正在执行
>线程2（子线程）---->正在执行
>线程2（子线程）---->正在执行
>线程2（子线程）---->正在执行
>线程2（子线程）---->正在执行
>线程2（子线程）---->正在执行
>......
>线程2（子线程）---->正在执行
>线程2（子线程）---->正在执行
>线程2（子线程）---->正在执行
>线程2（子线程）---->正在执行
>线程2（子线程）---->正在执行
>线程1（子线程）---->正在执行
>线程1（子线程）---->正在执行
>线程1（子线程）---->正在执行
>线程2（子线程）---->正在执行
>线程1（子线程）---->终止成功,stop=true
>线程2（子线程）---->终止成功,stop=true
>主线程main---->设置子线程的终止条件,stop=true
>
>Process finished with exit code 0
>```
>
>* ##### 形式2：（不会运行子线程而直接停止子线程）
>
>```java
>package threadandexception;
>
>import java.util.concurrent.TimeUnit;
>
>/**
> * @author MoFany-J
> * @date 2022/10/10
> * @description VolatileDemo
> */
>public class VolatileDemo implements Runnable{
>    /**
>     * volatile关键字修饰类的成员变量,具有可见性、有序性,不具有原子性
>     * 初始时标志量flag的值默认为false,即开始时默认执行子线程
>     * */
>    private volatile boolean flag;
>    
>    /**
>     * 无参构造器
>     * */
>    public VolatileDemo(){
>
>    }
>
>    /**
>     * 带有一个参数的构造器
>     * */
>    public VolatileDemo(boolean flag){
>        //为成员变量指定默认值
>        this.flag=flag;
>    }
>
>    /**
>     * 重写run()方法实现一个利用标志量flag来终止子线程
>     * */
>    @Override
>    public void run(){
>        //当不满足停止条件时线程会一直运行
>        while (!flag){
>            //死循环
>        }
>        //满足停止条件时，即停止子线程
>        System.out.println(Thread.currentThread().getName()+"（子线程）---->终止成功,stop="+flag);
>
>    }
>}
>```
>
>```java
>package threadandexception;
>
>import java.util.concurrent.TimeUnit;
>
>/**
> * @author MoFany-J
> * @date 2022/10/10
> * @description VolatileMainDemo
> */
>public class VolatileMainDemo {
>
>    public static void main(String[] args) throws InterruptedException {
>
>        //共享的对象,构造器中的参数为true时为关闭子线程，不传参数或传入false时都不会关闭子线程
>        VolatileDemo runnableObj=new VolatileDemo(true);
>        //创建线程对象
>        Thread thread1=new Thread(runnableObj,"线程1");
>        Thread thread2=new Thread(runnableObj,"线程2");
>        //激活并启动线程，实行抢占模式
>        thread1.start();
>        thread2.start();
>        //睡眠当前线程,用于睡眠当前线程即主线程
>        TimeUnit.MILLISECONDS.sleep(2000);
>        //输出父线程
>        System.out.println("主线程"+Thread.currentThread().getName()+"---->设置子线程的终止条件,stop=true");
>    }
>}
>```
>
>```properties
>程1（子线程）---->终止成功,stop=true
>线程2（子线程）---->终止成功,stop=true
>主线程main---->设置子线程的终止条件,stop=true
>
>Process finished with exit code 0
>```

## :accept:`synchronized`与`volatile`结合起来实现同步的优化

>#### 双检查锁机制，`单例懒汉式`
>
>```java
>package doublecheckmechanism;
>
>
>/**
> * @author MoFany-J
> * @date 2022/10/13
> * @description DoubleCheckLock 双检查加锁机制：实现单例懒汉式
> */
>class DoubleCheckLock{
>    /**
>     * @description 给一个对象进行双加锁
>     * volatile修饰的成员属性具有可见性、有序性、不具有原子性,可禁止指令重排序
>     * synchronized支持可见性、有序性、原子性
>     * */
>    private static volatile Object object;
>    
>    /**
>     * 私有构造器静止通过new关键字类外创建对象
>     * */
>    private DoubleCheckLock(){
>			throw new RunTimeExceprion("禁止反射！");
>    }
>    
>    /**
>     * 创建对象的方法：进行双检查
>     * */
>    public static Object objectFactory(){
>        //检查对象为空才进入同步代码块
>        if(object==null){
>            synchronized (Object.class){
>                //进入同步代码块后，再检查对象是否为空若为空才创建实例
>                if (object==null){
>                    object=new Object();//erro
>                }
>            }
>        }
>        return object;
>    }
>}
>```
>
>#### 总结与分析：
>
>1. **为什么双重检验 （即为什么使用了两个`if`语句）？**
>
>   ​	**`执行双重检测是因为，如果多个线程通过了第一次检测，由于此时的synchronized作用，其中一个线程会首先通过了第二次检测并实例化对象，而剩余的线程不会再重复实例化对象。这样就保证除了初始化的时候会加锁，后续的调用都是直接返回，解决了多余的性能消耗。`**
>
>   - **外层判断：完成实例化后，之后的线程就不需要再执行synchronized等待，提高效率。**
>   - **内层判断：防止多次实例化。**
>
>2. **为什么加双锁（即为什么同时使用了`synchronized`关键字和`volatile`关键字）？**
>
>   1. 如果不使用volatile关键字，隐患来自于上述代码中注释了 `erro `的一行，这行代码大致有以下三个步骤：
>
>      * 在堆中开辟对象所需空间，分配地址:one:
>
>      * 根据类加载的初始化顺序进行初始化:two:
>
>      * 将内存地址返回给栈中的引用型变量:three:
>
>   2. 由于 **Java 内存模型允许“无序写入”**，有些编译器可能会由于性能原因，把上述步骤中的 2 和 3 进行重排序，顺序就成了：
>
>      * 在堆中开辟对象所需空间，分配地址:one:
>
>      * 将内存地址返回给栈中的引型用变量:three:`此时变量已不在为null，但是变量却并没有初始化完成`
>
>      * 根据类加载的初始化顺序进行初始化:two:
>
>3. **JDK版本为什么要大于1.5？**
>
>   - **volatile关键字禁止指令重排序的语义在JDK1.5中才被完全修复。**
>   - **JDK5 以及后续版本扩展了volatile语义，不再允许volatile写操作与其前面的读写操作重排序，也不允许volatile读操作与其后面的读写操作重排序。**
>
>   #### 枚举实现单例
>
>   * 枚举实现的单例是天生线程安全的
>   * 枚举单例可解决反序列化破坏单例的问题
>
>   ```java
>   /**
>   * 枚举实现单例，枚举是由一组常量组成的合法类型
>   */
>   public enum Singleton{
>       INSTANCE,
>       public void whateverMethod(){
>           
>       }
>   }
>   ```

## :accept:synchronized锁如何升级？`锁可以升级但不能降级`

>#### 对象在内存中占16字节，数组在内存中占24字节
>
>### 无锁`non-biasable`
>
>* **当一个对象被创建之后，还没有线程进入，这个时候对象处于无锁状态。**
>* **无锁：如果持有偏向锁的线程不处于活动状态时，则将对象头中的锁标记状态设置为无锁状态。**
>
>```java
>package lockescalation;
>
>import org.openjdk.jol.info.ClassLayout;
>
>/**
> * @author MoFany-J
> * @date 2022/10/11
> * @description NonBiasable 无锁
> */
>public class NonBiasable {
>    public static void main(String[] args){
>        System.out.println("当前线程为："+Thread.currentThread().getName());
>        Object obj=10;
>        //查看对象obj在类分布中对象头的markWord（信息标记）部分中的锁状态
>        //默认JVM启动会有一个预热阶段，所以默认不会开启偏向锁
>        System.out.println(ClassLayout.parseInstance(obj).toPrintable());
>    }
>}
>```
>
>```properties
>当前线程为：main
># WARNING: Unable to get Instrumentation. Dynamic Attach failed. You may add this JAR as -javaagent manually, or supply -Djdk.attach.allowAttachSelf
>java.lang.Integer object internals:
>OFF  SZ   TYPE DESCRIPTION               VALUE
>  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)
>  8   4        (object header: class)    0x2000259e
> 12   4    int Integer.value             10
>Instance size: 16 bytes
>Space losses: 0 bytes internal + 0 bytes external = 0 bytes total
>
>
>Process finished with exit code 0
>```
>
>### 偏向锁`biasable`（对象被synchronized修饰）
>
> #### 待偏向（匿名偏向）`biasable（起步式）`
>
>  * **当一个对象已经准备好被一个线程访问时会从无锁到待偏向状态进行转变。**
>
>  ```java
>  package lockescalation;
>  
>  import org.openjdk.jol.info.ClassLayout;
>  
>  /**
>   * @author MoFany-J
>   * @date 2022/10/11
>   * @description Biasable 默认对象的锁状态处于待偏向状态（匿名偏向）
>   */
>  public class Biasable {
>      public static void main(String[] args){
>          System.out.println("当前线程为："+Thread.currentThread().getName());
>          Object obj=new Object();
>          
>          //查看对象obj在类分布中对象头的markWord（信息标记）部分中的锁状态
>          //默认JVM启动会有一个预热阶段，所以默认不会开启偏向锁
>          System.out.println(ClassLayout.parseInstance(obj).toPrintable());
>      }
>  }
>  ```
>
>  ```properties
>  当前线程为：main
>  # WARNING: Unable to get Instrumentation. Dynamic Attach failed. You may add this JAR as -javaagent manually, or supply -Djdk.attach.allowAttachSelf
>  java.lang.Object object internals:
>  OFF  SZ   TYPE DESCRIPTION               VALUE
>    0   8        (object header: mark)     0x0000000000000005 (biasable; age: 0)
>    8   4        (object header: class)    0x20000200
>   12   4        (object alignment gap)    
>  Instance size: 16 bytes
>  Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
>  
>  
>  Process finished with exit code 0
>  ```
>
>  #### 偏向锁`biasabled（完成式）`
>
>  * 使用synchronized获取某个对象的锁，此时该对象头中的锁标记状态会从待偏向状态(匿名偏向)转变为偏向锁状态。`synchronized获取某对象的锁`
>  * **当锁处于无锁状态时，有一个线程A访问同步块并获取锁时，会在对象头和栈帧中的锁记录记录线程ID，以后该线程在进入和退出同步块时不需要进行`CAS操作`来进行加锁和解锁，只需要简单的测试一下啊对象头中的线程ID和当前线程是否一致。**
>
>  ```java
>  package lockescalation;
>  //该类可用于查看类对象在内存中的布局
>  import org.openjdk.jol.info.ClassLayout;
>  /**
>   * @author MoFany-J
>   * @date 2022/10/11
>   * @description Biasabled synchronized升级为偏向锁
>   */
>  public class Biasabled {
>      public static void main(String[] args){
>          System.out.println("当前线程为："+Thread.currentThread().getName());
>          Object obj=new Object();
>          
>          /**
>          * 将synchronized升级为偏向锁
>          *
>          * 使用synchronized获取某个对象的锁，
>          * 此时该对象的对象头中的锁标记状态会从待偏向状态(匿名偏向)转变为偏向锁状态
>          */
>          synchronized(obj){
>              //查看对象obj在类分布中对象头的markWord（信息标记）部分中的锁状态
>              System.out.println(ClassLayout.parseInstance(obj).toPrintable());
>          }
>      }
>  }
>  ```
>
>  ```properties
>  当前线程为：main
>  # WARNING: Unable to get Instrumentation. Dynamic Attach failed. You may add this JAR as -javaagent manually, or supply -Djdk.attach.allowAttachSelf
>  java.lang.Object object internals:
>  OFF  SZ   TYPE DESCRIPTION               VALUE
>   0   8  (object header: mark)   0x0000021174cfa005 (biased: 0x00000000845d33e8; epoch: 0; age: 0)
>   8   4   (object header: class)  0x20000200
>  12   4   (object alignment gap)    
>  Instance size: 16 bytes
>  Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
>  
>  
>  Process finished with exit code 0
>  ```
>
>### 轻量级锁`thin lock`
>
>* 处于偏向状态的锁，在同步代码块外计算一次hashCode后会将偏向级锁升级为轻量级锁。`synchronized外计算hashCode`
>* **在偏向锁的基础上，又有另外一个线程B进来，这时判断对象头中存储的线程A的ID和线程B不一致，就会`使用CAS竞争锁，并且升级为轻量级锁`，会在线程栈中创建一个锁记录(lock Record)，将Mark Word复制到锁记录中，然后线程尝试使用CAS将对象头的Mark Word替换成指向锁记录的指针，如果成功，则当前线程获得锁；失败，表示其他线程竞争锁，当前线程便尝试CAS来获取锁。**
>* **会自旋消耗CPU**
>
>```java
>package lockescalation;
>
>import org.openjdk.jol.info.ClassLayout;
>
>/**
> * @author MoFany-J
> * @date 2022/10/11
> * @description ThinLock synchronized升级为轻量级锁
> */
>public class ThinLock {
>    public static void main(String[] args){
>        System.out.println("当前线程为："+Thread.currentThread().getName());
>        Object obj=new Object();
>        
>        
>        /**
>        * 同步语句块外调用对象obj的hashCode使其对象的锁标记状态升级为轻量级锁
>        */
>        System.out.println("对象的hashCode编码为："+obj.hashCode());
>        /**
>        * 将synchronized升级为轻量级锁
>        */
>        synchronized(obj){
>            //查看对象obj在类分布中对象头的markWord（信息标记）部分中的锁状态
>            System.out.println(ClassLayout.parseInstance(obj).toPrintable());
>        }
>    }
>}
>```
>
>```properties
>当前线程为：main
>对象的hashCode编码为：1720435669
># WARNING: Unable to get Instrumentation. Dynamic Attach failed. You may add this JAR as -javaagent manually, or supply -Djdk.attach.allowAttachSelf
>java.lang.Object object internals:
>OFF  SZ   TYPE DESCRIPTION               VALUE
>  0   8        (object header: mark)     0x000000828dfff480 (thin lock: 0x000000828dfff480)
>  8   4        (object header: class)    0x20000200
> 12   4        (object alignment gap)    
>Instance size: 16 bytes
>Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
>
>
>Process finished with exit code 0
>```
>
>### 重量级锁`fat lock`
>
>* 处于偏向级状态的锁，在同步代码块内计算一次hashCode后会将偏向级锁升级为重量级锁。`synchronized内计算hashCode`
>* **当线程没有获得轻量级锁时，线程会CAS自旋来获取锁，当一个线程`自旋10次`之后，仍然未获得锁，那么就会升级成为重量级锁。成为重量级锁之后，线程会进入阻塞队列(EntryList)，线程不再自旋获取锁，而是由CPU进行调度，线程串行执行。**
>* **不会自旋消耗CPU**
>
>```java
>package lockescalation;
>
>import org.openjdk.jol.info.ClassLayout;
>
>/**
> * @author MoFany-J
> * @date 2022/10/11
> * @description FatLock synchronized升级为重量级锁
> */
>public class FatLock {
>    public static void main(String[] args){
>        System.out.println("当前线程为："+Thread.currentThread().getName());
>        Object obj=new Object();
>        
>        
>        /**
>        * 将synchronized升级为重量级锁
>        */
>        synchronized(obj){
>            
>            /**
>            * 同步语句块内调用对象obj的hashCode使其对象的锁标记状态升级为重量级锁
>            */
>            System.out.println("对象的hashCode编码为："+obj.hashCode());
>            //查看对象obj在类分布中对象头的markWord（信息标记）部分中的锁状态
>            System.out.println(ClassLayout.parseInstance(obj).toPrintable());
>        }
>    }
>}
>```
>
>```properties
>当前线程为：main
>对象的hashCode编码为：1720435669
># WARNING: Unable to get Instrumentation. Dynamic Attach failed. You may add this JAR as -javaagent manually, or supply -Djdk.attach.allowAttachSelf
>java.lang.Object object internals:
>OFF  SZ   TYPE DESCRIPTION               VALUE
>  0   8        (object header: mark)     0x000001f5fecc2102 (fat lock: 0x000001f5fecc2102)
>  8   4        (object header: class)    0x20000200
> 12   4        (object alignment gap)    
>Instance size: 16 bytes
>Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
>
>
>Process finished with exit code 0
>```
>
>#### 对象在堆内存中地址值的十六进制表示：
>
>```java
>Object object=new Object();
>//获取一个对象在堆内存中地址值的十六进制表示
>int memoryValue=Integer.toHexString(object.hashCode());
>System.out.println(memoryValue);
>```
>

## 自旋锁的实现:boxing_glove:

>#### 自旋锁与互斥锁的相同点：
>
>* 都是为了实现线程的互斥操作，即都是为了解决对某项资源的互斥。
>* 与`synchronized`相同，同一个时刻只能有一个线程获得执行权。
>
>#### 自旋锁与互斥锁的不相同点：
>
>* `synchronized`互斥锁同一时刻只有一个线程可以获得执行权，而其他线程全部处于休眠阻塞状态；
>* 自旋锁同一时刻下也只有一个线程可以获得CPU的执行权，而其他线程依然处于某个循环（自旋）之中不停的去判断看CPU是否已经空闲，若空闲就开始新一轮的资源抢占；成功抢占CPU执行权的线程则开始执行，而其余线程又开始自旋。
>
>>#### ` compareAndSet(boolean expectedValue, boolean newValue)`方法的作用：
>>
>>* 该方法执行的操作又称为：**CAS（比较并交换）**
>>* **首先会比较第一个参数和调用者的值，如果相等则进行交换，也就是将调用者的值设置为第二个参数。**
>>* **如果这些操作成功，那么`compareAndSet()`方法就返回true，如果操作失败则返回false。**
>>* **操作失败可能是因为第一个参数的值（期望值）和调用者的值不相等，如果相等也可能因为在更改调用者的值的时候发生了失败。`因为可能有多个线程在操作，由于原子性的存在，所以只会有一个线程操作成功`**
>
>```java
>package lockescalation;
>//导入原子操作类，基本类型
>import java.util.concurrent.atomic.*;
>/**
> * @author MoFany-J
> * @date 2022/10/11
> * @description SpinLock 实现自旋锁，自旋锁会消耗CPU
> */
>class SpinLock {
>    
>    /**
>     * 使用了原子类
>     * false表示未上锁状态
>     * true表示已上锁状态
>     * */
>    private AtomicBoolean value;
>    
>    /**
>     * 无参构造器
>     * */
>    public SpinLock(){
>        this.value=new AtomicBoolean();
>        //设置value的默认值默认为未上锁状态，即为0
>        this.value.set(false);
>    }
>
>    /**
>     * 加锁
>     * */
>    public void lock(){
>        //进行自旋操作，CAS比较并交换
>        while (!value.compareAndSet(false,true)) {
>            ;
>        }
>    }
>
>    /**
>     * 释放锁
>     * */
>    public void unLock(){
>       //将锁的状态设置为未上锁状态
>        value.compareAndSet(true,false);
>    }
>}
>```
>
>```java
>package lockescalation;
>
>/**
> * @author MoFany-J
> * @date 2022/10/11
> * @description SpinLockTest 测试自旋锁
> */
>public class SpinLockTest {
>    public static int data;
>    public static SpinLock spinLock=new SpinLock();
>    
>    /**
>     * 上锁：只能有一个线程执行data++操作，其它线程都只能进行while循环
>     * */
>    public static void add(){
>        for (int i=0;i<100000;i++){
>            //上锁
>            spinLock.lock();
>            data++;
>            //释放锁
>            spinLock.unLock();
>        }
>    }
>    
>    /**
>     * 主方法
>     * */
>    public static void main(String[] args){
>        //创建100个线程
>        Thread[] threads=new Thread[100];
>        for (int i=0;i<100;i++){
>            //方法引用，去给线程数组元素赋值
>            threads[i]=new Thread(SpinLockTest::add);
>        }
>        //启动100个线程
>        for (Thread t:threads) {
>            t.start();
>        }
>        //等待100个线程执行完毕
>        try{
>            for (Thread t:threads) {
>                // 线程礼让，会释放锁因为join的底层就是wait
>                t.join();
>            }
>        }catch (Exception e){
>            e.getMessage();
>        }
>        //10000000
>        System.out.println(data==10000000?"data="+data+"\n达到理论效果，自旋锁合理!":"自旋锁有误!");
>    }
>}
>```
>
>```properties
>data=10000000
>达到理论效果，自旋锁合理!
>
>Process finished with exit code 0
>```

## :accept:`乐观锁：CAS`（Compare And Swap比较与交换操作）

>### CAS(V,E,N)操作：`对应于CompareAndSet()方法`
>
>* **V表示要更新的变量，E表示当前期望值，N表示更新的值，比较变量当前值和期望值是否相等，如果相等，则更新为新的值，否则再次循环。**
>  * 优点：原子类中也是使用了CAS来实现了线程安全，这种无锁的方式比基于锁的实现性能更优越，使用锁会带来线程间频繁调度的开销。
>  * 缺点：CAS的其他问题：ABA问题和自旋问题。
>
>#### ABA问题：
>
>* `CAS操作是判断当前内存中的值与期望值是否相等，若相等才更新。但如果第一个线程执行CAS操作，其期望值是对象A，而其它线程在这之前把内存中的值该为了B，然后又被其它线程改回了A（构成了闭合回路）。这时依然会判断相等，但是实际A的属性值可能已经改变，判断条件已经发生了变化，这就产生了线程安全的问题。`
>
>  ```java
>  package cas_aba;
>  
>  import java.util.concurrent.TimeUnit;
>  
>  /**
>   * @author MoFany-J
>   * @date 2022/10/11
>   * @description ABADemo CAS的ABA问题
>   */
>  public class ABADemo{
>  
>      /**
>       * value char类型的默认值为'\u0000'
>       * @description 表示对象的值
>       * */
>      private char value;
>  
>      /**
>       * log
>       * @description 用于记录对象的历史值
>       * */
>      private static String logData="";
>  
>      /**
>       * @param value 指定的对象的属性值
>       * 用于设置对象属性值，然后记录对象属性值的历史变化记录
>       * */
>      public void setValue(char value) {
>          this.value = value;
>          //设置对象属性值记录器
>          setLogData(value);
>      }
>  
>      /**
>       * 返回value属性的值
>       * */
>      public char getValue() {
>          return value;
>      }
>  
>      /**
>       * @param log
>       * */
>      private static void setLogData(char log) {
>          if (logData.length()>=0){
>              logData +="-->"+log;
>          }
>          //substring()方法的作用为去掉原字符串左面n个字符，即去掉“-->”前缀字符串
>          System.out.println("*日志：对象属性值的历史记录为："+logData.substring(3));
>      }
>  
>      /**
>       * @param object 被操作对象
>       * @param expectedValue 预期值
>       * @param newValue 新值
>       * @description 当前值与预期值相等时，则将变量值跟新为新值,否则一直循环（该方法被多个线程使用）
>       * */
>      public boolean compareAndSwap(ABADemo object,char expectedValue,char newValue){
>          boolean flag=true;
>          do{
>              if(object.value==expectedValue){
>                  object.value=newValue;
>                  //设置对象属性值记录器
>                  setLogData(object.value);
>                  //修改成功的线程跳出，其它线程则处于自旋状态
>                  flag=false;
>              }else {
>                      try{
>                          //触发自旋锁
>                          TimeUnit.SECONDS.sleep(1);
>                          System.out.println(Thread.currentThread().getName()+"正在自旋式的等待执行...");
>                      }catch (Exception e){
>                          System.out.println("发生异常"+e.getMessage()+"sleep失败！");
>                      }
>              }
>          }while (flag);
>          return flag;
>      }
>  }
>  ```
>
>  ```java
>  package cas_aba;
>  
>  /**
>   * @author MoFany-J
>   * @date 2022/10/12
>   * @description Factory 懒汉式模型
>   */
>  public class Factory {
>      /**
>       * 类属性工厂方法提前将静态属性与成员加载到内存中
>       * */
>      private static ABADemo aba;
>      /**
>       * 私有无参构造器的作用：禁止直接采用类名的方式创建对象
>       * */
>      private Factory() {
>  		throw new RunTimeException("禁止反射！");
>      }
>      /**
>       * 当前对象为空时创建一个对象，否则重用这个对象
>       * */
>      public static ABADemo getObject() {
>          if (aba==null){
>              aba=new ABADemo();
>          }
>          return aba;
>      }
>  }
>  ```
>
>  ```java
>  package cas_aba;
>  
>  /**
>   * @author MoFany-J
>   * @date 2022/10/12
>   * @description ABATest ABA问题的测试
>   */
>  public class ABATest {
>  
>      /**
>       * 实现A-->B-->A的修改
>       * */
>      public static void main(String[] args) {
>          //通过工厂获取对象
>          ABADemo aba=Factory.getObject();
>          //字符类型变量的默认值为'\u0000'
>          aba.setValue('A');
>          System.out.println("主线程"+Thread.currentThread().getName()+"将对象属性值设置为：value="+aba.getValue());
>          //创建线程
>          new Thread(()->{
>              System.out.println(printData(aba,'A','B'));
>          },"子线程1").start();
>  
>          new Thread(()->{
>              System.out.println(printData(aba,'C','C'));
>          },"子线程2").start();
>  
>          new Thread(()->{
>              System.out.println(printData(aba,'B','A'));
>          },"子线程3").start();
>      }
>  
>      /**
>       * 打印数据
>       * */
>      public static String printData(ABADemo obj,char ch1,char ch2){
>          String str1=Thread.currentThread().getName();
>          String str2=obj.compareAndSwap(obj,ch1,ch2)==false?"修改成功"+"，执行任务后的结果：value="+obj.getValue():"未修改";
>          return str1+str2;
>      }
>  }
>  ```
>
>  ```properties
>  *日志：对象属性值的历史记录为：A
>  主线程main将对象属性值设置为：value=A
>  *日志：对象属性值的历史记录为：A-->B
>  *日志：对象属性值的历史记录为：A-->B-->A
>  子线程1修改成功，执行任务后的结果：value=B
>  子线程3修改成功，执行任务后的结果：value=A
>  子线程2正在自旋式的等待执行...
>  子线程2正在自旋式的等待执行...
>  子线程2正在自旋式的等待执行...
>  子线程2正在自旋式的等待执行...
>  
>  Process finished with exit code 130
>  ```
>
>#### 解决方法：`AtomicStampReference`
>
>* ##### 添加版本号，每次更新内存操作时版本号加1，比较对象的同时再比较版本号`同一时刻下的一个数据对应一个新的版本号`。此时就需要结合`AtomicStampReference`原子引用类进行。
>
>```java
>package casabaed;
>
>import java.util.concurrent.TimeUnit;
>import java.util.concurrent.atomic.AtomicStampedReference;
>
>/**
> * @author MoFany-J
> * @date 2022/10/13
> * @description ABADemo 解决ABA问题的方案
> */
>public class ABADemo {
>    /**
>     * 值
>     */
>    private char value;
>    
>    /**
>     * 版本号，初始版本号可自定义
>     */
>    private int expectedVersion = 0;
>
>    /**
>     * 核心1：
>     * 通过原子对象引用类来解决ABA问题
>     * AtomicStampedReference维护一个对象引用以及一个整数“标记”，可以原子方式更新。
>     * 实现说明：此实现通过创建表示“盒装”[对象引用，整数版本号]对的内部对象来维护标记引用。
>     */
>    private AtomicStampedReference<Object> reference = 
>        new AtomicStampedReference(this, this.expectedVersion);
>
>    public ABADemo(char initValue) {
>        this.value = initValue;
>    }
>
>    /**
>     * @param object   被操作对象
>     * @param version  期望版本
>     * @param newValue 新值
>     * @description 当前值与预期值相等时，则将变量值更新为新值,否则一直循环（该方法被多个线程使用）
>     */
>    public void newCompareAndSwap(ABADemo object, int version, char newValue) {
>
>        //修改成功返回true,即!true为false则结束循环
>        int count = 0;
>        while (true) {
>            /**
>             * 核心2：
>             * 该计数器要位于临界代码块内，属于同步操作
>             * */
>            synchronized (this) {
>                count++;
>            }
>            if (count > 10) {
>                throw new RuntimeException(Thread.currentThread().getName() + "自旋超过10次!");
>            }
>            System.out.println(Thread.currentThread().getName() + "--->期望版本为:" 
>                               + reference.getStamp() + "，新版本为:" + version);
>            /**
>             * 核心3：
>             * 乐观锁CAS操作：对象是同一个对象且版本号一致时才会更新值
>             * 值为true时：重新设置整型原子类的期望对象与期望版本
>             * */
>            if (reference.compareAndSet(object, this, version, this.expectedVersion+1)) {
>                this.value = newValue;
>                System.out.println(Thread.currentThread().getName() + "修改成功...");
>                // 哪个线程成功了哪个线程就退出
>                break;
>            } else {
>                try {
>                    //触发自旋锁
>                    TimeUnit.SECONDS.sleep(3);
>                    System.out.println(Thread.currentThread().getName() + "正在自旋式的等待执行...");
>                } catch (Exception e) {
>                    System.out.println("发生异常" + e.getMessage() + "sleep失败！");
>                }
>            }
>        }
>    }
>}
>```
>
>#### 测试类
>
>```java
>package casabaed;
>
>/**
> * @author MoFany-J
> * @date 2022/10/14
> * @description Test
> */
>public class Test {
>    public static void main(String[] args) {
>        /**
>         * 对象的初始值为A，初始版本为0
>         * */
>        ABADemo aba1 = new ABADemo('A'); //initValue
>        ABADemo aba2 = new ABADemo('A'); //initValue
>
>        /**
>         * 成功的操作，参数为：被操作对象、期望版本、新值
>         * */
>        new Thread(() -> {
>            // 同一个对象
>            aba1.newCompareAndSwap(aba1, 0, 'B');
>        }, "子线程1").start();
>
>        /**
>         * 失败的操作，参数为：被操作对象、期望版本、新值
>         * */
>        new Thread(() -> {
>            // 同一个对象，新版本号与期望版本号不一致
>            aba1.newCompareAndSwap(aba1, 5, 'B');
>        }, "子线程2").start();
>
>        /**
>         * 失败的操作，参数为：被操作对象、期望版本、新值
>         * */
>        new Thread(() -> {
>            // 不是同一个对象
>            aba2.newCompareAndSwap(aba1, 0, 'B');
>        }, "子线程3").start();
>    }
>}
>```
>
>* 测试结果
>
>  ```properties
>  子线程3--->期望版本为:0，新版本为:0
>  子线程2--->期望版本为:0，新版本为:5
>  子线程1--->期望版本为:0，新版本为:0
>  子线程1修改成功...
>  子线程3正在自旋式的等待执行...
>  子线程3--->期望版本为:0，新版本为:0
>  子线程2正在自旋式的等待执行...
>  子线程2--->期望版本为:1，新版本为:5
>  子线程2正在自旋式的等待执行...
>  子线程3正在自旋式的等待执行...
>  子线程2--->期望版本为:1，新版本为:5
>  子线程3--->期望版本为:0，新版本为:0
>  子线程2正在自旋式的等待执行...
>  子线程2--->期望版本为:1，新版本为:5
>  子线程3正在自旋式的等待执行...
>  子线程3--->期望版本为:0，新版本为:0
>  子线程2正在自旋式的等待执行...
>  子线程2--->期望版本为:1，新版本为:5
>  子线程3正在自旋式的等待执行...
>  子线程3--->期望版本为:0，新版本为:0
>  子线程3正在自旋式的等待执行...
>  子线程2正在自旋式的等待执行...
>  子线程2--->期望版本为:1，新版本为:5
>  子线程3--->期望版本为:0，新版本为:0
>  子线程3正在自旋式的等待执行...
>  子线程2正在自旋式的等待执行...
>  子线程2--->期望版本为:1，新版本为:5
>  子线程3--->期望版本为:0，新版本为:0
>  子线程3正在自旋式的等待执行...
>  子线程3--->期望版本为:0，新版本为:0
>  子线程2正在自旋式的等待执行...
>  子线程2--->期望版本为:1，新版本为:5
>  子线程3正在自旋式的等待执行...
>  子线程3--->期望版本为:0，新版本为:0
>  子线程2正在自旋式的等待执行...
>  子线程2--->期望版本为:1，新版本为:5
>  子线程3正在自旋式的等待执行...
>  子线程3--->期望版本为:0，新版本为:0
>  子线程2正在自旋式的等待执行...
>  子线程2--->期望版本为:1，新版本为:5
>  子线程2正在自旋式的等待执行...
>  子线程3正在自旋式的等待执行...
>  Exception in thread "子线程2" Exception in thread "子线程3" java.lang.RuntimeException: 子线程2自旋超过10次!
>  	at casabaed.ABADemo.newCompareAndSwap(ABADemo.java:52)
>  	at casabaed.Test.lambda$main$1(Test.java:29)
>  	at java.base/java.lang.Thread.run(Thread.java:834)
>  java.lang.RuntimeException: 子线程3自旋超过10次!
>  	at casabaed.ABADemo.newCompareAndSwap(ABADemo.java:52)
>  	at casabaed.Test.lambda$main$2(Test.java:37)
>  	at java.base/java.lang.Thread.run(Thread.java:834)
>  ```
>

# 显示锁Lock

## Lock接口`显示加锁与解锁`

>##### Lock接口中定义了一组无条件的、可轮询的、定时的、可中断的锁获取操作
>
>#### 统一锁释放方式
>
>- ##### 必须在`finally块`中调用`lock.unLock()`方法，进行锁释放否则该所永不被释放
>
>#### 无条件锁获取
>
>- ##### 加锁方式：`lock.lock()`
>
>#### 轮询锁获取
>
>- ##### 加锁方式：`lock.tryLock()`
>
>#### 定时锁获取
>
>- ##### 加锁方式：`lock.tryLock(时间,单位)`
>
>#### 可中断锁获取
>
>- ##### 加锁方式：`lock.lockInterruptibly()`
>
>

## `ReentrantLock`公平锁与非公平锁

>### 公平锁：`new ReentrantLock(true);`（构造器的参数为true时是公平锁）
>
>```java
>package reentrantlock;
>
>import java.util.concurrent.TimeUnit;
>import java.util.concurrent.locks.ReentrantLock;
>
>/**
> * @author MoFany-J
> * @date 2022/10/13
> * @description ReentrantLockDemo 实现公平锁
> */
>public class ReentrantLockDemo {
>    /**
>     * 公平锁：构造器参数为true时是公平锁，即一种可重入锁
>     */
>    private static ReentrantLock fairLock = new ReentrantLock(true);
>    
>    /**
>     * 非公平锁：构造器无参数时或为false时为非公平锁
>     */
>    private static ReentrantLock unfairLock = new ReentrantLock();
>
>    /**
>     * 主方法（主线程）
>     */
>    public static void main(String[] args) {
>        //循环控制不同线程访问的次数
>        Runnable runnable = () -> {
>            for (int i = 0; i < 5; i++) {
>                try {
>                    /**
>                    * 加锁
>                    */
>                    fairLock.lock();
>                    System.out.println(Thread.currentThread().getName() + "-->Start OK!");
>                    //线程睡眠
>                    TimeUnit.SECONDS.sleep(1);
>                } catch (Exception e) {
>                    System.out.println(e.getMessage());
>                } finally {
>                    /**
>                    * 释放锁
>                    */
>                    fairLock.unlock();
>                }
>            }
>        };
>        //创建线程
>        Thread thread1 = new Thread(runnable, "线程1");
>        Thread thread2 = new Thread(runnable, "线程2");
>        //启动线程
>        thread1.start();
>        thread2.start();
>    }
>}
>```
>
>```properties
># 两个线程直线彼此轮询的交替的执行
>线程1-->Start OK!
>线程2-->Start OK!
>线程1-->Start OK!
>线程2-->Start OK!
>线程1-->Start OK!
>线程2-->Start OK!
>线程1-->Start OK!
>线程2-->Start OK!
>线程1-->Start OK!
>线程2-->Start OK!
>
>Process finished with exit code 0
>```
>
>### 非公平锁：`new ReentrantLock(false)`或`new ReentrantLock()`
>
>```java
>package reentrantlock;
>
>import java.util.concurrent.TimeUnit;
>import java.util.concurrent.locks.ReentrantLock;
>
>/**
> * @author MoFany-J
> * @date 2022/10/13
> * @description ReentrantLockDemo 实现公平锁
> */
>public class ReentrantLockDemo {
>    /**
>     * 公平锁：构造器参数为true时是公平锁，即一种可重入锁
>     */
>    private static ReentrantLock fairLock = new ReentrantLock(true);
>    
>    /**
>     * 非公平锁：构造器无参数时或为false时为非公平锁
>     */
>    //private static ReentrantLock unfairLock = new ReentrantLock(false);
>    private static ReentrantLock unfairLock = new ReentrantLock();
>
>    /**
>     * 主方法（主线程）
>     */
>    public static void main(String[] args) {
>        //循环控制不同线程访问的次数
>        Runnable runnable = () -> {
>            for (int i = 0; i < 5; i++) {
>                try {
>                    /**
>                    * 加锁
>                    */
>                    unfairLock.lock();
>                    System.out.println(Thread.currentThread().getName() + "-->Start OK!");
>                    //线程睡眠
>                    TimeUnit.SECONDS.sleep(1);
>                } catch (Exception e) {
>                    System.out.println(e.getMessage());
>                } finally {
>                    /**
>                    * 释放锁
>                    */
>                    unfairLock.unlock();
>                }
>            }
>        };
>        //创建线程
>        Thread thread1 = new Thread(runnable, "线程1");
>        Thread thread2 = new Thread(runnable, "线程2");
>        //启动线程
>        thread1.start();
>        thread2.start();
>    }
>}
>```
>
>```properties
># 先执行抢占成功的线程，后执行另一个线程
>线程1-->Start OK!
>线程1-->Start OK!
>线程1-->Start OK!
>线程1-->Start OK!
>线程1-->Start OK!
>线程2-->Start OK!
>线程2-->Start OK!
>线程2-->Start OK!
>线程2-->Start OK!
>线程2-->Start OK!
>
>Process finished with exit code 0
>```

## ReadWriteLock接口`显示加锁与解锁`

>##### 提供了两种显示锁获取方式，读锁与写锁
>
>#### 统一锁释放方式
>
>- ##### 必须在`finally块`中调用`lock.unLock()`方法，进行锁释放否则该所永不被释放
>
>#### 读锁获取`readLock`
>
>* ##### 加锁方式：`lock.readLock()`
>
>#### 写锁获取
>
>* ##### 加锁方式：`lock.writeLock()`

## `ReentrantReadWriteLock`读锁与写锁

> #### 读写锁操作
>
> * 读写锁
>
>   ```java
>   ReadWriteLock lock = ReentrantReadWriteLock(); //向上转型
>   ```
>
>   * 读锁
>
>     ```java
>     ReadWriteLock lock = ReentrantReadWriteLock(); //向上转型
>     Lock readLock = lock.readLock(); // 读锁
>     ```
>
>   * 写锁
>
>     ```java
>     ReadWriteLock lock = ReentrantReadWriteLock(); //向上转型
>     Lock writeLock = lock.writeLock(); // 写锁
>     ```

# 乐观锁与悲观锁`PCC`

>#### 乐观锁与悲观锁
>
>>1. **悲观锁`独占锁`：**
>>   - `synchronized`（可重入锁）
>>   - `ReentrantLock`（可重入锁）
>>2. **乐观锁：**
>>   - `CAS指令`比较并交换
>>     - `CompareAndSet()`
>>   - `MVCC`版本号控制
>
>#### 原子操作类
>
>>1. 原子基本数据类型：
>>   * `AtomicInteger`
>>   * `AtomicLong`
>>   * `AtomicBoolean`
>>2. 原子引用数据类型：
>>   * `AtomicReference`无版本号的原子引用类
>>   * `AtomicStampReference`有版本号的原子引用类
>
>#### `ThreadLocal`
>
>> - 解决哈希冲突的的办法是：`开放定址法`
>> - 通过`ThreadLocal`创建每一个线程共享变量的副本，这个副本是线程独享的。

##  :accept:多线程通信`生产者消费者模式`

>利用了`wait()`方法与`notify()`方法进行代码实现。
>
>* 生产者：`Producer`生产者有库存就暂停生产并通知消费者消费
>* 仓库：`list集合实现`生产者与消费者共用同一个仓库
>* 消费者：`Consumer`消费者无库存时就暂停消费并通知生产者生产
>
>```java
>package producerandconsumer;
>
>import java.util.ArrayList;
>import java.util.List;
>
>/**
> * @author MoFany-J
> * @date 2022/10/13
> * @description Producer 生产者
> */
>public class Producer implements Runnable{
>    /**
>     * 成员属性为仓库，生产者与消费者公用一个仓库
>     * */
>    private List<String> wareHouse;
>    /**
>     * 生产者含有一个参数的构造器
>     * */
>    public Producer(List wareHouse){
>        //生产者与消费者公用一个仓库
>        this.wareHouse=wareHouse;
>    }
>    /**
>     * 接口实现类重写接口的方法
>     * */
>    @Override
>    public void run() {
>        synchronized (wareHouse){
>            //仓库中有库存时，通知消费者消费
>            if(wareHouse.size()>0){
>                try{
>                    //生产者停止生产，让消费者者先消费
>                    wareHouse.wait();
>                }catch (Exception e){
>                    e.getMessage();
>                }
>            }
>            String str="一个面包";
>            System.out.println(Thread.currentThread().getName()+"-->生产了："+str);
>            //仓库无内容时就由生产者开始生产
>            wareHouse.add(str);
>            //唤醒消费者者消费
>            wareHouse.notify();
>        }
>    }
>}
>```
>
>```java
>package producerandconsumer;
>
>import java.util.ArrayList;
>import java.util.List;
>
>/**
> * @author MoFany-J
> * @date 2022/10/13
> * @description Consumer 消费者
> */
>public class Consumer implements Runnable{
>    /**
>     * 成员属性为仓库，生产者与消费者公用一个仓库
>     * */
>    private List<String> wareHouse;
>    /**
>     * 消费者含有一个参数的构造器
>     * */
>    public Consumer(List wareHouse ){
>        //生产者与消费者公用一个仓库
>        this.wareHouse=wareHouse;
>    }
>
>    /**
>     * 接口实现类重写接口的方法
>     * */
>    @Override
>    public void run() {
>        synchronized (wareHouse){
>            //仓库没有库存时，通知生产者生产
>            if(wareHouse.size()<=0){
>                try{
>                    //消费者停止消费，让生产者先生产
>                    wareHouse.wait();
>                }catch (Exception e){
>                    e.getMessage();
>                }
>            }
>            //仓库有内容就由消费者开始消费
>            String content=wareHouse.remove(0);
>            System.out.println(Thread.currentThread().getName()+"-->消费了："+content);
>            //唤醒生产者生产
>            wareHouse.notify();
>        }
>    }
>}
>```
>
>```java
>package producerandconsumer;
>
>import java.util.ArrayList;
>import java.util.List;
>
>/**
> * @author MoFany-J
> * @date 2022/10/13
> * @description Test 测试类用于测试生产者消费者模式,负责测试两个线程之间的通信
> */
>public class Test {
>    public static void main(String[] args){
>        //仓库
>        List<String> wareHouse=new ArrayList<>();
>        //生产者可运行对象
>        Producer producer=new Producer(wareHouse);
>        //消费者可运行对象
>        Consumer consumer=new Consumer(wareHouse);
>        //创建生产者线程
>        Thread producerThread=new Thread(producer,"生产者");
>        //创建消费者线程
>        Thread consumerThread=new Thread(consumer,"消费者");
>        //启动生产者与消费者线程
>        producerThread.start();
>        consumerThread.start();
>    }
>}
>```
>
>```properties
>生产者-->生产了：一个面包
>消费者-->消费了：一个面包
>
>Process finished with exit code 0
>```
>

# 创建线程的四种方法

## :abcd:`Thread线程类`（不能实现资源数据的共享）

>#### Thread类中决定线程优先级的静态常量：
>
>**`优先级高的线程可能会抢占到CUP的时间片的次数多一些，并不代表优先级高的线程一定会优先执行。`**
>
>* `min_priority `  1 最小优先级
>* `normal_priority`  5 普通优先级（默认优先级）
>* `max_priority`  10 最大优先级
>
>#### 线程调度
>
>* 分时模型：
>
>  在分时模型中，CPU资源是按照时间片来分配的，获得CPU资源的线程只能在指定的时间片内执行，一旦时间片使用完毕，就必须将CPU让给另外一个处于就绪状态的线程。在分时模型中，线程本身不会让出CPU。
>
>* **抢占模型：`java所用模式`**
>
>  ***在抢占模型中，当前活动的线程一旦获得执行权，将一直执行下去，直到执行完毕或由于某种原因主动放弃执行权。如在一个低优先级线程的执行过程中，又有一个高优先级的线程准备就绪，那么低优先级的线程就把 CPU资源让给高优先级的线程。为了使低优先级的线程有机会执行，高优先级的线程应该不时地主动进入“ 休眠 ”状态，而暂时让出CPU。java语言所支持的就是抢占式调度模型。***
>
>#### 通过`Thread类`创建线程：
>
>1. **此线程类必须是继承自`Thread类`的子类。**
>2. 线程所要执行的代码必须写在`run()`方法中。`即Thread类的子类必须重写父类的run()方法`
>3. 一个线程总是从`run()方法`处开始执行，`run()方法`是线程的起点方法，就类似于`main()`方法是应用程序的执行起点一样。
>4. 先创建自定义线程类的对象，然后通过该线程类对象去调用`start()`方法来激活自定义线程从而执行`run()方法`。
>5. **通过`Thread类`创建线程类后，可以直接使用`this`子句来表示当前的线程对象，而不用在通过`Thread.current()`方法来获取当前正在执行的线程类的对象。**
>
>```java
>package thread;
>
>/**
> * @author MoFany-J
> * @date 2022/10/5
> * @description ThreadDemo 线程类继承Thread类
> */
>public class ThreadDemo extends Thread {
>    /**
>     * 线程类的成员属性
>     * */
>
>    /**
>     * 线程类的成员方法
>     * */
>
>    /**
>     * 重写自父类的run()方法，该线程方法又由start()方法启动执行
>     */
>    @Override
>    public void run() {
>        //获取当前正在执行的线程对象的名字
>        System.out.println("OK\t" + Thread.currentThread().getName());
>        //所要执行的线程的代码
>        System.out.println("Hello World!");
>    }
>}
>```
>
>```java
>package thread;
>
>/**
> * @author MoFany-J
> * @date 2022/10/5
> * @description ExecuteThread
> */
>public class ExecuteThread {
>    public static void main(String[] args) {
>
>        //1.创建自定义线程类的对象
>        ThreadDemo thread = new ThreadDemo();
>        //2.由自定义线程类调用父类的start()方法激活线程类，然后执行run()方法
>        thread.start();
>    }
>}
>```
>

------

## :abcd:`Runnable函数式接口`(没有返回值可实现资源数据的共享)

>### Runnable接口的源码：
>
>```java
>/**
> * Runnable接口是一个函数式接口:
> * 	1.可以创建该接口的实现类，通过Thread包装线程实现类对象去激活线程。
> * 	2.可以使用Lambda表达式，创建该函数式接口的实例：Runnable runnable = () -> {......};
> */
>@FunctionalInterface
>public interface Runnable {
>
>    public abstract void run();
>}
>```
>
>### 通过`Runnable接口`创建线程：Runnable中的异常只能处理不能抛出
>
>1. **此线程类必须是`Runnable接口`的实现类。**
>2. `Runnable接口`的实现类同样得重写`run()方法`。
>3. 激活此线程的方法依然是创建该线程类的实例，然后通过`Thread类`的实例调用`start()方法`去激活该线程，然后从线程类的`run()方法`开始执行。
>4. **重点：**
>   * ==先创建`Thread接口`实现类的实例。==
>   * ==然后将该实例包装为`Thread类`的实例（通过`Thread(Runnable target)`构造器包装）。==
>   * ==最后利用`Thread类`的实例去调用`start()`方法激活线程，执行`run()方法`。==
>
>```java
>package thread;
>
>/**
> * @author MoFany-J
> * @date 2022/10/5
> * @description RunnableDemo 线程类实现Runnable接口
> */
>public class RunnableDemo implements Runnable {
>    /**
>     * 线程类的成员属性
>     * */
>
>    /**
>     * 线程类的成员属性
>     * */
>
>    /**
>     * 重写自Runnable接口的run()方法，该线程方法又由start()方法启动执行
>     */
>    @Override
>    public void run() {
>
>        //获取当前正在运行线程对象的名字
>        System.out.println("OK\t" + Thread.currentThread().getName());
>        //所要执行的线程的代码
>        System.out.println("Hello World!");
>    }
>}
>```
>
>```java
>package thread;
>
>/**
> * @author MoFany-J
> * @date 2022/10/5
> * @description ExecuteRunnable
> */
>public class ExecuteRunnable {
>    public static void main(String[] args) {
>
>        //1.创建自定义线程类的对象
>        RunnableDemo runnable = new RunnableDemo();
>        //2.将线程类对象包装为Thread类实例
>        Thread thread = new Thread(runnable);
>        //3.由Thread类实例调用start()方法激活线程类，然后执行run()方法
>        thread.start();
>    }
>}
>```
>

------

## :abcd:`Callable函数式接口`（具有返回值可实现资源数据共享）

>### Callable接口的源码：
>
>```java
>/**
> * Callable接口是一个函数式接口：
> * 	1.可以创建该接口的实现类，通过Thread包装线程实现类对象去激活线程。
> * 	2.可以使用Lambda表达式，创建该函数式接口的实例：Callable callable = ()->{return .....};
> */
>@FunctionalInterface
>public interface Callable<V> {
>
>    V call() throws Exception;
>}
>```
>
>### 通过`Callable接口`创建线程：
>
>* ==**`FutureTask`可用于包装`Callable接口`或`Runnable接口`对象。**== 
>* 因为`FutureTask`实现了`Runnable` 、  `FutureTask`接口，故可以将`FutureTask`提交给`Executor`以供执行。
>
>```java
>package thread;
>
>import java.util.concurrent.Callable;
>
>/**
> * @author MoFany-J
> * @date 2022/10/5
> * @description CallableDemo 线程类实现Callable接口
> */
>class CallableDemo implements Callable<String> {
>    /**
>     * 线程类的成员属性
>     * */
>
>    /**
>     * 线程类的成员方法
>     * */
>
>    /**
>     * 重写自Callable接口的call()方法
>     */
>    @Override
>    public String call() throws Exception {
>        //返回当前正在执行的线程对象的名字
>        System.out.println("OK\t" + Thread.currentThread().getName());
>        //所要执行的线程的代码
>        return "Hello World!";
>    }
>}
>```
>#### 第一种使用形式：
>
>```java
>package thread;
>
>import java.util.concurrent.FutureTask;
>
>/**
> * @author MoFany-J
> * @date 2022/10/5
> * @description ExcuteCallable 主类用于激活线程
> */
>public class ExcuteCallable {
>
>    public static void main(String[] args) {
>
>        //1.创建自定义线程类的对象
>        CallableDemo callable = new CallableDemo();
>        //2.创建未来任务的对象
>        FutureTask<String> task = new FutureTask(callable);
>        //3.将未来任务对象包装为Thread类实例（FutureTask接口实现了Runnable接口）
>        Thread thread = new Thread(task);
>        //4.激活线程类，然后执行run()方法
>        thread.start();
>
>        /**
>        * 5.获取线程执行结果，即获取call()方法的返回值（记得在调用点捕获异常）
>        */
>        try {
>            System.out.println(task.get());
>        } catch (Exception e) {
>
>            System.out.println("获取线程结果失败！");
>        }
>    }
>}
>```
>#### 第二种使用形式：
>
>```java
>package thread;
>
>import java.util.concurrent.ExecutorService;
>import java.util.concurrent.Executors;
>import java.util.concurrent.FutureTask;
>
>/**
> * @author MoFany-J
> * @date 2022/10/9
> * @description ExecuteCallableDemo
> */
>public class ExecuteCallableDemo {
>    public static void main(String[] args){
>
>        //1.创建自定义线程类对象
>        CallableDemo callable=new CallableDemo();
>        //2.包装线程类对象为一个未来任务对象
>        FutureTask<String> task=new FutureTask<>(callable);
>        
>        //3.创建一个ExcutorService类对象，并创建一个单线程池
>        //Executors是创建线程池要用到的一个工具类
>        //Executor是一个接口,该接口被ExecutorService类实现
>        ExecutorService threadPool=Executors.newSingleThreadExecutor();
>        
>        /**
>        * 1.提交有返回结果的任务：
>        *	threadPool.submit(task);
>        *
>        * 2.执行无返回结果的任务：
>        * 	threadPool.execute(task);
>        */
>        threadPool.execute(task);
>        
>        try{
>            //输出任务返回值
>            System.out.println(task.get());
>        }catch (Exception e){
>            e.printStackTrace();
>        }finally {
>            //平缓的关闭线程池
>            threadPool.shutdown();
>        }
>    }
>}
>```
>#### 使用`submit()`提交任务并获取返回结果
>
>* `submit()`既可以提交Runnable类型的任务，也可以提交Callable类型的任务。
>* `submit()`会有一个类型为Future的返回值，但当任务类型为Runnable时，返回值为null。
>
>```java
>package thread;
>
>import java.util.concurrent.ExecutionException;
>import java.util.concurrent.ExecutorService;
>import java.util.concurrent.Executors;
>import java.util.concurrent.FutureTask;
>
>/**
> * @author MoFany-J
> * @date 2022/10/9
> * @description ExecuteCallableDemo1
> */
>public class ExecuteCallableDemo1 {
>    public static void main(String[] args) throws ExecutionException, InterruptedException {
>
>        //1.创建自定义线程类对象
>        CallableDemo callable=new CallableDemo();
>        //2.包装线程类对象为一个未来任务对象
>        FutureTask<String> task=new FutureTask<>(callable);
>        //3.创建一个ExcutorService类对象，并创建一个单线程池
>        ExecutorService threadPool=Executors.newSingleThreadExecutor();
>        
>        /**
>        * 4.提交带有result的任务，并返回其值
>        */
>        System.out.println(threadPool.submit(task,"I am task!!!").get());
>        //5.平缓关闭线程池
>        threadPool.shutdown();
>    }
>}
>
>```
>
>```properties
>####《执行结果》####
>OK	pool-1-thread-1
>I am task!!!
>
>Process finished with exit code 0
>```
>
>#### 使用`execute()`执行任务但无法获取返回结果
>
>* `execute`只能提交Runnable类型的任务，无返回值。
>
>```java
>package thread;
>
>import java.util.concurrent.ExecutorService;
>import java.util.concurrent.Executors;
>import java.util.concurrent.FutureTask;
>
>/**
> * @author MoFany-J
> * @date 2022/10/9
> * @description ExecuteCallableDemo2
> */
>public class ExecuteCallableDemo2 {
>    public static void main(String[] args){
>
>        //1.创建自定义线程类对象
>        CallableDemo callable=new CallableDemo();
>        //2.包装线程类对象为一个未来任务对象
>        FutureTask<String> task=new FutureTask<>(callable);
>        //3.创建一个ExcutorService类对象，并创建一个单线程池
>        ExecutorService threadPool=Executors.newSingleThreadExecutor();
>        
>        /**
>        * 4.执行任务，无法获取其返回值
>        */
>        threadPool.execute(task);
>        try{
>            /**
>            * 5.输出任务返回值，通过任务FutureTask来获取返回值
>            */
>            System.out.println(task.get());
>        }catch (Exception e){
>            e.printStackTrace();
>        }finally {
>            //6.平缓的关闭线程池
>            threadPool.shutdown();
>        }
>    }
>}
>```
>
>```properties
>####《执行结果》####
>OK	pool-1-thread-1
>Hello World!
>
>Process finished with exit code 0
>```
>
>#### Runnable与Callable的区别与优缺点：
>
>* **线程类只是实现自`Runnable`或`Callable`接口，此时线程类也还可以继承其它的类。**
>* 这种方式下线程可以共享同一个target对象（`Runnable target`或`Callable target`），故非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，更好的体现了面向对象的思想。
>* 缺点是编写的代码略微复杂！每当需要访问当前对象都需要使用`Thread.currentThread()`方法。
>
>#### Thread线程类的优缺点：
>
>* 优点是编写简单，若需要访问当前线程对象直接可以使用`this`，而无需使用`Thread.currentThread()`方法。
>* 缺点是若线程类继承自`Thread`类，故不能再继承其它父类。

------

## :abcd:`线程池`（池化思想）

>#### 线程池
>
>>* **指管理一组同构工作线程的资源池。**线程池是与工作队列（work Queue）密切相关，在工作队列中保存了所有等待执行的任务。而工作者线程（Woker Thread）的任务是从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。
>>
>>* 线程池通过重用现有的线程，可以在处理多个请求时分摊以往在线程创建和销毁过程中产生的巨大开销。**额外的好处是：若当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。**通过适当调整线程池的大小，可以创建足够多的线程以便使处理器保持忙碌状态，同时还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。
>
>------
>
>#### 创建线程池的方法：
>
>1. ==**通过`Executor`框架创建线程池。**==
>   * `Executor`接口有两个子接口：`ExecutorService接口`与`ScheduledExecutorService接口`利用多态再结合`Executor工具类`提供的创建线程池的相关方法就可以创建线程池。
>
>#### 工具类`Executors`提供了四种不同类型线程池的实现：
>
>| 静态方法（四种基本线程池）                 | 创建的线程池的作用                                     |
>| ------------------------------------------ | ------------------------------------------------------ |
>| `newCachedThreadPool()`                    | 可缓存线程池，可伸缩的线程池`无界限的，没有大小限制的` |
>| `newSingleThreadExecutor()`                | 单线程化的线程池`只有单个线程`                         |
>| `newFixedThreadPool(int nThreads)`         | 定长线程池`可控制线程最大并发数，超出线程在对列中等待` |
>| `newScheduledThreadPool(int corePoolSize)` | 定长定时线程池`支持定时及周期性的任务执行`             |
>
>### **利用线程池创建线程：**:a:（方法1：Executors工具类）
>
>>**阿里巴巴规范规定严格规定禁用Executor框架这种方法创建线程池**
>>
>>1. `newFixedThreadPool`和`newSingThreadExecutor`所允许的最大请求队列长度为`Integer.MAX_VALUE`，故使用这种方式可能会堆积大量请求，从而导致OOM。（内存溢出Out Of Memory）
>>2. `newCachedThreadPool`和`newScheduledThreadPool`所允许的创建线程的最大数量为`Integer.MAX_VALUE`，从而导致OOM。（内存溢出Out Of Memory）
>
>```java
>/**
> * 利用Executors提供的四种创建线程池的方法创建线程
> * Executors是创建线程池要用到的一个工具类
> */
>package thread;
>
>import java.util.concurrent.ExecutorService;
>import java.util.concurrent.Executors;
>import java.util.concurrent.ScheduledExecutorService;
>
>/**
> * @author MoFany-J
> * @date 2022/10/4
> * @description ThreadPoolDemo1 利用线程池创建线程（四种线程池）
> */
>public class ThreadPoolDemo1 {
>    public static void main(String[] args) {
>        //创建一个带有缓存的线程池，只能使用Runnable的同步方式
>        ExecutorService threadPool = Executors.newCachedThreadPool();
>        //创建一个单线程的线程池
>        //ExecutorService threadPool = Executors.newSingleThreadExecutor();
>        //创建一个定长线程池(可控制线程最大并发数，超出线程则在等待阻塞队列中等待)
>        //ExecutorService threadPool = Executors.newFixedThreadPool(5);
>        //创建一个定长定时线程池(支持定时及周期性的任务执行)，结合调用schedule()定时方法
>        //ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(5);
>
>        try {
>            //利用线程池创建10个线程
>            for (int i = 0; i < 10; i++) {
>                //execute()只是单纯的执行，不能获取返回值，但是submit()可以获取返回值
>                threadPool.execute(() -> {
>                    //返回当前执行的线程的信息,即返回当前正在执行的线程对象的名字
>                    System.out.println("OK\t" + Thread.currentThread().getName());
>                });
>            }
>
>        } catch (Exception e) {
>            //打印堆栈使用轨迹
>            e.printStackTrace();
>        } finally {
>            //以平缓方式关闭线程池
>            threadPool.shutdown();
>            //强制关闭线程池：threadPool.shutdownNow()
>        }
>    }
>}
>```
>
>------
>
>#### `ThreadPoolExecutors`提供了7大核心参数
>
>| 核心参数名                          | 作用                                                   |
>| ----------------------------------- | ------------------------------------------------------ |
>| `int corePoolSize`                  | 线程池的常驻核心线程数（基础）                         |
>| `int maximumPoolSize`               | 线程池在任务最多时，最大可以创建的线程数               |
>| `long keepAliveTime`                | 线程池中除核心线程之外的线程的存活时间或空闲等待时间   |
>| `TimeUnit unit`                     | 线程存活时间单位（天、时、分、秒、毫秒、微秒、纳秒）   |
>| `BlockingQueue<Runnable> workQueue` | 等待阻塞队列，表示线程池执行的任务队列（空闲等待队列） |
>| `ThreadFactory threadFactory`       | 线程的创建工厂                                         |
>| `RejectedExecutionHandler handler`  | 线程池的拒绝策略                                       |
>
>#### `ThreadPoolExecutors`线程池的四种拒绝策略
>
>1. **`new ThreadPoolExecutor.AbortPolicy()`**==（默认拒绝策略）==
>   * 当前线程池中的线程数超过`maximumPoolSize`时，不再处理，并且抛出异常
>
>2. **`new ThreadPoolExecutor.CallerRunsPolicy()`**==（执行不了的任务调用主线程帮忙执行）==
>   * 当前线程池中的线程数超过`maximumPoolSize`时，先由当前线程来执行任务
>
>   * 当前线程忙不过来时会调用主线程即main()方法所在线程，帮忙分担执行任务
>
>3. **`new ThreadPoolExecutor.DiscardPolicy()`**==（执行不了的任务直接拒绝，不抛异常）==
>   * 当前线程池中的线程数超过`maximumPoolSize`时，丢弃当前任务，但不抛出异常
>
>4. **`new ThreadPoolExecutor.DiscardOldestPolicy()`**==（拒绝等待时间最长年龄最大的任务，不抛异常）==
>   * 当前线程池中的线程数超过`maximumPoolSize`时，丢弃等待时间最长的任务，但不抛出异常
>
>#### 四种空闲等待队列（等待阻塞队列）：
>
>- **直接队列`SynchronousQueue`**没有容量，每执行一个插入操作就会阻塞，当创建的线程超过线程池的最大线程数时会直接执行拒绝策略。
>- **无界队列`LinkedBlockingQueue`**没有限制范围大小的队列
>- **有界队列`ArrayBlockingQueue`**有范围大小限制的的队列
>- **优先级队列`PriorityBlockingQueue`**其是一个特殊的无界队列，可以设置指定线程的优先级
>
>#### `ThreadFactory`线程工厂
>
>* 无参构造器：`ThreadFactory()`
>* 有参构造器：`ThreadFactory(...)`
>
>### **利用线程池创建线程：**:b:（方法2，`ThreadPoolExecutors`建议使用该方法）
>
>| （Thread类）方法名              | 作用                               |
>| ------------------------------- | ---------------------------------- |
>| `static Thread currentThread()` | 返回对当前正在执行的线程对象的引用 |
>| `String getName()`              | 返回此线程的名称                   |
>
>```java
>/**
> * 利用ThreadPoolExecutors创建线程池并创建对象
> */
>package thread;
>
>import java.util.concurrent.ArrayBlockingQueue;
>import java.util.concurrent.Executors;
>import java.util.concurrent.ThreadPoolExecutor;
>import java.util.concurrent.TimeUnit;
>
>/**
> * @author MoFany-J
> * @date 2022/10/4
> * @description ThreadPoolDemo2 利用7大核心参数创建线程池
> */
>public class ThreadPoolDemo2 {
>    public static void main(String[] args){
>        //最大线程池数为：JVM可用的处理器数
>        int maxPools=Runtime.getRuntime().availableProcessors();
>        System.out.println("JVM可用的处理器数为："+maxPools);
>
>        //创建线程池,并指定七大核心参数
>		ThreadPoolExecutor threadPool=new ThreadPoolExecutor(
>			//线程池的常驻核心线程数
>			2,
>			//线程池在任务最多时，最大可以创建的线程数
>			maxPools,
>			//线程池中除核心线程之外的线程的存活时间
>			3,
> 			//线程存活时间单位
>			TimeUnit.SECONDS,
>			//等待阻塞队列，表示线程池执行的任务队列(空闲等待队列)
>			new ArrayBlockingQueue<>(3),
>			//线程的创建工厂
>			Executors.defaultThreadFactory(),
>			//线程池的拒绝策略
>			new ThreadPoolExecutor.DiscardOldestPolicy()
>	);
>
>        try{
>            //利用线程池创建20个线程
>            for (int i=0;i<20;i++){
>                threadPool.execute(()->{
>                   //返回当前执行的线程的信息,即返回当前正在执行的线程对象的名字
>                    System.out.println("OK\t"+Thread.currentThread().getName());
>                });
>            }
>        }catch (Exception e){
>            //打印堆栈使用轨迹
>            e.printStackTrace();
>        }finally {
>            //以平缓方式关闭线程池
>            threadPool.shutdown();
>        }
>    }
>}
>```
>
>#### 线程池的大小如何确定？
>
>* `IO密集型：核心数*2`
>* `计算密集型：核心数+1`
>
>| （Runtime类）方法名           | 作用                                     |
>| ----------------------------- | ---------------------------------------- |
>| `static Runtime getRuntime()` | 返回与当前Java应用程序关联的运行时对象。 |
>| `int availableProcessors()`   | 返回JVM可用的处理器数。                  |
>
>```java
>//线程池大小为：JVM可用的处理器数
>int maxPools = Runtime.getRuntime().availableProcessors();
>```
>
>#### 创建线程池的核心代码：
>
>```java
>//创建线程池,并指定七大核心参数
>ThreadPoolExecutor threadPool=new ThreadPoolExecutor(
>	//线程池的常驻核心线程数
>	2,
>	//线程池在任务最多时，最大可以创建的线程数
>	maxPools,
>	//线程池中除核心线程之外的线程的存活时间
>	3,
> 	//线程存活时间单位
>	TimeUnit.SECONDS,
>	//等待阻塞队列，表示线程池执行的任务队列
>	new ArrayBlockingQueue<>(3),
>	//线程的创建工厂
>	Executors.defaultThreadFactory(),
>	//线程池的拒绝策略
>	new ThreadPoolExecutor.DiscardOldestPolicy()
>);
>```
>
>
>### `execute()`方法与`submit()`方法的区别与执行过程：
>
>1. 两者区别：
>
>   * `execute()`
>     * 只是单纯的执行，不能获取返回值。
>     * 只能实现`Runnable接口类型`的任务且异常会直接抛出。
>
>   * `submit()`
>     * 可以获取返回值，且异常不会直接抛出。
>     * 其一般通过`Future.get()`方法抛出异常。
>     * 对应`Runnable接口类型`的任务与`Callable接口类型`的任务其都可以实现执行。
>
>2. 执行过程及源码分析：
>
>   * **`execute()方法源码解析：`**
>
>   ```java
>   /**
>    * 源码
>    */
>   public void execute(Runnable command) {
>       if (command == null)
>           //抛出空指针异常
>           throw new NullPointerException();
>       int c = ctl.get();
>       //线程池：当前线程数 < 最大线程数
>       if (workerCountOf(c) < corePoolSize) {
>           //创建新线程执行此任务
>           // addWorker(Runnable firstTask, boolean core) 参数：
>           //firstTask，线程应首先运行的任务，如果没有则可以设置为 null； 
>           //core，判断是否可以创建线程的阀值（最大值）, 
>           //true 则表示使用 corePoolSize 作为阀值，false 则表示使用 maximumPoolSize 作为阀值。
>           if (addWorker(command, true))
>               return;
>           c = ctl.get();
>       }
>       // 检查线程池是否处于运行状态，如果是则把任务添加到队列，否则直接执行拒绝策略
>       if (isRunning(c) && workQueue.offer(command)) {
>           int recheck = ctl.get();
>           // 再次检查线程池是否处于运行状态，防止在第一次校验通过后线程池关闭
>           // 如果是非运行状态，则将刚加入队列的任务移除
>           if (! isRunning(recheck) && remove(command))
>               //执行拒绝策略
>               reject(command);
>           // 如果线程池的线程数为 0 时（当 corePoolSize 设置为 0 时会发生）
>           else if (workerCountOf(recheck) == 0)
>              	//新建线程执行任务
>               addWorker(null, false);
>       }
>       // 核心线程都在忙且队列都已爆满，尝试新启动一个线程执行失败
>       else if (!addWorker(command, false))
>           //执行拒绝策略
>           reject(command);
>   }
>   ```
>
>

